<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.4 $ -->
<!-- EN-Revision: 1.10 Maintainer: hirokawa Status: working -->
<!-- CREDITS: shimooka -->
<!-- Author: Wez Furlong <wez@thebrainroom.com>
  Please contact me before making any major amendments to the
  content of this section.  Splitting/Merging are fine if they are
  required for php-doc restructuring purposes - just drop me a line
  if you make a change (so I can update my local copy).
-->

<chapter id="streams">
 <title>PHP拡張モジュールの作者用のストリームAPI</title>

 <sect1 id="streams.overview">
  <title>概要</title>
  <para>
    PHPストリームAPIは、PHP拡張モジュールにファイルおよびソケット処理
    用の統一化された手段を導入するものです。
    共通の操作を行なうための標準関数を有する単一のAPIを使用することに
    より、ストリームAPIは拡張モジュールがファイル、ソケット、URL、メモリ
    スクリプトが定義したオブジェクトにアクセスすることを可能にします。
    ストリームは、新規ストリームを登録するために動的にロードされる
    モジュール(およびスクリプト!)とすることができる実行時に拡張可能な
    APIです。
  </para>
  <para>
    ストリームAPIの目的は、ファイル、URL、その他のストリームにできるデータ
    ソースを平易な統一されたAPIにより、開発者が容易にオープンできるように
    することです。APIは、ほぼANSI C stdio関数と(多くの主な関数について同等
    の意味を有しており、)類似しています。このため、Cプログラマは、
    ストリームに慣れている印象を受けるはずです。
  </para>
  <para>
    ストリームAPIは、いくつかの異なるレベルを処理します。
    基本レベルでは、APIはストリーマブルなデータソースを表す
    php_streamオブジェクトを定義します。
    やや高いレベルでは、APIは、URLからのデータおよびメタデータの取得を
    サポートするために低レベルAPIをラップしたphp_stream_wrapper
    オブジェクトを定義します。
    An additional <literal>context</literal>
    parameter, accepted by most stream creation functions, is passed to the
    wrapper's <literal>stream_opener</literal> method to fine-tune the behavior
    of the wrapper.
   </para>
   <para>
    Any stream, once opened, can also have any number of <literal>filters</literal>
    applied to it, which process data as it is read from/written to the stream.
   </para>
   <para>
    ストリームは、ファイル処理の他の形式にキャスト(変換)でき、
    大きな問題もなくサードパーティ製のライブラリと組み合わせて使用する
    ことができます。これにより、これらのライブラリがURLソースからデータに
    直接アクセスできるようになります。
    使用するシステムに<function>fopencookie</function>または
    <function>funopen</function>関数がある場合、
    任意のPHPストリームをANSI stdioを使う任意のライブラリに渡すことさえ
    できます!
   </para>
   <para>
    <note>
    <para>
      The functions in this chapter are for use in the PHP source code and
      are not PHP functions.  Userland stream functions can be found in the
      <link linkend="ref.stream">Stream Reference</link>.
     </para>
    </note>
   </para>
  </sect1>

  <sect1 id="streams.basics">
   <title>ストリームの基本</title>
   <para>
    ストリームの使用方法は、ANSI stdio関数の使用と非常に似ています。
    主な違いは、使用を開始するストリームを得る方法です。
    多くの場合、ストリームのハンドルを得るために
    <function>php_stream_open_wrapper</function>を使用します。
    この関数の動作は、以下の例で示すようにfopenと非常によくにています。
   </para>
   <para>
    <example>
     <title>PHPホームページを表示するための簡単なストリームの例</title>
     <programlisting role="c">
<![CDATA[
php_stream * stream = php_stream_open_wrapper("http://www.php.net", "rb", REPORT_ERRORS, NULL);
if (stream) {
    while(!php_stream_eof(stream)) {
        char buf[1024];

        if (php_stream_gets(stream, buf, sizeof(buf))) {
            printf(buf);
        } else {
            break;
        }
    }
    php_stream_close(stream);
}
]]>
      </programlisting>
     </example>
  </para>
  <para>
    以下の表にその他の一般的なANSI stdio関数と等価なストリーム関数を
    示します。注記で除外されていない限り、関数の意味は同じです。
    <table>
     <title>ANSI stdioと等価なストリームAPI関数</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>ANSI stdio関数</entry>
         <entry>PHP ストリーム関数</entry>
         <entry>注意</entry>
        </row>
       </thead>
       <tbody>

        <row>
         <entry>fopen</entry>
         <entry>php_stream_open_wrapper</entry>
         <entry>ストリームではパラメータが増えています</entry>
        </row>

        <row>
         <entry>fclose</entry>
         <entry>php_stream_close</entry>
         <entry></entry>
        </row>

        <row>
         <entry>fgets</entry>
         <entry>php_stream_gets</entry>
         <entry></entry>
        </row>

        <row>
         <entry>fread</entry>
         <entry>php_stream_read</entry>
         <entry>パラメータnmembの値を1と仮定すると、プロトタイプはread(2)により似ることになります</entry>
        </row>

        <row>
         <entry>fwrite</entry>
         <entry>php_stream_write</entry>
         <entry>パラメータnmembの値を1と仮定すると、プロトタイプはwrite(2)により似ることになります</entry>
        </row>

        <row>
         <entry>fseek</entry>
         <entry>php_stream_seek</entry>
         <entry></entry>
        </row>

        <row>
         <entry>ftell</entry>
         <entry>php_stream_tell</entry>
         <entry></entry>
        </row>

        <row>
         <entry>rewind</entry>
         <entry>php_stream_rewind</entry>
         <entry></entry>
        </row>

        <row>
         <entry>feof</entry>
         <entry>php_stream_eof</entry>
         <entry></entry>
        </row>

        <row>
         <entry>fgetc</entry>
         <entry>php_stream_getc</entry>
         <entry></entry>
        </row>

        <row>
         <entry>fputc</entry>
         <entry>php_stream_putc</entry>
         <entry></entry>
        </row>

        <row>
         <entry>fflush</entry>
         <entry>php_stream_flush</entry>
         <entry></entry>
        </row>

        <row>
         <entry>puts</entry>
         <entry>php_stream_puts</entry>
         <entry>fputsではなく、putsと同じ意味</entry>
        </row>

        <row>
         <entry>fstat</entry>
         <entry>php_stream_stat</entry>
         <entry>ストリームはより情報の多いstat構造体を有しています</entry>
        </row>

       </tbody>
      </tgroup>
     </table>

  </para>
 </sect1>

 <sect1 id="streams.resources">
  <title>リソースとしてのストリーム</title>
  <para>
   All streams are registered as resources when they are created.  This ensures
   that they will be properly cleaned up even if there is some fatal error.
   All of the filesystem functions in PHP operate on streams resources - that
   means that your extensions can accept regular PHP file pointers as
   parameters to, and return streams from their functions.
   The streams API makes this process as painless as possible:
  </para>
  <para>
     <example>
      <title>How to accept a stream as a parameter</title>
      <programlisting role="c">
<![CDATA[
PHP_FUNCTION(example_write_hello)
{
    zval *zstream;
    php_stream *stream;

    if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r", &zstream))
        return;

    php_stream_from_zval(stream, &zstream);

    /* you can now use the stream.  However, you do not "own" the
        stream, the script does.  That means you MUST NOT close the
        stream, because it will cause PHP to crash! */

    php_stream_write(stream, "hello\n");

    RETURN_TRUE();
}
]]>
      </programlisting>
     </example>
  </para>
  <para>
     <example>
      <title>How to return a stream from a function</title>
      <programlisting role="c">
<![CDATA[
PHP_FUNCTION(example_open_php_home_page)
{
    php_stream *stream;

    stream = php_stream_open_wrapper("http://www.php.net", "rb", REPORT_ERRORS, NULL);

    php_stream_to_zval(stream, return_value);

    /* after this point, the stream is "owned" by the script.
        If you close it now, you will crash PHP! */
}
]]>
      </programlisting>
     </example>
  </para>
  <para>
   Since streams are automatically cleaned up, it's tempting to think that we can get
   away with being sloppy programmers and not bother to close the streams when we
   are done with them.  Although such an approach might work, it is not a good idea
   for a number of reasons: streams hold locks on system resources while they are
   open, so leaving a file open after you have finished with it could prevent other
   processes from accessing it.  If a script deals with a large number of files,
   the accumulation of the resources used, both in terms of memory and the
   sheer number of open files, can cause web server requests to fail.  Sounds
   bad, doesn't it?  The streams API includes some magic that helps you to
   keep your code clean - if a stream is not closed by your code when it should
   be, you will find some helpful debugging information in you web server error
   log.
  </para>
  <note>
   <simpara>
    Always use a debug build of PHP when developing an extension
    (<option>--enable-debug</option> when running configure), as a lot of
    effort has been made to warn you about memory and stream leaks.
   </simpara>
  </note>
  <para>
   In some cases, it is useful to keep a stream open for the duration of a request,
   to act as a log or trace file for example.  Writing the code to safely clean up
   such a stream is not difficult, but it's several lines of code that are not
   strictly needed.  To save yourself the trouble of writing the code, you
   can mark a stream as being OK for auto cleanup.  What this means is
   that the streams API will not emit a warning when it is time to auto-cleanup
   a stream.  To do this, you can use <function>php_stream_auto_cleanup</function>.
  </para>
 </sect1>
</chapter>

&chapters.streams.common;
&chapters.streams.dir;
&chapters.streams.file;
&chapters.streams.socket;
&chapters.streams.structs;
&chapters.streams.constants;


<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

