<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.2 $ -->
<!-- Author: Wez Furlong <wez@thebrainroom.com>
  Please contact me before making any major amendments to the
  content of this section.  Splitting/Merging are fine if they are
  required for php-doc restructuring purposes - just drop me a line
  if you make a change (so I can update my local copy).
-->
 <sect1 id="stream.common-api">
 <title>ストリーム共通APIリファレンス</title>
  
  <refentry id="streams.php-stream-stat-path">
  <refnamediv>
   <refname>php_stream_stat_path</refname>
   <refpurpose>ファイルまたはURLのステータスを得る</refpurpose>
  </refnamediv>
  <refsect1>
   <title>説明</title>
   <methodsynopsis>
    <type>int</type><methodname>php_stream_stat_path</methodname>
    <methodparam><type>char *</type><parameter>path</parameter></methodparam>
    <methodparam><type>php_stream_statbuf *</type><parameter>ssb</parameter></methodparam>
   </methodsynopsis>
   <para>
    <function>php_stream_stat_path</function> は、
    <parameter>path</parameter>で指定したファイルまたはURLを調べ、
    ファイルサイズ、アクセス権、作成日時といった情報を返します。
    返り値は成功時に0、エラー時に-1となります。返される情報の詳細に
    ついては、
    <link linkend="streams.struct-php-stream-statbuf">php_stream_statbuf</link>
    を参照ください。
   </para>
  </refsect1>
 </refentry>
  
 <refentry id="streams.php-stream-stat">
  <refnamediv>
   <refname>php_stream_stat</refname>
   <refpurpose>ストリームを保持するストレージに関する情報を得る</refpurpose>
  </refnamediv>
  <refsect1>
   <title>説明</title>
   <methodsynopsis>
    <type>int</type><methodname>php_stream_stat</methodname>
    <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
    <methodparam><type>php_stream_statbuf *</type><parameter>ssb</parameter></methodparam>
   </methodsynopsis>
   <para>
    <function>php_stream_stat</function> は、<parameter>stream</parameter>
    にバインドされているストレージに関する情報を調べ、ファイルサイズ、
    アクセス権、作成日時といった情報を返します。
    返り値は成功時に0、エラー時に-1となります。返される情報の詳細に
    ついては、
    <link linkend="streams.struct-php-stream-statbuf">php_stream_statbuf</link>
    を参照ください。
   </para>
  </refsect1>
 </refentry>
  
 <refentry id="streams.php-stream-open-wrapper">
  <refnamediv>
   <refname>php_stream_open_wrapper</refname>
   <refpurpose>ファイルまたはURLをオープンする</refpurpose>
  </refnamediv>
  <refsect1>
   <title>説明</title>
   <methodsynopsis>
    <type>php_stream *</type><methodname>php_stream_open_wrapper</methodname>
    <methodparam><type>char *</type><parameter>path</parameter></methodparam>
    <methodparam><type>char *</type><parameter>mode</parameter></methodparam>
    <methodparam><type>int</type><parameter>options</parameter></methodparam>
    <methodparam><type>char **</type><parameter>opened</parameter></methodparam>
   </methodsynopsis>
   <para>
    <function>php_stream_open_wrapper</function> は <parameter>path</parameter>
    で指定されたファイルやURLなどのラップされたリソースのストリームを開きます。
    <parameter>mode</parameter> によって、ストリームを読み出し用、書き出し用、
    追記用、あるいはその組み合わせで開くことができます。指定できる種々のモード
    については下記の表をご覧下さい。それらの文字列に加え、文字 'b' を
    モード文字列の2文字目、または末尾に含めることができます。
    この文字 'b' は、該当するストリームの実装に対し、バイナリセーフなモードで
    ストリームを開くよう指示します。
   </para>
   <para>
    文字 'b' は、すべての POSIX に準拠したシステム上では、バイナリファイルと
    テキストファイルが同列に扱われるため、無視されます。アクセスするデータ
    において、8 ビットすべてが重要な際には、この 'b' 文字を指定しておくのは、
    'b' フラグが意味を持つシステムでも同じスクリプトを動かせるので、
    よいアイディアといえます。 
   </para>
   <para>
    ストリーム API によって作成されたすべてのローカルにあるファイルの
    パーミッションは、オペレーティングシステムのデフォルトに従って
    設定されます - UNIX ベースのシステムでは、ファイルを作成したプロセスの
    umask が反映されます。また、Windows では、ファイルを作成したプロセスが
    ファイルを所有します。
    リモートにあるファイルについては、ファイルを開くのに用いた URL ラッパー
    の設定や、リモートのサーバに与えられた信頼情報に応じて作成されます。
   </para>
   <para>
    <variablelist>
     <varlistentry>
      <term>
       <constant>r</constant> 
      </term>
      <listitem>
       <simpara>
        ファイルを読み出し用に開きます。このとき、ストリームの位置は、
        ファイルの先頭に移動されます。
       </simpara>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term>
       <constant>r+</constant> 
      </term>
      <listitem>
       <simpara>
        ファイルを読み書き用に開きます。このとき、ストリームの位置は、
        ファイルの先頭に移動されます。
       </simpara>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term>
       <constant>w</constant> 
      </term>
      <listitem>
       <simpara>
        ファイルの内容を長さ 0 に切り詰めるか、新規にファイルを作成し、
        書き出しモードで開きます。このとき、ストリームの位置は、
        ファイルの先頭に移動されます。
       </simpara>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term>
       <constant>w+</constant> 
       </term>
      <listitem>
       <simpara>
        ファイルを読み書き用に開きます。もし指定されたファイルが存在
        しない場合は、新規に作成し、存在する場合は、長さを切り詰めます。
        このとき、ストリームの位置は、ファイルの先頭に移動されます。
       </simpara>
      </listitem>
     </varlistentry>
      
     <varlistentry>
      <term>
       <constant>a</constant> 
      </term>
      <listitem>
       <simpara>
        ファイルを書き出し用に開きます。もしファイルが存在しない場合は、
        新規に作成します。このとき、ストリームの位置は、ファイルの
        末尾に移動されます。
       </simpara>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term>
       <constant>a+</constant> 
      </term>
      <listitem>
       <simpara>
        ファイルを読み書き用に開きます。もし指定されたファイルが存在
        しない場合は、新規に作成します。このとき、ストリームの位置は、
        ファイルの末尾に移動されます。
       </simpara>
      </listitem>
     </varlistentry>
     
    </variablelist>    
   </para>    
    <para>
    <parameter>options</parameter> は、ストリームへのパスや URL をどのように
    解釈するかや、セーフモードチェック、ストリームを開くときにエラーが
    発生した場合のアクションに影響します。このオプションに関しては、
    <link linkend="streams.options">Stream open options</link> を参照ください。
   </para>
   <para>
    もし <parameter>opened</parameter> が NULL でなければ、実際に
    開かれたファイルやリソースの名前がセットされます。これは、
    オプションに include_path に列挙されたパスからファイルを探すよう指示する
    <constant>USE_PATH</constant> が含まれている時に重要になります。
    呼び出し元は、最後にこのパラメータによって返されたファイル名を
    <function>efree</function> の呼び出しによって開放する必要があります。
   </para>
   <note>
    <simpara>
     もし、<constant>STREAM_MUST_SEEK</constant> を <parameter>options</parameter>
     に指定した場合、<parameter>opened</parameter> に返されたファイルへのパス
     は、実際に返されるストリームのものと違う場合があります。しかし、これは
     シーク可能なストリームを作るのに用いられた元のストリームの名前になります。
    </simpara>
   </note>
  </refsect1>
 </refentry>
 
  
 <refentry id="streams.php-stream-read">
  <refnamediv>
   <refname>php_stream_read</refname>
   <refpurpose>ストリームからバッファに指定バイト数読み込む</refpurpose>
  </refnamediv>
   <refsect1>
    <title>説明</title>
     <methodsynopsis>
      <type>size_t</type><methodname>php_stream_read</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
      <methodparam><type>char *</type><parameter>buf</parameter></methodparam>
      <methodparam><type>size_t</type><parameter>count</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_read</function> は <parameter>count</parameter>
     バイトで指定されたバイト数まで <parameter>stream</parameter> から
     データを読み取り、バッファ <parameter>buf</parameter> にコピーします。
    </para>
    <para>
     <function>php_stream_read</function> は、正常に読み込むことのできた
     バイト数を返します。読み込みが失敗したのか、ファイルの終端に達したのか
     をここから知ることはできませんので、<function>php_stream_eof</function>
     を、<constant>EOF</constant> 条件のテストに使います。
    </para>
    <para>
     ストリームの内部位置は、次回以降続きから読めるよう、
     読み込まれた分だけ進められます。
    </para>
    <para>
     もし、<parameter>count</parameter> バイトよりも少ないデータしか揃って
     いない場合、この関数は、ストリームのブロックモードの設定に応じて、
     すべてのデータが揃うまでブロックします(待ちます)。デフォルトでは、
     ストリームはブロックモードで開かれます。
     もし通常のファイルから読み込む場合は、ブロックモードはあまり意味を
     持ちません。ストリームが、<constant>EOF</constant> に達した場合は、
     <function>php_stream_read</function> は、<parameter>count</parameter>
     よりも少ない値を返し、次回以降は、0 を返します。
    </para>
   </refsect1>
  </refentry>

  <refentry id="streams.php-stream-write">
   <refnamediv>
    <refname>php_stream_write</refname>
    <refpurpose>バッファからストリームに指定バイト数書き込む</refpurpose>
   </refnamediv>
   <refsect1>
    <title>説明</title>
     <methodsynopsis>
      <type>size_t</type><methodname>php_stream_write</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
      <methodparam><type>const char *</type><parameter>buf</parameter></methodparam>
      <methodparam><type>size_t</type><parameter>count</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_write</function> は、<parameter>count</parameter>
     バイトのデータを <parameter>buf</parameter> から
     <parameter>stream</parameter> に書き出します。
    </para>
    <para>
     <function>php_stream_write</function> は正常に書き込むことのできた
     バイト数を返します。もし、何らかのエラーがあった場合は、
     書き込むことのできたバイト数は <parameter>count</parameter> よりも
     小さくなります。
    </para>
    <para>
     ストリームの内部位置は、次回以降続きから書き込めるよう、
     読み込まれた分だけ進められます。
    </para>
   </refsect1>
  </refentry>

  <refentry id="streams.php-stream-eof">
   <refnamediv>
    <refname>php_stream_eof</refname>
    <refpurpose>ストリームがファイル終端に達したかどうか調べる</refpurpose>
   </refnamediv>
   <refsect1>
    <title>説明</title>
     <methodsynopsis>
      <type>int</type><methodname>php_stream_eof</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_eof</function> は、<parameter>stream</parameter> が、
     ファイルの終端に達したかどうかを調べます。
    </para>
    <para>
     <function>php_stream_eof</function> が 1 を返すということは、
     <constant>EOF</constant> に達したことを意味します。0 ならば、
     まだ <constant>EOF</constant> でなく、-1 はエラーを意味します。
    </para>
   </refsect1>
  </refentry>

  <refentry id="streams.php-stream-getc">
   <refnamediv>
    <refname>php_stream_getc</refname>
    <refpurpose>ストリームから1バイト読み込む</refpurpose>
   </refnamediv>
   <refsect1>
    <title>説明</title>
     <methodsynopsis>
      <type>int</type><methodname>php_stream_getc</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_getc</function> は <parameter>stream</parameter>
     から 1 文字読み込み、unsigned char を int としてキャストした形で
     返します。 ファイルの終端に達したか、エラーが発生した場合は、
     <constant>EOF</constant> を返します。
    </para>
    <para>
     <function>php_stream_getc</function> のブロックに関する挙動は、 
     <function>php_stream_read</function> のものと一緒です。
    </para>
    <para>
     正常に実行できた場合、ストリームの内部位置は 1 だけ進められます。
    </para>
   </refsect1>
  </refentry>

  <refentry id="streams.php-stream-gets">
   <refnamediv>
    <refname>php_stream_gets</refname>
    <refpurpose>ストリームからバッファに1行分のデータを読み込む</refpurpose>
   </refnamediv>
   <refsect1>
    <title>説明</title>
     <methodsynopsis>
      <type>char *</type><methodname>php_stream_gets</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
      <methodparam><type>char *</type><parameter>buf</parameter></methodparam>
      <methodparam><type>size_t</type><parameter>maxlen</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_gets</function> は、最大で <parameter>count</parameter>-1
     バイトまでのデータを <parameter>stream</parameter> から読み込み、
     バッファ <parameter>buf</parameter> にコピーします。読み込みは、
     <constant>EOF</constant> あるいは行末記号に到達した時点でストップします。
     もし、行末まで読み込まれた場合、行末記号は、<parameter>buf</parameter>
     の一部として含まれます。NUL 終端文字が、バッファの末尾に付加されます。
    </para>
    <para>
     <function>php_stream_read</function> は正常に終了すると、<parameter>buf</parameter>
     を、その他の場合は NULL を返します。
    </para>
    <para>
     ストリームの内部位置は、次回以降続きから読めるよう、
     読み込まれた分だけ進められます。
    </para>
    <para>
     この関数のブロックに関する挙動は、<function>php_stream_read</function>
     のものと一緒です。
    </para>
   </refsect1>
  </refentry>

  <refentry id="streams.php-stream-close">
   <refnamediv>
    <refname>php_stream_close</refname>
    <refpurpose>ストリームを閉じる</refpurpose>
   </refnamediv>
   <refsect1>
    <title>説明</title>
     <methodsynopsis>
      <type>int</type><methodname>php_stream_close</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_close</function> は、<parameter>stream</parameter> を
     安全にクローズし、それに関連付けられたリソースを同時に開放します。
     一旦 <parameter>stream</parameter> を閉じると、その値は不定になります。
     再び利用してはいけません。
    </para>
    <para>
     <function>php_stream_close</function> は正常にストリームを閉じられた
     場合、0 を、エラーが発生した場合には、<constant>EOF</constant>
     を返します。関数の実行の成否にかかわらず、<parameter>stream</parameter>
     は不定になりますので、この関数の実行後に利用してはいけません。
    </para>
   </refsect1>
  </refentry>

  <refentry id="streams.php-stream-flush">
   <refnamediv>
    <refname>php_stream_flush</refname>
    <refpurpose>ストリームバッファをストレージにフラッシュする</refpurpose>
   </refnamediv>
   <refsect1>
    <title>説明</title>
     <methodsynopsis>
      <type>int</type><methodname>php_stream_flush</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_flush</function> causes any data held in
     write buffers in <parameter>stream</parameter> to be committed to the
     underlying storage.
    </para>
    <para>
     <function>php_stream_flush</function> returns 0 if the buffers were flushed,
     or if the buffers did not need to be flushed, but returns <constant>EOF</constant>
     to indicate an error.
    </para>
   </refsect1>
  </refentry>

 <refentry id="streams.php-stream-seek">
  <refnamediv>
   <refname>php_stream_seek</refname>
   <refpurpose>ストリーム内で移動する</refpurpose>
  </refnamediv>
  <refsect1>
   <title>説明</title>
   <methodsynopsis>
    <type>int</type><methodname>php_stream_seek</methodname>
    <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
    <methodparam><type>off_t</type><parameter>offset</parameter></methodparam>
    <methodparam><type>int</type><parameter>whence</parameter></methodparam>
   </methodsynopsis>
   <para>
    <function>php_stream_seek</function> repositions the internal
    position of <parameter>stream</parameter>.
    The new position is determined by adding the <parameter>offset</parameter>
    to the position indicated by <parameter>whence</parameter>.
     If <parameter>whence</parameter> is set to <constant>SEEK_SET</constant>,
    <constant>SEEK_CUR</constant> or <constant>SEEK_END</constant> the offset
     is relative to the start of the stream, the current position or the end of the stream, respectively.
   </para>
   <para>
    <function>php_stream_seek</function> returns 0 on success, but -1 if there was an error.
   </para>
   <note>
    <para>
     Not all streams support seeking, although the streams API will emulate a seek if
     <parameter>whence</parameter> is set to <constant>SEEK_CUR</constant>
     and <parameter>offset</parameter> is positive, by calling <function>php_stream_read</function>
     to read (and discard) <parameter>offset</parameter> bytes.
    </para>
    <para>
     The emulation is only applied when the underlying stream implementation does not
     support seeking.  If the stream is (for example) a file based stream that is wrapping
     a non-seekable pipe, the streams api will not apply emulation because the file based
      stream implements a seek operation; the seek will fail and an error result will be
     returned to the caller.
    </para>
   </note>
  </refsect1>
 </refentry>
 
 <refentry id="streams.php-stream-tell">
  <refnamediv>
   <refname>php_stream_tell</refname>
   <refpurpose>ストリーム内の位置を調べる</refpurpose>
  </refnamediv>
  <refsect1>
   <title>説明</title>
   <methodsynopsis>
    <type>off_t</type><methodname>php_stream_tell</methodname>
    <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
   </methodsynopsis>
   <para>
    <function>php_stream_tell</function> returns the internal position of
    <parameter>stream</parameter>, relative to the start of the stream.
    If there is an error, -1 is returned.
   </para>
  </refsect1>
 </refentry>
 
 <refentry id="streams.php-stream-copy-to-stream">
  <refnamediv>
   <refname>php_stream_copy_to_stream</refname>
   <refpurpose>
    あるストリームから別のストリームへデータをコピーする
   </refpurpose>
  </refnamediv>
  <refsect1>
   <title>説明</title>
   <methodsynopsis>
    <type>size_t</type><methodname>php_stream_copy_to_stream</methodname>
    <methodparam><type>php_stream *</type><parameter>src</parameter></methodparam>
    <methodparam><type>php_stream *</type><parameter>dest</parameter></methodparam>
    <methodparam><type>size_t</type><parameter>maxlen</parameter></methodparam>
   </methodsynopsis>
   <para>
    <function>php_stream_copy_to_stream</function> attempts to read up to <parameter>maxlen</parameter>
    bytes of data from <parameter>src</parameter> and write them to <parameter>dest</parameter>,
      and returns the number of bytes that were successfully copied.
    </para>
    <para>
     If you want to copy all remaining data from the <parameter>src</parameter> stream, pass the
     constant <constant>PHP_STREAM_COPY_ALL</constant> as the value of <parameter>maxlen</parameter>.
   </para>
   <note>
    <simpara>
     This function will attempt to copy the data in the most efficient manner, using memory mapped
     files when possible.
    </simpara>
   </note>
   </refsect1>
 </refentry>
 
 <refentry id="streams.php-stream-copy-to-mem">
  <refnamediv>
   <refname>php_stream_copy_to_mem</refname>
   <refpurpose>
    ストリームから確保されたバッファにデータをコピーする
   </refpurpose>
  </refnamediv>
  <refsect1>
   <title>説明</title>
   <methodsynopsis>
    <type>size_t</type><methodname>php_stream_copy_to_mem</methodname>
    <methodparam><type>php_stream *</type><parameter>src</parameter></methodparam>
    <methodparam><type>char **</type><parameter>buf</parameter></methodparam>
    <methodparam><type>size_t</type><parameter>maxlen</parameter></methodparam>
    <methodparam><type>int</type><parameter>persistent</parameter></methodparam>
   </methodsynopsis>
   <para>
    <function>php_stream_copy_to_mem</function> allocates a buffer <parameter>maxlen</parameter>+1
     bytes in length using <function>pemalloc</function> (passing <parameter>persistent</parameter>).
     It then reads <parameter>maxlen</parameter> bytes from <parameter>src</parameter> and stores
     them in the allocated buffer.
   </para>
   <para>
    The allocated buffer is returned in <parameter>buf</parameter>, and the number of bytes successfully
    read.  You, the caller, are responsible for freeing the buffer by passing it and <parameter>persistent</parameter>
    to <function>pefree</function>.
   </para>
   <para>
    If you want to copy all remaining data from the <parameter>src</parameter> stream, pass the
    constant <constant>PHP_STREAM_COPY_ALL</constant> as the value of <parameter>maxlen</parameter>.
   </para>
   <note>
    <simpara>
     This function will attempt to copy the data in the most efficient manner, using memory mapped
     files when possible.
    </simpara>
   </note>
  </refsect1>
 </refentry>
 
 <refentry id="streams.php-stream-make-seekable">
   <refnamediv>
   <refname>php_stream_make_seekable</refname>
   <refpurpose>ストリームをシーク可能なストリームへ変換する</refpurpose>
  </refnamediv>
  <refsect1>
   <title>説明</title>
   <methodsynopsis>
    <type>int</type><methodname>php_stream_make_seekable</methodname>
    <methodparam><type>php_stream *</type><parameter>origstream</parameter></methodparam>
    <methodparam><type>php_stream **</type><parameter>newstream</parameter></methodparam>
    <methodparam><type>int</type><parameter>flags</parameter></methodparam>
   </methodsynopsis>
   <para>
    <function>php_stream_make_seekable</function> checks if <parameter>origstream</parameter> is
    seekable.   If it is not, it will copy the data into a new temporary stream.
    If successful, <parameter>newstream</parameter> is always set to the stream that is valid to use, even if the original
    stream was seekable.
   </para>
   <para>
    <parameter>flags</parameter> allows you to specify your preference for the seekeable stream that is
    returned: use <constant>PHP_STREAM_NO_PREFERENCE</constant> to use the default seekable stream
    (which uses a dynamically expanding memory buffer, but switches to temporary file backed storage
    when the stream size becomes large), or use <constant>PHP_STREAM_PREFER_STDIO</constant> to
    use "regular" temporary file backed storage.
   </para>
   <para>
    <table>
     <title><function>php_stream_make_seekable</function> return values</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Value</entry>
        <entry>Meaning</entry>
        </row>
      </thead>
      <tbody>
       
       <row>
        <entry>PHP_STREAM_UNCHANGED</entry>
        <entry>Original stream was seekable anyway. <parameter>newstream</parameter> is set to the value
         of <parameter>origstream</parameter>.
        </entry>
       </row>
       
       <row>
        <entry>PHP_STREAM_RELEASED</entry>
        <entry>Original stream was not seekable and has been released. <parameter>newstream</parameter> is set to the
         new seekable stream.  You should not access <parameter>origstream</parameter> anymore.
        </entry>
       </row>

       <row>
        <entry>PHP_STREAM_FAILED</entry>
        <entry>An error occurred while attempting conversion. <parameter>newstream</parameter> is set to NULL;
         <parameter>origstream</parameter> is still valid.
        </entry>
       </row>
       
       <row>
        <entry>PHP_STREAM_CRITICAL</entry>
        <entry>An error occurred while attempting conversion that has left <parameter>origstream</parameter> in
         an indeterminate state. <parameter>newstream</parameter> is set to NULL and it is highly recommended
         that you close <parameter>origstream</parameter>.
        </entry>
       </row>
         
      </tbody>
     </tgroup>
    </table>
   </para>
   <note>
    <simpara>
     If you need to seek and write to the stream, it does not make sense to use this function, because the stream
     it returns is not guaranteed to be bound to the same resource as the original stream.
     </simpara>
   </note>
   <note>
    <simpara>
     If you only need to seek forwards, there is no need to call this function, as the streams API will emulate
     forward seeks when the whence parameter is <constant>SEEK_CUR</constant>.
     </simpara>
   </note>
   <note>
    <simpara>
     If <parameter>origstream</parameter> is network based, this function will block until the whole contents
     have been downloaded.
    </simpara>
   </note>
    <note>
    <simpara>
     NEVER call this function with an <parameter>origstream</parameter> that is reference by a file pointer
     in a PHP script!  This function may cause the underlying stream to be closed which could cause a crash
     when the script next accesses the file pointer!
    </simpara>
   </note>
   <note>
    <simpara>
     In many cases, this function can only succeed when <parameter>origstream</parameter> is a newly opened
     stream with no data buffered in the stream layer.  For that reason, and because this function is complicated to
     use correctly, it is recommended that you use <function>php_stream_open_wrapper</function> and pass in
     <constant>PHP_STREAM_MUST_SEEK</constant> in your options instead of calling this function directly.
    </simpara>
   </note>
    </refsect1>
 </refentry>
 
 
 <refentry id="streams.php-stream-cast">
   <refnamediv>
   <refname>php_stream_cast</refname>
   <refpurpose>
    ストリームをFILE*またはソケットのような他の形式に変換する
   </refpurpose>
  </refnamediv>
  <refsect1>
   <title>説明</title>
   <methodsynopsis>
    <type>int</type><methodname>php_stream_cast</methodname>
    <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
    <methodparam><type>int</type><parameter>castas</parameter></methodparam>
    <methodparam><type>void **</type><parameter>ret</parameter></methodparam>
    <methodparam><type>int</type><parameter>flags</parameter></methodparam>
   </methodsynopsis>
   <para>
    <function>php_stream_cast</function> attempts to convert <parameter>stream</parameter> into
    a resource indicated by <parameter>castas</parameter>.
     If <parameter>ret</parameter> is NULL, the stream is queried to find out if such a conversion is
     possible, without actually performing the conversion (however, some internal stream state *might*
     be changed in this case).
     If <parameter>flags</parameter> is set to <constant>REPORT_ERRORS</constant>, an error
     message will be displayed is there is an error during conversion.
    </para>
    <note>
        <para>
         This function returns <constant>SUCCESS</constant> for success or <constant>FAILURE</constant>
         for failure.  Be warned that you must explicitly compare the return value with <constant>SUCCESS</constant>
         or <constant>FAILURE</constant> because of the underlying values of those constants. A simple
         boolean expression will not be interpreted as you intended.
        </para>
    </note>
    <para>
     <table>
      <title>Resource types for <parameter>castas</parameter></title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Value</entry>
         <entry>Meaning</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>PHP_STREAM_AS_STDIO</entry>
         <entry>Requests an ANSI FILE* that represents the stream</entry>
        </row>
        <row>
         <entry>PHP_STREAM_AS_FD</entry>
         <entry>Requests a POSIX file descriptor that represents the stream</entry>
        </row>
        <row>
         <entry>PHP_STREAM_AS_SOCKETD</entry>
         <entry>Requests a network socket descriptor that represents the stream</entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <para>
     In addition to the basic resource types above, the conversion process can be altered by using the
     following flags by using the OR operator to combine the resource type with one or more of the
     following values:
     <table>
      <title>Resource types for <parameter>castas</parameter></title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Value</entry>
         <entry>Meaning</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>PHP_STREAM_CAST_TRY_HARD</entry>
         <entry>Tries as hard as possible, at the expense of additional resources, to ensure that the conversion succeeds</entry>
        </row>
        <row>
         <entry>PHP_STREAM_CAST_RELEASE</entry>
         <entry>Informs the streams API that some other code (possibly a third party library) will be responsible for closing the
         underlying handle/resource.  This causes the <parameter>stream</parameter> to be closed in such a way the underlying
         handle is preserved and returned in <parameter>ret</parameter>.  If this function succeeds, <parameter>stream</parameter>
         should be considered closed and should no longer be used.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <note>
     <simpara>
      If your system supports <function>fopencookie</function> (systems using glibc 2 or later), the streams API
      will always be able to synthesize an ANSI FILE* pointer over any stream.
      While this is tremendously useful for passing any PHP stream to any third-party libraries, such behaviour is not
      portable.  You are requested to consider the portability implications before distributing you extension.
      If the fopencookie synthesis is not desireable, you should query the stream to see if it naturally supports FILE*
      by using <function>php_stream_is</function>
     </simpara>
    </note>
    <note>
     <simpara>
      If you ask a socket based stream for a FILE*, the streams API will use <function>fdopen</function> to
      create it for you.  Be warned that doing do may cause data that was buffered in the streams layer to be
      lost if you intermix streams API calls with ANSI stdio calls.
     </simpara>
    </note>
    <para>
     See also <function>php_stream_is</function> and <function>php_stream_can_cast</function>.
    </para>
   </refsect1>
  </refentry>
 
 <refentry id="streams.php-stream-can-cast">
  <refnamediv>
   <refname>php_stream_can_cast</refname>
   <refpurpose>
    ストリームがFILE*またはソケットのような他の形式に変換できるかどうかを
    調べる
   </refpurpose>
  </refnamediv>
  <refsect1>
   <title>説明</title>
   <methodsynopsis>
    <type>int</type><methodname>php_stream_can_cast</methodname>
    <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
    <methodparam><type>int</type><parameter>castas</parameter></methodparam>
   </methodsynopsis>
   <para>
    This function is equivalent to calling <function>php_stream_cast</function> with <parameter>ret</parameter>
    set to NULL and <parameter>flags</parameter> set to 0.
    It returns <constant>SUCCESS</constant> if the stream can be converted into the form requested, or
    <constant>FAILURE</constant> if the conversion cannot be performed.
   </para>
   <note>
    <simpara>
     Although this function will not perform the conversion, some internal stream state *might* be
     changed by this call.
    </simpara>
    </note>
   <note>
    <simpara>
     You must explicity compare the return value of this function with one of the constants, as described
     in <function>php_stream_cast</function>.
    </simpara>
   </note>
   <para>
    See also <function>php_stream_cast</function> and <function>php_stream_is</function>.
   </para>
  </refsect1>
 </refentry>
 
 <refentry id="streams.php-stream-is-persistent">
  <refnamediv>
   <refname>php_stream_is_persistent</refname>
   <refpurpose>
    ストリームが持続的なストリームであるかどうかを調べる
   </refpurpose>
  </refnamediv>
  <refsect1>
   <title>説明</title>
   <methodsynopsis>
    <type>int</type><methodname>php_stream_is_persistent</methodname>
    <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
   </methodsynopsis>
   <para>
    <function>php_stream_is_persistent</function> returns 1 if the stream is a persistent stream,
    0 otherwise.
   </para>
  </refsect1>
 </refentry>
 
 <refentry id="streams.php-stream-is">
  <refnamediv>
   <refname>php_stream_is</refname>
   <refpurpose>ストリームが特定の型であるかどうかを調べる</refpurpose>
  </refnamediv>
  <refsect1>
   <title>説明</title>
   <methodsynopsis>
    <type>int</type><methodname>php_stream_is</methodname>
    <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
    <methodparam><type>int</type><parameter>istype</parameter></methodparam>
     </methodsynopsis>
   <para>
    <function>php_stream_is</function> returns 1 if <parameter>stream</parameter> is of
    the type specified by <parameter>istype</parameter>, or 0 otherwise.
    <table>
     <title>Values for <parameter>istype</parameter></title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Value</entry>
        <entry>Meaning</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>PHP_STREAM_IS_STDIO</entry>
        <entry>The stream is implemented using the stdio implementation</entry>
       </row>
       <row>
        <entry>PHP_STREAM_IS_SOCKET</entry>
        <entry>The stream is implemented using the network stream implementation</entry>
       </row>
       <row>
         <entry>PHP_STREAM_IS_USERSPACE</entry>
        <entry>The stream is implemented using the userspace object implementation</entry>
       </row>
       <row>
        <entry>PHP_STREAM_IS_MEMORY</entry>
        <entry>The stream is implemented using the grow-on-demand memory stream implementation</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
    
   </para>
   <note>
    <simpara>
     The PHP_STREAM_IS_XXX "constants" are actually defined as pointers to the underlying
     stream operations structure.  If your extension (or some other extension) defines additional
     streams, it should also declare a PHP_STREAM_IS_XXX constant in it's header file that you
     can use as the basis of this comparison.
    </simpara>
    </note>
   <note>
    <simpara>
      This function is implemented as a simple (and fast) pointer comparision, and does not change
     the stream state in any way.
    </simpara>
   </note>
   <para>
    See also <function>php_stream_cast</function> and <function>php_stream_can_cast</function>.
   </para>
   </refsect1>
 </refentry>
 
 <refentry id="streams.php-stream-passthru">
  <refnamediv>
   <refname>php_stream_passthru</refname>
   <refpurpose>ストリームから残りのデータを全て出力する</refpurpose>
  </refnamediv>
  <refsect1>
   <title>説明</title>
   <methodsynopsis>
      <type>size_t</type><methodname>php_stream_passthru</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
     </methodsynopsis>
     <para>
      <function>php_stream_passthru</function> outputs all remaining data from <parameter>stream</parameter>
      to the active output buffer and returns the number of bytes output.
      If buffering is disabled, the data is written straight to the output, which is the browser making the
    request in the case of PHP on a web server, or stdout for CLI based PHP.
    This function will use memory mapped files if possible to help improve performance.
   </para>
  </refsect1>
 </refentry>

 <refentry id="streams.php-register-url-stream-wrapper">
  <refnamediv>
   <refname>php_register_url_stream_wrapper</refname>
   <refpurpose>ストリームAPI用のラッパを登録する</refpurpose>
  </refnamediv>
  <refsect1>
   <title>説明</title>
   <methodsynopsis>
    <type>int</type><methodname>php_register_url_stream_wrapper</methodname>
    <methodparam><type>char *</type><parameter>protocol</parameter></methodparam>
    <methodparam><type>php_stream_wrapper *</type><parameter>wrapper</parameter></methodparam>
    <methodparam><type>TSRMLS_DC</type><parameter></parameter></methodparam>
   </methodsynopsis>
   <para>
    <function>php_register_url_stream_wrapper</function> registers <parameter>wrapper</parameter>
    as the handler for the protocol specified by <parameter>protocol</parameter>.
   </para>
   <note>
    <simpara>
     If you call this function from a loadable module, you *MUST* call <function>php_unregister_url_stream_wrapper</function>
     in your module shutdown function, otherwise PHP will crash.
    </simpara>
   </note>
  </refsect1>
 </refentry>
 
 <refentry id="streams.php-unregister-url-stream-wrapper">
  <refnamediv>
   <refname>php_unregister_url_stream_wrapper</refname>
   <refpurpose>ストリームAPI用のラッパの登録を解除する</refpurpose>
  </refnamediv>
  <refsect1>
   <title>説明</title>
   <methodsynopsis>
    <type>int</type><methodname>php_unregister_url_stream_wrapper</methodname>
    <methodparam><type>char *</type><parameter>protocol</parameter></methodparam>
    <methodparam><type>TSRMLS_DC</type><parameter></parameter></methodparam>
   </methodsynopsis>
   <para>
    <function>php_unregister_url_stream_wrapper</function> unregisters the wrapper
    associated with <parameter>protocol</parameter>.
   </para>
  </refsect1>
 </refentry>
 
 <refentry id="streams.php-stream-open-wrapper-ex">
  <refnamediv>
   <refname>php_stream_open_wrapper_ex</refname>
   <refpurpose>
    コンテキストを指定して、ファイルまたはURLにストリームをオープンする
   </refpurpose>
  </refnamediv>
  <refsect1>
   <title>説明</title>
   <methodsynopsis>
    <type>php_stream *</type><methodname>php_stream_open_wrapper_ex</methodname>
    <methodparam><type>char *</type><parameter>path</parameter></methodparam>
    <methodparam><type>char *</type><parameter>mode</parameter></methodparam>
    <methodparam><type>int</type><parameter>options</parameter></methodparam>
    <methodparam><type>char **</type><parameter>opened</parameter></methodparam>
    <methodparam><type>php_stream_context *</type><parameter>context</parameter></methodparam>
   </methodsynopsis>
   <para>
    <function>php_stream_open_wrapper_ex</function> is exactly like
    <function>php_stream_open_wrapper</function>, but allows you to specify a
    php_stream_context object using <parameter>context</parameter>.
    To find out more about stream contexts, see XXX
   </para>
  </refsect1>
 </refentry>
 
 <refentry id="streams.php-stream-open-wrapper-as-file">
  <refnamediv>
   <refname>php_stream_open_wrapper_as_file</refname>
   <refpurpose>
    ファイルまたはURLをオープンし、FILE*に変換する
   </refpurpose>
  </refnamediv>
  <refsect1>
   <title>説明</title>
   <methodsynopsis>
    <type>FILE *</type><methodname>php_stream_open_wrapper_as_file</methodname>
    <methodparam><type>char *</type><parameter>path</parameter></methodparam>
    <methodparam><type>char *</type><parameter>mode</parameter></methodparam>
    <methodparam><type>int</type><parameter>options</parameter></methodparam>
    <methodparam><type>char **</type><parameter>opened</parameter></methodparam>
   </methodsynopsis>
   <para>
    <function>php_stream_open_wrapper_as_file</function> is exactly like
    <function>php_stream_open_wrapper</function>, but converts the stream
    into an ANSI stdio FILE* and returns that instead of the stream.
    This is a convenient shortcut for extensions that pass FILE* to third-party libraries.
   </para>
  </refsect1>
 </refentry>
  

</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

