<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.8 $ -->
<!-- EN-Revision: 1.19 Maintainer: hirokawa Status: ready -->
<!-- CREDITS: shimooka -->
<!-- Purpose: xml -->
<!-- Membership: bundled, external -->

 <reference id="ref.xml">
  <title>XML パーサ関数</title>
  <titleabbrev>XML</titleabbrev>

  <partintro>

   <section id="xml.intro">
    &reftitle.intro;
    <para>
     XML (eXtensible Markup Language) は、Web における構造化された
     ドキュメント交換用のデータフォーマットです。XML は、World Wide
     Web consortium (W3C) で規定された規格です。XML に関する情報およ
     び関連する技術は、<ulink url="&url.xml;">&url.xml;</ulink>
     で参照することができます。
    </para>
     <para>
      このPHPエクステンションは、James Clark氏の
      <productname>expat</productname>のサポートをPHPに付加します。
      このツールキットは、XML ドキュメントの構文解析をしますが、
      検証は行いません。3種類のソース
      <link linkend="xml.encoding">文字エンコーディング</link>、
      <literal>US-ASCII</literal>,
      <literal>ISO-8859-1</literal> ,<literal>UTF-8</literal>
      がPHPでサポートされます。<literal>UTF-16</literal> はサポートさ
      れません。
     </para>
     <para>
      この拡張モジュールは、<link
      linkend="function.xml-parser-create">XML パーサの作成</link>
      を行い、異なった XML イベントに関して<emphasis>ハンドラ
      </emphasis> を定義します。各XMLパーサーには、設定可能な小数の
      <link linkend="function.xml-parser-set-option">パラメータ</link>
      もあります。
     </para>
   </section>

   <section id="xml.requirements">
    &reftitle.required;
    <para>
     このエクステンションは、<productname>expat</productname> を使用します。
     これは、<ulink url="&url.expat;">&url.expat;</ulink>にあります。
     expatに付属のMakefileは、デフォルトでライブラリを構築しません。こ
     れを行うmakeルールを次のように指定できます。
     <programlisting role="makefile">
<![CDATA[
libexpat.a: $(OBJS)
    ar -rc $@ $(OBJS)
    ranlib $@
]]>
     </programlisting>
     expat のソース RPM パッケージが
     <ulink url="&url.expat.rpm;">&url.expat.rpm;</ulink> にあります。
    </para>
   </section>

   &reference.xml.configure;

   <section id="xml.configuration">
    &reftitle.runtime;
    &no.config;
   </section>

   <section id="xml.resources">
    &reftitle.resources;
    <section id="xml.resources.xml">
     <title><literal>xml</literal></title>
     <para>
      <function>xml_parser_create</function>および
      <function>xml_parser_create_ns</function> により返された
      <literal>xml</literal>リソースは、
      このエクステンションにより提供された関数で使用される
      XMLパーサのインスタンスを参照します。
     </para>
    </section>
   </section>

   &reference.xml.constants;

   <section id="xml.eventhandlers">
    <title>イベントハンドラ</title>
    <para>
     XML イベントハンドラは次のように定義されます。
     <table>
      <title>サポートされる XML ハンドラ</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>ハンドラ設定用の PHP 関数</entry>
         <entry>イベントの説明</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><function>xml_set_element_handler</function></entry>
         <entry>
          要素イベントは、XML パーサーが開始または終了タグに出会うたび
          に発行されます。開始タグと終了タグについて別のハンドラがあり
          ます。
         </entry>
        </row>
        <row>
         <entry>
          <function>xml_set_character_data_handler</function>
         </entry>
         <entry>
          文字データは、タグの間の空白を含めて XML ドキュメントにおけ
          るほぼ全ての非マークアップ部分の内容です。XML パーサーは、
          空白を加えたり削除したりしないことに注意してください。空白が
          意味を有するかどうかを決めるのは、アプリケーション側の責任
          です。
         </entry>
        </row>
        <row>
         <entry>
          <function>xml_set_processing_instruction_handler</function>
         </entry>
         <entry>
          PHP プログラマは、既に処理用命令 (PI) に既に慣れているに違
          いありません。&lt;?php ?&gt; は処理用命令であり、この場合、
          <replaceable>php</replaceable> は "PI ターゲット"と呼ばれます。
          これらの処理はアプリケーション依存ですが、全ての PI ターゲッ
          トが "XML" から始まることだけは、規定されています。
         </entry>
        </row>
        <row>
         <entry><function>xml_set_default_handler</function></entry>
         <entry>
          別のハンドラでしないことをデフォルトのハンドラで行います。
          XML およびドキュメント型の宣言のようなことをデフォルトハンドラで
          行います。
         </entry>
        </row>
        <row>
         <entry>
          <function>xml_set_unparsed_entity_decl_handler</function>
         </entry>
         <entry>
          このハンドラは、処理されない (NDATA) エンティティの宣言用に
          コールされます。
         </entry>
        </row>
        <row>
         <entry><function>xml_set_notation_decl_handler</function></entry>
         <entry>
          このハンドラは、表記の宣言用にコールされます。
         </entry>
        </row>
        <row>
         <entry>
          <function>xml_set_external_entity_ref_handler</function>
         </entry>
         <entry>
          このハンドラは、XML パーサーが外部処理された通常のエンティティ
          への参照を見つけた際にコールされます。これは、例えば、ファ
          イルまたは URL への参照とすることが可能です。例としては、
          <link linkend="example.xml-external-entity">外部エンティティ
     の例</link> を参照ください。
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
   </section>

   <section id="xml.case-folding">
    <title>大文字変換(Case Folding)</title>
     <para>
     要素ハンドラ関数は、その要素に<glossterm>大文字小文字を変換する
      (case-folded)</glossterm>の名前をつけることができます。
     大文字変換(case-folding) は、XML標準により "大文字でないものは等
     価な大文字に置換される一連の文字に適用されるプロセス" として定義
     されています。言い替えると、XML に関しては単に大文字変換は大文字
     にすることを意味します。
    </para>
    <para>
     デフォルトで、ハンドラ関数に渡される全ての要素名は、大文字変換さ
     れます。この動作は、<function>xml_parser_get_option</function>
     および<function>xml_parser_set_option</function> 関数でXMLパーサー
     毎にそれぞれ問い合わせ、制御することが可能です。
    </para>
   </section>

   <section id="xml.error-codes">
    <title>エラーコード</title>
    <para>
     (<function>xml_parse</function> により返されるものとして)
     XMLエラーコードとして次のような定数が定義されています。:
     <simplelist>
      <member>XML_ERROR_NONE</member>
      <member>XML_ERROR_NO_MEMORY</member>
      <member>XML_ERROR_SYNTAX</member>
      <member>XML_ERROR_NO_ELEMENTS</member>
      <member>XML_ERROR_INVALID_TOKEN</member>
      <member>XML_ERROR_UNCLOSED_TOKEN</member>
      <member>XML_ERROR_PARTIAL_CHAR</member>
      <member>XML_ERROR_TAG_MISMATCH</member>
      <member>XML_ERROR_DUPLICATE_ATTRIBUTE</member>
      <member>XML_ERROR_JUNK_AFTER_DOC_ELEMENT</member>
      <member>XML_ERROR_PARAM_ENTITY_REF</member>
      <member>XML_ERROR_UNDEFINED_ENTITY</member>
      <member>XML_ERROR_RECURSIVE_ENTITY_REF</member>
      <member>XML_ERROR_ASYNC_ENTITY</member>
      <member>XML_ERROR_BAD_CHAR_REF</member>
      <member>XML_ERROR_BINARY_ENTITY_REF</member>
      <member>XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF</member>
      <member>XML_ERROR_MISPLACED_XML_PI</member>
      <member>XML_ERROR_UNKNOWN_ENCODING</member>
      <member>XML_ERROR_INCORRECT_ENCODING</member>
      <member>XML_ERROR_UNCLOSED_CDATA_SECTION</member>
      <member>XML_ERROR_EXTERNAL_ENTITY_HANDLING</member>
     </simplelist>
    </para>
   </section>

   <section id="xml.encoding">
    <title>文字エンコーディング</title>
    <para>
     PHPのXML拡張機能は、異なった<glossterm>文字エンコーディング
     </glossterm>を通じて<ulink url="&url.unicode;">Unicode</ulink>
     文字セットをサポートします。<glossterm>ソースエンコーディング
     </glossterm>および<glossterm>ターゲットエンコーディング
     </glossterm>という2種類の文字エンコーディングがあります。
     PHP におけるドキュメントの内部表現は、常に
     <literal>UTF-8</literal>でエンコードされます。
    </para>
    <para>
     ソースエンコーディングは、XMLドキュメントが
     <link linkend="function.xml-parse">構文解析</link>された際に行わ
     れます。<link linkend="function.xml-parser-create">XML パーサの
      作成</link>を行う際に、ソースエンコードを指定することができます。
     (このエンコーディングは、その XML パーサーが存在する間、後で変更す
     ることはできません)サポートされるソースエンコーディングは、
     <literal>ISO-8859-1</literal>, <literal>US-ASCII</literal> ,
     <literal>UTF-8</literal> です。前の二つは、シングルバイトエンコー
     ディングです。これは、各文字がシングルバイトで表現されることを意
     味します。<literal>UTF-8</literal> は、1から4バイトの可変ビット
     数(最大21ビット)で構成された文字をエンコードすることが可能です。
     PHP で用いられるデフォルトのソースエンコーディングは、
     <literal>ISO-8859-1</literal>です。
    </para>
    <para>
     ターゲットエンコーディングは、PHPがデータをXMLハンドラ関数に
     渡す時に行われます。あるXMLパーサが作成された際、ターゲットエン
     コーディングは、ソースエンコーディングと同様に設定されます。
     しかし、これは、いつでも変更可能です。ターゲットエンコーディング
     は、タグ名と同様に文字データに作用し、命令を処理します。
    </para>
    <para>
     XML パーサがソースエンコーディングが表現できる範囲の外側の文字に
     出会った場合、エラーが返されます。
    </para>
    <para>
     解釈するXMLドキュメントにおいてPHPが文字に出会った際に、選択した
     ターゲットエンコーディングで表現できない文字に出会った場合、問題
     の文字は "降格" されます。現在、このことはこのような文字が疑問符
     で置換されることを意味します。
    </para>
   </section>

   <section id="xml.examples">
    &reftitle.examples;
    <para>
     以下にXMLドキュメントを処理するPHPスクリプトの例をいくつか示します。
    </para>
    <section id="example.xml-structure">
     <title>XML エレメント構造の例</title>
     <para>
      この最初の例は、あるドキュメント中のstart エレメントの構造をイン
      デントを付けて表示します。
      <example>
       <title>XML エレメント構造を表示</title>
       <programlisting role="php">
<![CDATA[
<?php
$file = "data.xml";
$depth = array();

function startElement($parser, $name, $attrs)
{
    global $depth;
    for ($i = 0; $i < $depth[$parser]; $i++) {
        print "  ";
    }
    print "$name\n";
    $depth[$parser]++;
}

function endElement($parser, $name)
{
    global $depth;
    $depth[$parser]--;
}

$xml_parser = xml_parser_create();
xml_set_element_handler($xml_parser, "startElement", "endElement");
if (!($fp = fopen($file, "r"))) {
    die("XML 入力をオープンできませんでした");
}
while ($data = fread($fp, 4096)) {
    if (!xml_parse($xml_parser, $data, feof($fp))) {
        die(sprintf("XML エラー: %s が %d 行目で発生しました",
                    xml_error_string(xml_get_error_code($xml_parser)),
                    xml_get_current_line_number($xml_parser)));
    }
}
xml_parser_free($xml_parser);
?>
]]>
       </programlisting>
      </example>
     </para>
    </section>

    <section id="example.xml-map-tags">
     <title>XMLタグのマッピングの例</title>
     <para>
      <example>
       <title>XMLをHTMLにマップする</title>
       <para>
  この例は、XMLドキュメントのタグを直接HTMLタグにマップします。
  "map array" にないエレメントは無視されます。もちろん、この例は、
  特定の XML ドキュメント型を有する場合のみ動作します。
       </para>
       <para>
  <programlisting role="php">
<![CDATA[
<?php
$file = "data.xml";
$map_array = array(
    "BOLD"     => "B",
    "EMPHASIS" => "I",
    "LITERAL"  => "TT"
);

function startElement($parser, $name, $attrs)
{
    global $map_array;
    if (isset($map_array[$name])) {
        echo "<$map_array[$name]>";
    }
}

function endElement($parser, $name)
{
    global $map_array;
    if (isset($map_array[$name])) {
        echo "</$map_array[$name]>";
    }
}

function characterData($parser, $data)
{
    echo $data;
}

$xml_parser = xml_parser_create();
// case-folding を用いることで、$map_array から確実にタグを見つけられるようにします
xml_parser_set_option($xml_parser, XML_OPTION_CASE_FOLDING, true);
xml_set_element_handler($xml_parser, "startElement", "endElement");
xml_set_character_data_handler($xml_parser, "characterData");
if (!($fp = fopen($file, "r"))) {
    die("XML 入力をオープンできませんでした");
}

while ($data = fread($fp, 4096)) {
    if (!xml_parse($xml_parser, $data, feof($fp))) {
        die(sprintf("XML エラー: %s が %d 行目で発生しました",
                    xml_error_string(xml_get_error_code($xml_parser)),
                    xml_get_current_line_number($xml_parser)));
    }
}
xml_parser_free($xml_parser);
?>
]]>
  </programlisting>
       </para>
      </example>
     </para>
    </section>

    <section id="example.xml-external-entity">
     <title>XML 外部エンティティの例</title>
     <para>
      この例は、XML コードに焦点を当てます。この例は、他のドキュメント
      をインクルードし処理するための外部エンティティリファレンスのハン
      ドラの使用法およびPIの処理方法、PIが含むコードに関する"信頼度"
      を定義する手段を説明します。
     </para>
     <para>
      この例で使用される XML ドキュメントは、例題ファイル
      (<filename>xmltest.xml</filename> および
      <filename>xmltest2.xml</filename>) にあります。
     </para>
     <para>
      <example>
       <title>外部エンティティの例</title>
       <programlisting role="php">
<![CDATA[
<?php
$file = "xmltest.xml";

function trustedFile($file)
{
    // 信頼できるのは、自分自身が所有しているローカルファイルのみです
    if (!eregi("^([a-z]+)://", $file)
        && fileowner($file) == getmyuid()) {
            return true;
    }
    return false;
}

function startElement($parser, $name, $attribs)
{
    echo "&lt;<font color=\"#0000cc\">$name</font>";
    if (count($attribs)) {
        foreach ($attribs as $k => $v) {
            echo " <font color=\"#009900\">$k</font>=\"<font
                   color=\"#990000\">$v</font>\"";
        }
    }
    echo "&gt;";
}

function endElement($parser, $name)
{
    echo "&lt;/<font color=\"#0000cc\">$name</font>&gt;";
}

function characterData($parser, $data)
{
    echo "<b>$data</b>";
}

function PIHandler($parser, $target, $data)
{
    switch (strtolower($target)) {
        case "php":
            global $parser_file;
            // もし「信頼できる」ドキュメントだった場合、その中に書かれている
            // PHP コードを実行しても安全だと考えます。そうでない場合、
            // コードを実行するかわりにコードそのものを表示します。
            if (trustedFile($parser_file[$parser])) {
                eval($data);
            } else {
                printf("信頼できない PHP コード: <i>%s</i>",
                        htmlspecialchars($data));
            }
            break;
    }
}

function defaultHandler($parser, $data)
{
    if (substr($data, 0, 1) == "&" && substr($data, -1, 1) == ";") {
        printf('<font color="#aa00aa">%s</font>',
                htmlspecialchars($data));
    } else {
        printf('<font size="-1">%s</font>',
                htmlspecialchars($data));
    }
}

function externalEntityRefHandler($parser, $openEntityNames, $base, $systemId,
                                  $publicId) {
    if ($systemId) {
        if (!list($parser, $fp) = new_xml_parser($systemId)) {
            printf("エンティティ %s (%s にある) をオープンできませんでした\n", $openEntityNames,
                   $systemId);
            return false;
        }
        while ($data = fread($fp, 4096)) {
            if (!xml_parse($parser, $data, feof($fp))) {
                printf("XML エラー: %s が、%d 行目でエンティティ %s のパース中に発生しました\n",
                       xml_error_string(xml_get_error_code($parser)),
                       xml_get_current_line_number($parser), $openEntityNames);
                xml_parser_free($parser);
                return false;
            }
        }
        xml_parser_free($parser);
        return true;
    }
    return false;
}

function new_xml_parser($file)
{
    global $parser_file;

    $xml_parser = xml_parser_create();
    xml_parser_set_option($xml_parser, XML_OPTION_CASE_FOLDING, 1);
    xml_set_element_handler($xml_parser, "startElement", "endElement");
    xml_set_character_data_handler($xml_parser, "characterData");
    xml_set_processing_instruction_handler($xml_parser, "PIHandler");
    xml_set_default_handler($xml_parser, "defaultHandler");
    xml_set_external_entity_ref_handler($xml_parser, "externalEntityRefHandler");

    if (!($fp = @fopen($file, "r"))) {
        return false;
    }
    if (!is_array($parser_file)) {
        settype($parser_file, "array");
    }
    $parser_file[$xml_parser] = $file;
    return array($xml_parser, $fp);
}

if (!(list($xml_parser, $fp) = new_xml_parser($file))) {
    die("XML 入力をオープンできませんでした");
}

echo "<pre>";
while ($data = fread($fp, 4096)) {
    if (!xml_parse($xml_parser, $data, feof($fp))) {
        die(sprintf("XML エラー: %s が %d 行目で発生しました\n",
                    xml_error_string(xml_get_error_code($xml_parser)),
                    xml_get_current_line_number($xml_parser)));
    }
}
echo "</pre>";
echo "パースが完了しました\n";
xml_parser_free($xml_parser);

?>
]]>
        </programlisting>
      </example>
     </para>
     <para>
      <example>
       <title>xmltest.xml</title>
       <programlisting role="xml">
<![CDATA[
<?xml version='1.0'?>
<!DOCTYPE chapter SYSTEM "/just/a/test.dtd" [
<!ENTITY plainEntity "FOO entity">
<!ENTITY systemEntity SYSTEM "xmltest2.xml">
]>
<chapter>
 <TITLE>Title &plainEntity;</TITLE>
 <para>
  <informaltable>
   <tgroup cols="3">
    <tbody>
     <row><entry>a1</entry><entry morerows="1">b1</entry><entry>c1</entry></row>
     <row><entry>a2</entry><entry>c2</entry></row>
     <row><entry>a3</entry><entry>b3</entry><entry>c3</entry></row>
    </tbody>
   </tgroup>
  </informaltable>
 </para>
 &systemEntity;
 <section id="about">
  <title>About this Document</title>
  <para>
   <!-- this is a comment -->
   <?php print 'Hi!  This is PHP version '.phpversion(); ?>
  </para>
 </section>
</chapter>
]]>
       </programlisting>
      </example>
     </para>
     <para>
      このファイルは、<filename>xmltest.xml</filename> からインクルードされます。
      <example>
       <title>xmltest2.xml</title>
       <programlisting role="xml">
<![CDATA[
<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY testEnt "test entity">
]>
<foo>
   <element attrib="value"/>
   &testEnt;
   <?php print "This is some more PHP code being executed."; ?>
</foo>
]]>
       </programlisting>
      </example>
     </para>
    </section>
   </section>
  </partintro>

&reference.xml.functions;

 </reference>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->

