<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 328620 $ -->
<chapter xml:id="mysqlnd.plugin" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>MySQL Native Driver プラグインAPI</title>
 <para>
  The MySQL Native Driver プラグインAPI は MySQL Native Driver、略して <literal>mysqlnd</literal> が持つ機能の一つです。<literal>mysqlnd</literal> プラグインは、PHPアプリケーションと MySQL サーバの間にあるレイヤで動きます。これは MySQL Proxy と比較できます。MySQL Proxy はあらゆる MySQL クライアントアプリケーション、たとえば PHPアプリケーション と MySQL サーバの間のレイヤで動きます。<literal>mysqlnd</literal> プラグインは典型的な MySQL Proxy のタスク、たとえばロードバランシングやモニタリング、パフォーマンスの最適化をこなせます。アーキテクチャや置かれる場所が異なるため、<literal>mysqlnd</literal> プラグインは MySQL Proxy が持ついくつかの欠点がありません。たとえば、プラグインを使えば、単一障害点が存在しませんし、専用のプロキシサーバをデプロイする必要もありませんし、新しいプログラミング言語(Lua) を学ぶ必要もありません。
 </para>
 <para>
  <literal>mysqlnd</literal>プラグインは <literal>mysqlnd</literal>の拡張と考えることが出来ます。プラグインは 多くの <literal>mysqlnd</literal> 関数の制御を奪い取ることができます。<literal>mysqlnd</literal> 関数は <literal>ext/mysql</literal> や <literal>ext/mysqli</literal>、<literal>PDO_MYSQL</literal> のような PHP の MySQLエクステンションによって呼び出されます。その結果として、<literal>mysqlnd</literal>プラグイン はクライアントアプリケーションからこれらのエクステンションへの呼び出しの制御をすべて奪うことが出きるのです。
 </para>
 <para>
  内部的な <literal>mysqlnd</literal> 関数の呼び出しも制御を奪ったり、処理を置き換えたりすることができます。<literal>mysqlnd</literal> の内部的な関数テーブルを管理することに関しても全く制限がありません。ある <literal>mysqlnd</literal> 関数が <literal>mysqlnd</literal> を使うエクステンションによって呼び出される場合に、適切な <literal>mysqlnd</literal>プラグインの適切な関数に処理を転送するようにセットアップすることが可能です。このように、<literal>mysqlnd</literal> の内部関数テーブルを管理できることで、プラグインの柔軟性が最大限に発揮できるのです。
 </para>
 <para>
  <literal>mysqlnd</literal>プラグインは、実際は <literal>mysqlnd</literal> のプラグインAPI (これは MySQL Native Driver, 略して <literal>mysqlnd</literal> に組み込まれています) を使い、C言語 で書かれた PHPエクステンション です。 プラグインは PHPアプリケーションに対して 100% 透過的です。つまり、プラグインがPHPアプリケーションとは異なるレイヤで動作するため、アプリケーションを変更する必要がないのです。<literal>mysqlnd</literal>プラグイン は、<literal>mysqlnd</literal> のひとつ下のレイヤで動くと考えることが出来ます。
 </para>
 <para>
  <literal>mysqlnd</literal>プラグインで実現可能なアプリケーションのリストをいくつか以下に示します
 </para>
 <itemizedlist>
  <listitem>
   <para>
    ロードバランシング
   </para>
   <itemizedlist>
    <listitem>
     <para>
      読み取り/書き込み の分割。例として、PECL/mysqlnd_ms (Master Slave) が挙げられます。この エクステンション は 読み取り/書き込み のクエリをレプリケーションのセットアップ向けに分割します。
     </para>
    </listitem>
    <listitem>
     <para>
      フェイルオーバー
     </para>
    </listitem>
    <listitem>
     <para>
      ラウンドロビン, 負荷が一番低いサーバへの転送
     </para>
    </listitem>
   </itemizedlist>
  </listitem>
  <listitem>
   <para>
    サーバの監視
   </para>
   <itemizedlist>
    <listitem>
     <para>
      クエリのロギング
     </para>
    </listitem>
    <listitem>
     <para>
      クエリの分析
     </para>
    </listitem>
    <listitem>
     <para>
      クエリの監査。例として、PECL/mysqlnd_sip (SQL Injection Protection) が挙げられます。この エクステンション はクエリを調べ、ルールセットに従って許可されたクエリのみを実行します。
     </para>
    </listitem>
   </itemizedlist>
  </listitem>
  <listitem>
   <para>
    パフォーマンスの向上
   </para>
   <itemizedlist>
    <listitem>
     <para>
      キャッシュ。例として、PECL/mysqlnd_qc (Query Cache) が挙げられます。
     </para>
    </listitem>
    <listitem>
     <para>
      トラフィックの調整
     </para>
    </listitem>
    <listitem>
     <para>
      シャーディング。例として、PECL/mysqlnd_mc (Multi Connect) が挙げられます。このエクステンション は、SELECT ステートメントを SELECT ... LIMIT part1, SELECT LIMIT part_n という形でn個に分割します。そしてクエリを別々の MySQLサーバに送り、結果をクライアント側でマージします。
     </para>
    </listitem>
   </itemizedlist>
  </listitem>
 </itemizedlist>
 <para>
  <emphasis role="bold">利用可能な MySQL Native Driverプラグイン</emphasis>
 </para>
 <para>
  既にたくさんの mysqlnd プラグインが利用可能になっています。以下が含まれます。
 </para>
 <itemizedlist>
  <listitem>
   <para>
    <emphasis role="bold">PECL/mysqlnd_mc</emphasis> - 複数接続ができるプラグイン
   </para>
  </listitem>
  <listitem>
   <para>
    <emphasis role="bold">PECL/mysqlnd_ms</emphasis> - マスタースレーブ構成用のプラグイン
   </para>
  </listitem>
  <listitem>
   <para>
    <emphasis role="bold">PECL/mysqlnd_qc</emphasis> - クエリキャッシュプラグイン
   </para>
  </listitem>
  <listitem>
   <para>
    <emphasis role="bold">PECL/mysqlnd_pscache</emphasis> - プリペアドステートメントハンドルをキャッシュするプラグイン
   </para>
  </listitem>
  <listitem>
   <para>
    <emphasis role="bold">PECL/mysqlnd_sip</emphasis> - SQLインジェクションから防御するためのプラグイン
   </para>
  </listitem>
  <listitem>
   <para>
    <emphasis role="bold">PECL/mysqlnd_uh</emphasis> - ユーザーハンドラープラグイン
   </para>
  </listitem>
 </itemizedlist>
 <section xml:id="mysqlnd.plugin.mysql-proxy">
  <title>mysqlndプラグイン と MySQL Proxyの比較</title>
  <para>
   <literal>mysqlnd</literal>プラグインと MySQL Proxyは、異なるアプローチを用いた異なる技術です。どちらもロードバランシングや監視、パフォーマンスの向上のような共通の様々な課題を解決するのに適したツールです。重要な違いは、MySQL Proxyがあらゆる MySQLクライアント と協調して動作するのに対して、<literal>mysqlnd</literal>プラグインは PHPアプリケーション との協調動作に特化しているということです。
  </para>
  <para>
   PHPエクステンションとして、<literal>mysqlnd</literal>プラグイン はPHPの残りの部分とともに、PHPのアプリケーションサーバにインストールされます。MySQL Proxy はPHPアプリケーションサーバ上でも動作しますし、複数のPHPアプリケーションサーバを扱う専用マシンにもインストール出来ます。
  </para>
  <para>
   MySQL Proxyをアプリケーションサーバにデプロイすることにはふたつの利点があります:
  </para>
  <orderedlist>
   <listitem>
    <para>
     単一障害点がない
    </para>
   </listitem>
   <listitem>
    <para>
     スケールアウトしやすい (水平方向へのスケールアウト、クライアントによるスケーリング)
    </para>
   </listitem>
  </orderedlist>
  <para>
   MySQL Proxy (と、<literal>mysqlnd</literal>プラグイン) は、他のやり方だと既存のアプリケーションを変更しなければならない問題にも容易に対処することができます。
  </para>
  <para>
   しかし、MySQL Proxyにはいくつか欠点があります:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     MySQL Proxy は新たにマスターし、デプロイしなければならないコンポーネント、技術です
    </para>
   </listitem>
   <listitem>
    <para>
     MySQL Proxy は Lua スクリプト言語の知識が必要です。
    </para>
   </listitem>
  </itemizedlist>
  <para>
   MySQL Proxy は C言語と プログラミング言語 Lua によってカスタマイズ出来ます。Lua は MySQL Proxy において好ましいスクリプト言語です。ほとんどのPHPエキスパートにとって、Lua は新しく学ばなければならない言語です。<literal>mysqlnd</literal>プラグインは C言語で書くことができます。<link xlink:href="http://pecl.php.net/package/mysqlnd_uh">PECL/mysqlnd_uh</link> を使って、プラグインを PHP で書くこともできます。
  </para>
  <para>
   MySQL Proxy はデーモン - バックグラウンドのプロセスとして動作します。MySQL Proxy は初期の決定を取り消すことも出来ますが、すべての状態を保持することできます。しかしながら <literal>mysqlnd</literal>プラグインは、PHPのリクエスト単位のライフサイクルに結びついています。MySQL Proxy は一度計算された結果を複数のアプリケーションサーバで共有出来ます。<literal>mysqlnd</literal>プラグインでこれを行うには、永続的なストレージにデータを保存する必要があります。この目的のためには Memcache のような別のデーモンが必要です。この場合は、MySQL Proxy に有利です。
  </para>
  <para>
   MySQL Proxy は wire protocol (訳注：ネットワークを通じてデータを転送するプロトコル。<link xlink:href="http://en.wikipedia.org/wiki/Wire_protocol">WikipediaでのWire Protocolの説明</link>, <link xlink:href="http://stackoverflow.com/questions/2324089/can-someone-explain-what-a-wire-level-protocol-is">StackOverflow でのWire Protocolの説明</link>) の上で動作します。MySQL Proxy を使うと、MySQLクライアントサーバプロトコルを解析し、リバースエンジニアリングしなければなりません。MySQL Proxy できることは、通信プロトコルを管理することで達成できることに限られます。wire protocol が変更(滅多にありませんが)されると、MySQL Proxy のスクリプトも変更する必要があります。
  </para>
  <para>
   <literal>mysqlnd</literal>プラグインは C言語のAPI上で動作します。このAPIは <literal>libmysql</literal>クライアント と Connector/C API の動きをそのままコピーしています。この C言語のAPI は、 基本的に MySQLクライアントサーバプロトコル、時に wire protocol と呼ばれるもののラッパーです。開発者は C言語のAPI呼び出しの制御を奪うことができます。それゆえに、wire protocol レベルのプログラムに一切変更を加えることなく、すべてのPHP呼び出しをフックできるのです。
  </para>
  <para>
   <literal>mysqlnd</literal> は wire protocol を実装しています。そのため、プラグインは通信プロトコルを解析し、リバースエンジニアリングし、管理できるばかりか、通信プロトコルを置き換えることだってできます。ただ、こんなことをする必要は通常ありません。
  </para>
  <para>
   プラグインが 2つのレベル(C言語のAPI と wire protocol) を使って実装できるので、MySQL Proxy よりも大きな柔軟性を得られます。 <literal>mysqlnd</literal>プラグインが C言語のAPI を使って実装されれば、wire protocol に対していかなる変更が行われても、プラグインへの変更は必要ありません。
  </para>
 </section>
 <section xml:id="mysqlnd.plugin.obtaining">
  <title>mysqlnd plugin APIを取得する</title>
  <para>
   <literal>mysqlnd</literal>プラグインAPI は、MySQL Native Driver PHPエクステンションである <literal>ext/mysqlnd</literal> の一部です。2009年12月に <literal>mysqlnd</literal>プラグインAPI の開発がスタートしました。これは PHP のソースリポジトリの一分として開発が進められ、git経由で公開されたり、ソースコードのスナップショットがダウンロード可能になっています。
  </para>
  <para>
   次の表は、PHPのバージョンとそれに含まれている <literal>mysqlnd</literal> の対応バージョンを示しています。
  </para>
  <table>
   <title>PHPのリリースにバンドルされた mysqlnd のバージョン</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>PHP のバージョン</entry>
      <entry>MySQL Native Driver のバージョン</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>5.3.0</entry>
      <entry>5.0.5</entry>
     </row>
     <row>
      <entry>5.3.1</entry>
      <entry>5.0.5</entry>
     </row>
     <row>
      <entry>5.3.2</entry>
      <entry>5.0.7</entry>
     </row>
     <row>
      <entry>5.3.3</entry>
      <entry>5.0.7</entry>
     </row>
     <row>
      <entry>5.3.4</entry>
      <entry>5.0.7</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   プラグインの開発者は <literal>mysqlnd</literal> のバージョンを <literal>MYSQLND_VERSION</literal> にアクセスすることで決めることができます。この値は、<quote>mysqlnd 5.0.7-dev - 091210 - $Revision: 300535</quote> という文字列フォーマットです。または、<literal>MYSQLND_VERSION_ID</literal> という値にもアクセスできます。これはたとえば、50007 のような数値です。 開発者は次のようにしてバージョン番号を計算することが出来ます:
  </para>
  <table>
   <title>MYSQLND_VERSION_ID 計算テーブル</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Version (一部)</entry>
      <entry>例</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>Major*10000</entry>
      <entry>5*10000 = 50000</entry>
     </row>
     <row>
      <entry>Minor*100</entry>
      <entry>0*100 = 0</entry>
     </row>
     <row>
      <entry>Patch</entry>
      <entry>7 = 7</entry>
     </row>
     <row>
      <entry>MYSQLND_VERSION_ID</entry>
      <entry>50007</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   開発している間は、開発者は <literal>mysqlnd</literal> のバージョン番号を互換性と対応バージョンのテストとして参照すべきです。PHP本体のひとつのバージョンにおける開発のライフサイクルの間に、<literal>mysqlnd</literal> の開発イテレーションは複数行われる場合があるためです。
  </para>
 </section>
 <section xml:id="mysqlnd.plugin.architecture">
  <title>MySQL Native Driver Plugin Architecture</title>
  <para>
   This section provides an overview of the <literal>mysqlnd</literal>
   plugin architecture.
  </para>
  <para>
   <emphasis role="bold"> MySQL Native Driver Overview </emphasis>
  </para>
  <para>
   Before developing <literal>mysqlnd</literal> plugins, it is useful to
   know a little of how <literal>mysqlnd</literal> itself is organized.
   <literal>Mysqlnd</literal> consists of the following modules:
  </para>
  <table>
   <title>The mysqlnd organization chart, per module</title>
   <tgroup cols="2">
    <tbody>
     <row>
      <entry>Modules Statistics</entry>
      <entry>mysqlnd_statistics.c</entry>
     </row>
     <row>
      <entry>Connection</entry>
      <entry>mysqlnd.c</entry>
     </row>
     <row>
      <entry>Resultset</entry>
      <entry>mysqlnd_result.c</entry>
     </row>
     <row>
      <entry>Resultset Metadata</entry>
      <entry>mysqlnd_result_meta.c</entry>
     </row>
     <row>
      <entry>Statement</entry>
      <entry>mysqlnd_ps.c</entry>
     </row>
     <row>
      <entry>Network</entry>
      <entry>mysqlnd_net.c</entry>
     </row>
     <row>
      <entry>Wire protocol</entry>
      <entry>mysqlnd_wireprotocol.c</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   <emphasis role="bold">C Object Oriented Paradigm</emphasis>
  </para>
  <para>
   At the code level, <literal>mysqlnd</literal> uses a C pattern for
   implementing object orientation.
  </para>
  <para>
   In C you use a <literal>struct</literal> to represent an object.
   Members of the struct represent object properties. Struct members
   pointing to functions represent methods.
  </para>
  <para>
   Unlike with other languages such as C++ or Java, there are no fixed
   rules on inheritance in the C object oriented paradigm. However,
   there are some conventions that need to be followed that will be
   discussed later.
  </para>
  <para>
   <emphasis role="bold">The PHP Life Cycle</emphasis>
  </para>
  <para>
   When considering the PHP life cycle there are two basic cycles:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     PHP engine startup and shutdown cycle
    </para>
   </listitem>
   <listitem>
    <para>
     Request cycle
    </para>
   </listitem>
  </itemizedlist>
  <para>
   When the PHP engine starts up it will call the module initialization
   (MINIT) function of each registered extension. This allows each
   module to setup variables and allocate resources that will exist for
   the lifetime of the PHP engine process. When the PHP engine shuts
   down it will call the module shutdown (MSHUTDOWN) function of each
   extension.
  </para>
  <para>
   During the lifetime of the PHP engine it will receive a number of
   requests. Each request constitutes another life cycle. On each
   request the PHP engine will call the request initialization function
   of each extension. The extension can perform any variable setup and
   resource allocation required for request processing. As the request
   cycle ends the engine calls the request shutdown (RSHUTDOWN) function
   of each extension so the extension can perform any cleanup required.
  </para>
  <para>
   <emphasis role="bold">How a plugin works</emphasis>
  </para>
  <para>
   A <literal>mysqlnd</literal> plugin works by intercepting calls made
   to <literal>mysqlnd</literal> by extensions that use
   <literal>mysqlnd</literal>. This is achieved by obtaining the
   <literal>mysqlnd</literal> function table, backing it up, and
   replacing it by a custom function table, which calls the functions of
   the plugin as required.
  </para>
  <para>
   The following code shows how the <literal>mysqlnd</literal> function
   table is replaced:
  </para>
<programlisting>
<![CDATA[
/* a place to store original function table */
struct st_mysqlnd_conn_methods org_methods;

void minit_register_hooks(TSRMLS_D) {
  /* active function table */
  struct st_mysqlnd_conn_methods * current_methods
    = mysqlnd_conn_get_methods();

  /* backup original function table */
  memcpy(&org_methods, current_methods,
    sizeof(struct st_mysqlnd_conn_methods);

  /* install new methods */
  current_methods->query = MYSQLND_METHOD(my_conn_class, query);
}
]]>
</programlisting>
  <para>
   Connection function table manipulations must be done during Module
   Initialization (MINIT). The function table is a global shared
   resource. In an multi-threaded environment, with a TSRM build, the
   manipulation of a global shared resource during the request
   processing will almost certainly result in conflicts.
  </para>
  <note>
   <para>
    Do not use any fixed-size logic when manipulating the
    <literal>mysqlnd</literal> function table: new methods may be added
    at the end of the function table. The function table may change at
    any time in the future.
   </para>
  </note>
  <para>
   <emphasis role="bold">Calling parent methods</emphasis>
  </para>
  <para>
   If the original function table entries are backed up, it is still
   possible to call the original function table entries - the parent
   methods.
  </para>
  <para>
   In some cases, such as for
   <literal>Connection::stmt_init()</literal>, it is vital to call the
   parent method prior to any other activity in the derived method.
  </para>
<programlisting>
<![CDATA[
MYSQLND_METHOD(my_conn_class, query)(MYSQLND *conn,
  const char *query, unsigned int query_len TSRMLS_DC) {

  php_printf("my_conn_class::query(query = %s)\n", query);

  query = "SELECT 'query rewritten' FROM DUAL";
  query_len = strlen(query);

  return org_methods.query(conn, query, query_len); /* return with call to parent */
}
]]>
</programlisting>
  <para>
   <emphasis role="bold"> Extending properties </emphasis>
  </para>
  <para>
   A <literal>mysqlnd</literal> object is represented by a C struct. It
   is not possible to add a member to a C struct at run time. Users of
   <literal>mysqlnd</literal> objects cannot simply add properties to
   the objects.
  </para>
  <para>
   Arbitrary data (properties) can be added to a
   <literal>mysqlnd</literal> objects using an appropriate function of
   the
   <literal>mysqlnd_plugin_get_plugin_&lt;object&gt;_data()</literal>
   family. When allocating an object <literal>mysqlnd</literal> reserves
   space at the end of the object to hold a <literal>void *</literal>
   pointer to arbitrary data. <literal>mysqlnd</literal> reserves space
   for one <literal>void *</literal> pointer per plugin.
  </para>
  <para>
   The following table shows how to calculate the position of the
   pointer for a specific plugin:
  </para>
  <table>
   <title>Pointer calculations for mysqlnd</title>
   <tgroup cols="2">
    <tbody>
     <row>
      <entry>Memory address</entry>
      <entry>Contents</entry>
     </row>
     <row>
      <entry>0</entry>
      <entry>Beginning of the mysqlnd object C struct</entry>
     </row>
     <row>
      <entry>n</entry>
      <entry>End of the mysqlnd object C struct</entry>
     </row>
     <row>
      <entry>n + (m x sizeof(void*))</entry>
      <entry>void* to object data of the m-th plugin</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   If you plan to subclass any of the <literal>mysqlnd</literal> object
   constructors, which is allowed, you must keep this in mind!
  </para>
  <para>
   The following code shows extending properties:
  </para>
<programlisting>
<![CDATA[
/* any data we want to associate */
typedef struct my_conn_properties {
  unsigned long query_counter;
} MY_CONN_PROPERTIES;

/* plugin id */
unsigned int my_plugin_id;

void minit_register_hooks(TSRMLS_D) {
  /* obtain unique plugin ID */
  my_plugin_id = mysqlnd_plugin_register();
  /* snip - see Extending Connection: methods */
}

static MY_CONN_PROPERTIES** get_conn_properties(const MYSQLND *conn TSRMLS_DC) {
  MY_CONN_PROPERTIES** props;
  props = (MY_CONN_PROPERTIES**)mysqlnd_plugin_get_plugin_connection_data(
    conn, my_plugin_id);
  if (!props || !(*props)) {
    *props = mnd_pecalloc(1, sizeof(MY_CONN_PROPERTIES), conn->persistent);
    (*props)->query_counter = 0;
  }
  return props;
}
]]>
</programlisting>
  <para>
   The plugin developer is responsible for the management of plugin data
   memory.
  </para>
  <para>
   Use of the <literal>mysqlnd</literal> memory allocator is recommended
   for plugin data. These functions are named using the convention:
   <literal>mnd_*loc()</literal>. The <literal>mysqlnd</literal>
   allocator has some useful features, such as the ability to use a
   debug allocator in a non-debug build.
  </para>
  <table>
   <title>When and how to subclass</title>
   <tgroup cols="4">
    <tbody>
     <row>
      <entry></entry>
      <entry>When to subclass?</entry>
      <entry>Each instance has its own private function table?</entry>
      <entry>How to subclass?</entry>
     </row>
     <row>
      <entry>Connection (MYSQLND)</entry>
      <entry>MINIT</entry>
      <entry>No</entry>
      <entry>mysqlnd_conn_get_methods()</entry>
     </row>
     <row>
      <entry>Resultset (MYSQLND_RES)</entry>
      <entry>MINIT or later</entry>
      <entry>Yes</entry>
      <entry>mysqlnd_result_get_methods() or object method function table
       manipulation</entry>
     </row>
     <row>
      <entry>Resultset Meta (MYSQLND_RES_METADATA)</entry>
      <entry>MINIT</entry>
      <entry>No</entry>
      <entry>mysqlnd_result_metadata_get_methods()</entry>
     </row>
     <row>
      <entry>Statement (MYSQLND_STMT)</entry>
      <entry>MINIT</entry>
      <entry>No</entry>
      <entry>mysqlnd_stmt_get_methods()</entry>
     </row>
     <row>
      <entry>Network (MYSQLND_NET)</entry>
      <entry>MINIT or later</entry>
      <entry>Yes</entry>
      <entry>mysqlnd_net_get_methods() or object method function table manipulation</entry>
     </row>
     <row>
      <entry>Wire protocol (MYSQLND_PROTOCOL)</entry>
      <entry>MINIT or later</entry>
      <entry>Yes</entry>
      <entry>mysqlnd_protocol_get_methods() or object method function table
       manipulation</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   You must not manipulate function tables at any time later than MINIT
   if it is not allowed according to the above table.
  </para>
  <para>
   Some classes contain a pointer to the method function table. All
   instances of such a class will share the same function table. To
   avoid chaos, in particular in threaded environments, such function
   tables must only be manipulated during MINIT.
  </para>
  <para>
   Other classes use copies of a globally shared function table. The
   class function table copy is created together with the object. Each
   object uses its own function table. This gives you two options: you
   can manipulate the default function table of an object at MINIT, and
   you can additionally refine methods of an object without impacting
   other instances of the same class.
  </para>
  <para>
   The advantage of the shared function table approach is performance.
   There is no need to copy a function table for each and every object.
  </para>
  <table>
   <title>Constructor status</title>
   <tgroup cols="4">
    <tbody>
     <row>
      <entry></entry>
      <entry>Allocation, construction, reset</entry>
      <entry>Can be modified?</entry>
      <entry>Caller</entry>
     </row>
     <row>
      <entry>Connection (MYSQLND)</entry>
      <entry>mysqlnd_init()</entry>
      <entry>No</entry>
      <entry>mysqlnd_connect()</entry>
     </row>
     <row>
      <entry>Resultset(MYSQLND_RES)</entry>
      <entry><para>
        Allocation:
       </para>
       <itemizedlist>
        <listitem>
         <para>
          Connection::result_init()
         </para>
        </listitem>
       </itemizedlist>
       <para>
        Reset and re-initialized during:
       </para>
       <itemizedlist>
        <listitem>
         <para>
          Result::use_result()
         </para>
        </listitem>
        <listitem>
         <para>
          Result::store_result
         </para>
        </listitem>
       </itemizedlist></entry>
      <entry>Yes, but call parent!</entry>
      <entry><itemizedlist>
        <listitem>
         <para>
          Connection::list_fields()
         </para>
        </listitem>
        <listitem>
         <para>
          Statement::get_result()
         </para>
        </listitem>
        <listitem>
         <para>
          Statement::prepare() (Metadata only)
         </para>
        </listitem>
        <listitem>
         <para>
          Statement::resultMetaData()
         </para>
        </listitem>
       </itemizedlist></entry>
     </row>
     <row>
      <entry>Resultset Meta (MYSQLND_RES_METADATA)</entry>
      <entry>Connection::result_meta_init()</entry>
      <entry>Yes, but call parent!</entry>
      <entry>Result::read_result_metadata()</entry>
     </row>
     <row>
      <entry>Statement (MYSQLND_STMT)</entry>
      <entry>Connection::stmt_init()</entry>
      <entry>Yes, but call parent!</entry>
      <entry>Connection::stmt_init()</entry>
     </row>
     <row>
      <entry>Network (MYSQLND_NET)</entry>
      <entry>mysqlnd_net_init()</entry>
      <entry>No</entry>
      <entry>Connection::init()</entry>
     </row>
     <row>
      <entry>Wire protocol (MYSQLND_PROTOCOL)</entry>
      <entry>mysqlnd_protocol_init()</entry>
      <entry>No</entry>
      <entry>Connection::init()</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   It is strongly recommended that you do not entirely replace a
   constructor. The constructors perform memory allocations. The memory
   allocations are vital for the <literal>mysqlnd</literal> plugin API
   and the object logic of <literal>mysqlnd</literal>. If you do not
   care about warnings and insist on hooking the constructors, you
   should at least call the parent constructor before doing anything in
   your constructor.
  </para>
  <para>
   Regardless of all warnings, it can be useful to subclass
   constructors. Constructors are the perfect place for modifying the
   function tables of objects with non-shared object tables, such as
   Resultset, Network, Wire Protocol.
  </para>
  <table>
   <title>Destruction status</title>
   <tgroup cols="3">
    <tbody>
     <row>
      <entry></entry>
      <entry>Derived method must call parent?</entry>
      <entry>Destructor</entry>
     </row>
     <row>
      <entry>Connection</entry>
      <entry>yes, after method execution</entry>
      <entry>free_contents(), end_psession()</entry>
     </row>
     <row>
      <entry>Resultset</entry>
      <entry>yes, after method execution</entry>
      <entry>free_result()</entry>
     </row>
     <row>
      <entry>Resultset Meta</entry>
      <entry>yes, after method execution</entry>
      <entry>free()</entry>
     </row>
     <row>
      <entry>Statement</entry>
      <entry>yes, after method execution</entry>
      <entry>dtor(), free_stmt_content()</entry>
     </row>
     <row>
      <entry>Network</entry>
      <entry>yes, after method execution</entry>
      <entry>free()</entry>
     </row>
     <row>
      <entry>Wire protocol</entry>
      <entry>yes, after method execution</entry>
      <entry>free()</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   The destructors are the appropriate place to free properties,
   <literal>mysqlnd_plugin_get_plugin_<replaceable>&lt;object&gt;</replaceable>_data()</literal>.
  </para>
  <para>
   The listed destructors may not be equivalent to the actual
   <literal>mysqlnd</literal> method freeing the object itself. However,
   they are the best possible place for you to hook in and free your
   plugin data. As with constructors you may replace the methods
   entirely but this is not recommended. If multiple methods are listed
   in the above table you will need to hook all of the listed methods
   and free your plugin data in whichever method is called first by
   <literal>mysqlnd</literal>.
  </para>
  <para>
   The recommended method for plugins is to simply hook the methods,
   free your memory and call the parent implementation immediately
   following this.
  </para>
  <caution>
   <para>
    Due to a bug in PHP versions 5.3.0 to 5.3.3, plugins do not
    associate plugin data with a persistent connection. This is because
    <literal>ext/mysql</literal> and <literal>ext/mysqli</literal> do
    not trigger all the necessary <literal>mysqlnd</literal>
    <literal>end_psession()</literal> method calls and the plugin may
    therefore leak memory. This has been fixed in PHP 5.3.4.
   </para>
  </caution>
 </section>
 <section xml:id="mysqlnd.plugin.api">
  <title>The mysqlnd plugin API</title>
  <para>
   The following is a list of functions provided in the
   <literal>mysqlnd</literal> plugin API:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     mysqlnd_plugin_register()
    </para>
   </listitem>
   <listitem>
    <para>
     mysqlnd_plugin_count()
    </para>
   </listitem>
   <listitem>
    <para>
     mysqlnd_plugin_get_plugin_connection_data()
    </para>
   </listitem>
   <listitem>
    <para>
     mysqlnd_plugin_get_plugin_result_data()
    </para>
   </listitem>
   <listitem>
    <para>
     mysqlnd_plugin_get_plugin_stmt_data()
    </para>
   </listitem>
   <listitem>
    <para>
     mysqlnd_plugin_get_plugin_net_data()
    </para>
   </listitem>
   <listitem>
    <para>
     mysqlnd_plugin_get_plugin_protocol_data()
    </para>
   </listitem>
   <listitem>
    <para>
     mysqlnd_conn_get_methods()
    </para>
   </listitem>
   <listitem>
    <para>
     mysqlnd_result_get_methods()
    </para>
   </listitem>
   <listitem>
    <para>
     mysqlnd_result_meta_get_methods()
    </para>
   </listitem>
   <listitem>
    <para>
     mysqlnd_stmt_get_methods()
    </para>
   </listitem>
   <listitem>
    <para>
     mysqlnd_net_get_methods()
    </para>
   </listitem>
   <listitem>
    <para>
     mysqlnd_protocol_get_methods()
    </para>
   </listitem>
  </itemizedlist>
  <para>
   There is no formal definition of what a plugin is and how a plugin
   mechanism works.
  </para>
  <para>
   Components often found in plugins mechanisms are:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     A plugin manager
    </para>
   </listitem>
   <listitem>
    <para>
     A plugin API
    </para>
   </listitem>
   <listitem>
    <para>
     Application services (or modules)
    </para>
   </listitem>
   <listitem>
    <para>
     Application service APIs (or module APIs)
    </para>
   </listitem>
  </itemizedlist>
  <para>
   The <literal>mysqlnd</literal> plugin concept employs these features,
   and additionally enjoys an open architecture.
  </para>
  <para>
   <emphasis role="bold"> No Restrictions </emphasis>
  </para>
  <para>
   A plugin has full access to the inner workings of
   <literal>mysqlnd</literal>. There are no security limits or
   restrictions. Everything can be overwritten to implement friendly or
   hostile algorithms. It is recommended you only deploy plugins from a
   trusted source.
  </para>
  <para>
   As discussed previously, plugins can use pointers freely. These
   pointers are not restricted in any way, and can point into another
   plugin's data. Simple offset arithmetic can be used to read another
   plugin's data.
  </para>
  <para>
   It is recommended that you write cooperative plugins, and that you
   always call the parent method. The plugins should always cooperate
   with <literal>mysqlnd</literal> itself.
  </para>
  <table>
   <title>Issues: an example of chaining and cooperation</title>
   <tgroup cols="3">
    <tbody>
     <row>
      <entry>Extension</entry>
      <entry>mysqlnd.query() pointer</entry>
      <entry>call stack if calling parent</entry>
     </row>
     <row>
      <entry>ext/mysqlnd</entry>
      <entry>mysqlnd.query()</entry>
      <entry>mysqlnd.query</entry>
     </row>
     <row>
      <entry>ext/mysqlnd_cache</entry>
      <entry>mysqlnd_cache.query()</entry>
      <entry><orderedlist>
        <listitem>
         <para>
          mysqlnd_cache.query()
         </para>
        </listitem>
        <listitem>
         <para>
          mysqlnd.query
         </para>
        </listitem>
       </orderedlist></entry>
     </row>
     <row>
      <entry>ext/mysqlnd_monitor</entry>
      <entry>mysqlnd_monitor.query()</entry>
      <entry><orderedlist>
        <listitem>
         <para>
          mysqlnd_monitor.query()
         </para>
        </listitem>
        <listitem>
         <para>
          mysqlnd_cache.query()
         </para>
        </listitem>
        <listitem>
         <para>
          mysqlnd.query
         </para>
        </listitem>
       </orderedlist></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   In this scenario, a cache (<literal>ext/mysqlnd_cache</literal>) and
   a monitor (<literal>ext/mysqlnd_monitor</literal>) plugin are loaded.
   Both subclass <literal>Connection::query()</literal>. Plugin
   registration happens at <literal>MINIT</literal> using the logic
   shown previously. PHP calls extensions in alphabetical order by
   default. Plugins are not aware of each other and do not set extension
   dependencies.
  </para>
  <para>
   By default the plugins call the parent implementation of the query
   method in their derived version of the method.
  </para>
  <para>
   <emphasis role="bold"> PHP Extension Recap </emphasis>
  </para>
  <para>
   This is a recap of what happens when using an example plugin,
   <literal>ext/mysqlnd_plugin</literal>, which exposes the
   <literal>mysqlnd</literal> C plugin API to PHP:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     Any PHP MySQL application tries to establish a connection to
     192.168.2.29
    </para>
   </listitem>
   <listitem>
    <para>
     The PHP application will either use <literal>ext/mysql</literal>,
     <literal>ext/mysqli</literal> or <literal>PDO_MYSQL</literal>. All
     three PHP MySQL extensions use <literal>mysqlnd</literal> to
     establish the connection to 192.168.2.29.
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>Mysqlnd</literal> calls its connect method, which has been
     subclassed by <literal>ext/mysqlnd_plugin</literal>.
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>ext/mysqlnd_plugin</literal> calls the userspace hook
     <literal>proxy::connect()</literal> registered by the user.
    </para>
   </listitem>
   <listitem>
    <para>
     The userspace hook changes the connection host IP from 192.168.2.29
     to 127.0.0.1 and returns the connection established by
     <literal>parent::connect()</literal>.
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>ext/mysqlnd_plugin</literal> performs the equivalent of
     <literal>parent::connect(127.0.0.1)</literal> by calling the
     original <literal>mysqlnd</literal> method for establishing a
     connection.
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>ext/mysqlnd</literal> establishes a connection and returns
     to <literal>ext/mysqlnd_plugin</literal>.
     <literal>ext/mysqlnd_plugin</literal> returns as well.
    </para>
   </listitem>
   <listitem>
    <para>
     Whatever PHP MySQL extension had been used by the application, it
     receives a connection to 127.0.0.1. The PHP MySQL extension itself
     returns to the PHP application. The circle is closed.
    </para>
   </listitem>
  </itemizedlist>
 </section>
 <section xml:id="mysqlnd.plugin.developing">
  <title>mysqlndプラグインのビルドをはじめる</title>
  <para>
   <literal>mysqlnd</literal>プラグイン それ自体が PHPエクステンション であることを覚えておくことが重要です。
  </para>
  <para>
   次のコードは、典型的な <literal>mysqlnd</literal> プラグインで使われる MINIT 関数の基本構造を示します。
  </para>
<programlisting>
<![CDATA[
/* my_php_mysqlnd_plugin.c */

 static PHP_MINIT_FUNCTION(mysqlnd_plugin) {
  /* globals, ini entries, resources, classes */

  /* register mysqlnd plugin */
  mysqlnd_plugin_id = mysqlnd_plugin_register();

  conn_m = mysqlnd_get_conn_methods();
  memcpy(org_conn_m, conn_m,
    sizeof(struct st_mysqlnd_conn_methods));

  conn_m->query = MYSQLND_METHOD(mysqlnd_plugin_conn, query);
  conn_m->connect = MYSQLND_METHOD(mysqlnd_plugin_conn, connect);
}
]]>
</programlisting>
<programlisting>
<![CDATA[
/* my_mysqlnd_plugin.c */

 enum_func_status MYSQLND_METHOD(mysqlnd_plugin_conn, query)(/* ... */) {
  /* ... */
}
enum_func_status MYSQLND_METHOD(mysqlnd_plugin_conn, connect)(/* ... */) {
  /* ... */
}
]]>
</programlisting>
  <para>
   <emphasis role="bold">タスクの解析: C言語からユーザースペースへ</emphasis>
  </para>
<programlisting>
<![CDATA[
 class proxy extends mysqlnd_plugin_connection {
  public function connect($host, ...) { .. }
}
mysqlnd_plugin_set_conn_proxy(new proxy());
]]>
</programlisting>
  <para>
   プロセス:
  </para>
  <orderedlist>
   <listitem>
    <para>
     PHP: ユーザーがプラグインのコールバックを登録する
    </para>
   </listitem>
   <listitem>
    <para>
     PHP: ユーザーがMySQLに接続するため、任意の PHP MySQL API を呼び出す
    </para>
   </listitem>
   <listitem>
    <para>
     C: ext/*mysql* が mysqlnd のメソッドを呼び出す
    </para>
   </listitem>
   <listitem>
    <para>
     C: mysqlnd が ext/mysqlnd_plugin の中で終了する
    </para>
   </listitem>
   <listitem>
    <para>
     C: ext/mysqlnd_plugin
     <orderedlist>
      <listitem>
       <para>
        ユーザースペースで登録されたコールバックを呼び出す
       </para>
      </listitem>
      <listitem>
       <para>
        また、ユーザースペースのコールバックが登録されていない場合は、<literal>mysqlnd</literal> のメソッドを呼び出す。
       </para>
      </listitem>
     </orderedlist>
    </para>
   </listitem>
  </orderedlist>
  <para>
   次のことを実行する必要があります:
  </para>
  <orderedlist>
   <listitem>
    <para>
     "mysqlnd_plugin_connection" というクラスを C言語で書く
    </para>
   </listitem>
   <listitem>
    <para>
     "mysqlnd_plugin_set_conn_proxy()" 関数を使って、プロキシオブジェクトを受け入れ、登録する
    </para>
   </listitem>
   <listitem>
    <para>
     C言語から、ユーザースペースへのプロキシメソッドを呼び出す (最適化 - zend_interface.h)
    </para>
   </listitem>
  </orderedlist>
  <para>
   ユーザースペースのオブジェクトメソッドは、<literal>call_user_function()</literal> を使うか、<literal>zend_call_method()</literal> を使って Zend Engine に近いレベルで操作を行うことができます。
  </para>
  <para>
   <emphasis role="bold"> 最適化: C言語から zend_call_method を使ってメソッドを呼び出す</emphasis>
  </para>
  <para>
   次に示すコードの断片は、<literal>zend_call_method</literal> のプロトタイプを示しています。これは <filename>zend_interface.h</filename> からとってきたものです。
  </para>
<programlisting>
<![CDATA[
 ZEND_API zval* zend_call_method(
  zval **object_pp, zend_class_entry *obj_ce,
  zend_function **fn_proxy, char *function_name,
  int function_name_len, zval **retval_ptr_ptr,
  int param_count, zval* arg1, zval* arg2 TSRMLS_DC
);
]]>
</programlisting>
  <para>
   Zend API は2つの引数しかサポートしていません。それ以上必要な場合は、たとえば次のようにします。
  </para>
<programlisting>
<![CDATA[
 enum_func_status (*func_mysqlnd_conn__connect)(
  MYSQLND *conn, const char *host,
  const char * user, const char * passwd,
  unsigned int passwd_len, const char * db,
  unsigned int db_len, unsigned int port,
  const char * socket, unsigned int mysql_flags TSRMLS_DC
);
]]>
</programlisting>
  <para>
   この問題に対処するには、<literal>zend_call_method()</literal> のコピーを作り、追加の引数の入れ物を追加する必要があるでしょう。これは、<literal>MY_ZEND_CALL_METHOD_WRAPPER</literal> マクロの組を作ることで実現できます。
  </para>
  <para>
   <emphasis role="bold">PHP のユーザースペースを呼び出す</emphasis>
  </para>
  <para>
   以下のコードは、C言語からユーザースペースの関数を呼ぶための最適化されたやり方を示しています:
  </para>
<programlisting>
<![CDATA[ 
/* my_mysqlnd_plugin.c */

MYSQLND_METHOD(my_conn_class,connect)(
  MYSQLND *conn, const char *host /* ... */ TSRMLS_DC) {
  enum_func_status ret = FAIL;
  zval * global_user_conn_proxy = fetch_userspace_proxy();
  if (global_user_conn_proxy) {
    /* call userspace proxy */
    ret = MY_ZEND_CALL_METHOD_WRAPPER(global_user_conn_proxy, host, /*...*/);
  } else {
    /* or original mysqlnd method = do nothing, be transparent */
    ret = org_methods.connect(conn, host, user, passwd,
          passwd_len, db, db_len, port,
          socket, mysql_flags TSRMLS_CC);
  }
  return ret;
}
]]>
</programlisting>
  <para>
   <emphasis role="bold"> ユーザースペースを呼び出す: 引数が一つの場合
   </emphasis>
  </para>
<programlisting>
<![CDATA[
/* my_mysqlnd_plugin.c */

 MYSQLND_METHOD(my_conn_class,connect)(
  /* ... */, const char *host, /* ...*/) {
  /* ... */
  if (global_user_conn_proxy) {
    /* ... */
    zval* zv_host;
    MAKE_STD_ZVAL(zv_host);
    ZVAL_STRING(zv_host, host, 1);
    MY_ZEND_CALL_METHOD_WRAPPER(global_user_conn_proxy, zv_retval, zv_host /*, ...*/);
    zval_ptr_dtor(&zv_host);
    /* ... */
  }
  /* ... */
}
]]>
</programlisting>
  <para>
   <emphasis role="bold"> ユーザースペースを呼び出す: 構造体を引数にする場合
   </emphasis>
  </para>
<programlisting>
<![CDATA[
/* my_mysqlnd_plugin.c */

MYSQLND_METHOD(my_conn_class, connect)(
  MYSQLND *conn, /* ...*/) {
  /* ... */
  if (global_user_conn_proxy) {
    /* ... */
    zval* zv_conn;
    ZEND_REGISTER_RESOURCE(zv_conn, (void *)conn, le_mysqlnd_plugin_conn);
    MY_ZEND_CALL_METHOD_WRAPPER(global_user_conn_proxy, zv_retval, zv_conn, zv_host /*, ...*/);
    zval_ptr_dtor(&zv_conn);
    /* ... */
  }
  /* ... */
}
]]>
</programlisting>
  <para>
   多くの <literal>mysqlnd</literal> のメソッドがはじめに引数としてとるのが C の "object" です。たとえば、 connect() メソッドのはじめの引数は <literal>MYSQLND</literal>構造体 へのポインタです。MYSQNND構造体 は、<literal>mysqlnd</literal> 接続オブジェクトを表現します。
  </para>
  <para>
   <literal>mysqlnd</literal>接続オブジェクトへのポインタは、標準のI/Oファイルハンドルと比較できます。標準の I/Oファイルハンドルのように <literal>mysqlnd</literal>接続オブジェクトは PHP のリソース変数タイプを使ってユーザースペースに結びついていなければならないのです。
  </para>
  <para>
   <emphasis role="bold">C言語とユーザースペースを行き来する</emphasis>
  </para>
<programlisting>
<![CDATA[
 class proxy extends mysqlnd_plugin_connection {
  public function connect($conn, $host, ...) {
    /* "pre" hook */
    printf("Connecting to host = '%s'\n", $host);
    debug_print_backtrace();
    return parent::connect($conn);
  }

  public function query($conn, $query) {
    /* "post" hook */
    $ret = parent::query($conn, $query);
    printf("Query = '%s'\n", $query);
    return $ret;
  }
}
mysqlnd_plugin_set_conn_proxy(new proxy());
]]>
</programlisting>
  <para>
   PHP ユーザーは、オーバーライドしたメソッドの親の実装を呼び出し可能にしなければいけません。
  </para>
  <para>
   サブクラス化することで、ユーザーが選択したメソッドだけを改善し、"pre" や "post" フックを持たせるかどうかを選択できます。
  </para>
  <para>
   <emphasis role="bold"> ビルトインのクラス:
   mysqlnd_plugin_connection::connect() </emphasis>
  </para>
<programlisting>
<![CDATA[
/*  my_mysqlnd_plugin_classes.c */

 PHP_METHOD("mysqlnd_plugin_connection", connect) {
  /* ... simplified! ... */
  zval* mysqlnd_rsrc;
  MYSQLND* conn;
  char* host; int host_len;
  if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rs",
    &mysqlnd_rsrc, &host, &host_len) == FAILURE) {
    RETURN_NULL();
  }
  ZEND_FETCH_RESOURCE(conn, MYSQLND* conn, &mysqlnd_rsrc, -1,
    "Mysqlnd Connection", le_mysqlnd_plugin_conn);
  if (PASS == org_methods.connect(conn, host, /* simplified! */ TSRMLS_CC))
    RETVAL_TRUE;
  else
    RETVAL_FALSE;
}
]]>
</programlisting>
 </section>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
