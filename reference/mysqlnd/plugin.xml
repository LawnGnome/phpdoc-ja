<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 328620 $ -->
<chapter xml:id="mysqlnd.plugin" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>MySQL Native Driver プラグインAPI</title>
 <para>
  The MySQL Native Driver プラグインAPI は MySQL Native Driver、略して <literal>mysqlnd</literal> が持つ機能の一つです。<literal>mysqlnd</literal> プラグインは、PHPアプリケーションと MySQL サーバの間にあるレイヤで動きます。これは MySQL Proxy と比較できます。MySQL Proxy はあらゆる MySQL クライアントアプリケーション、たとえば PHPアプリケーション と MySQL サーバの間のレイヤで動きます。<literal>mysqlnd</literal> プラグインは典型的な MySQL Proxy のタスク、たとえばロードバランシングやモニタリング、パフォーマンスの最適化をこなせます。アーキテクチャや置かれる場所が異なるため、<literal>mysqlnd</literal> プラグインは MySQL Proxy が持ついくつかの欠点がありません。たとえば、プラグインを使えば、単一障害点が存在しませんし、専用のプロキシサーバをデプロイする必要もありませんし、新しいプログラミング言語(Lua) を学ぶ必要もありません。
 </para>
 <para>
  <literal>mysqlnd</literal>プラグインは <literal>mysqlnd</literal>の拡張と考えることが出来ます。プラグインは 多くの <literal>mysqlnd</literal> 関数の制御を奪い取ることができます。<literal>mysqlnd</literal> 関数は <literal>ext/mysql</literal> や <literal>ext/mysqli</literal>、<literal>PDO_MYSQL</literal> のような PHP の MySQLエクステンションによって呼び出されます。その結果として、<literal>mysqlnd</literal>プラグイン はクライアントアプリケーションからこれらのエクステンションへの呼び出しの制御をすべて奪うことが出きるのです。
 </para>
 <para>
  内部的な <literal>mysqlnd</literal> 関数の呼び出しも制御を奪ったり、処理を置き換えたりすることができます。<literal>mysqlnd</literal> の内部的な関数テーブルを管理することに関しても全く制限がありません。ある <literal>mysqlnd</literal> 関数が <literal>mysqlnd</literal> を使うエクステンションによって呼び出される場合に、適切な <literal>mysqlnd</literal>プラグインの適切な関数に処理を転送するようにセットアップすることが可能です。このように、<literal>mysqlnd</literal> の内部関数テーブルを管理できることで、プラグインの柔軟性が最大限に発揮できるのです。
 </para>
 <para>
  <literal>mysqlnd</literal>プラグインは、実際は <literal>mysqlnd</literal> のプラグインAPI (これは MySQL Native Driver, 略して <literal>mysqlnd</literal> に組み込まれています) を使い、C言語 で書かれた PHPエクステンション です。 プラグインは PHPアプリケーションに対して 100% 透過的です。つまり、プラグインがPHPアプリケーションとは異なるレイヤで動作するため、アプリケーションを変更する必要がないのです。<literal>mysqlnd</literal>プラグイン は、<literal>mysqlnd</literal> のひとつ下のレイヤで動くと考えることが出来ます。
 </para>
 <para>
  <literal>mysqlnd</literal>プラグインで実現可能なアプリケーションのリストをいくつか以下に示します
 </para>
 <itemizedlist>
  <listitem>
   <para>
    ロードバランシング
   </para>
   <itemizedlist>
    <listitem>
     <para>
      読み取り/書き込み の分割。例として、PECL/mysqlnd_ms (Master Slave) が挙げられます。この エクステンション は 読み取り/書き込み のクエリをレプリケーションのセットアップ向けに分割します。
     </para>
    </listitem>
    <listitem>
     <para>
      フェイルオーバー
     </para>
    </listitem>
    <listitem>
     <para>
      ラウンドロビン, 負荷が一番低いサーバへの転送
     </para>
    </listitem>
   </itemizedlist>
  </listitem>
  <listitem>
   <para>
    サーバの監視
   </para>
   <itemizedlist>
    <listitem>
     <para>
      クエリのロギング
     </para>
    </listitem>
    <listitem>
     <para>
      クエリの分析
     </para>
    </listitem>
    <listitem>
     <para>
      クエリの監査。例として、PECL/mysqlnd_sip (SQL Injection Protection) が挙げられます。この エクステンション はクエリを調べ、ルールセットに従って許可されたクエリのみを実行します。
     </para>
    </listitem>
   </itemizedlist>
  </listitem>
  <listitem>
   <para>
    パフォーマンスの向上
   </para>
   <itemizedlist>
    <listitem>
     <para>
      キャッシュ。例として、PECL/mysqlnd_qc (Query Cache) が挙げられます。
     </para>
    </listitem>
    <listitem>
     <para>
      トラフィックの調整
     </para>
    </listitem>
    <listitem>
     <para>
      シャーディング。例として、PECL/mysqlnd_mc (Multi Connect) が挙げられます。このエクステンション は、SELECT ステートメントを SELECT ... LIMIT part1, SELECT LIMIT part_n という形でn個に分割します。そしてクエリを別々の MySQLサーバに送り、結果をクライアント側でマージします。
     </para>
    </listitem>
   </itemizedlist>
  </listitem>
 </itemizedlist>
 <para>
  <emphasis role="bold">利用可能な MySQL Native Driverプラグイン</emphasis>
 </para>
 <para>
  既にたくさんの mysqlnd プラグインが利用可能になっています。以下が含まれます。
 </para>
 <itemizedlist>
  <listitem>
   <para>
    <emphasis role="bold">PECL/mysqlnd_mc</emphasis> - 複数接続ができるプラグイン
   </para>
  </listitem>
  <listitem>
   <para>
    <emphasis role="bold">PECL/mysqlnd_ms</emphasis> - マスタースレーブ構成用のプラグイン
   </para>
  </listitem>
  <listitem>
   <para>
    <emphasis role="bold">PECL/mysqlnd_qc</emphasis> - クエリキャッシュプラグイン
   </para>
  </listitem>
  <listitem>
   <para>
    <emphasis role="bold">PECL/mysqlnd_pscache</emphasis> - プリペアドステートメントハンドルをキャッシュするプラグイン
   </para>
  </listitem>
  <listitem>
   <para>
    <emphasis role="bold">PECL/mysqlnd_sip</emphasis> - SQLインジェクションから防御するためのプラグイン
   </para>
  </listitem>
  <listitem>
   <para>
    <emphasis role="bold">PECL/mysqlnd_uh</emphasis> - ユーザーハンドラープラグイン
   </para>
  </listitem>
 </itemizedlist>
 <section xml:id="mysqlnd.plugin.mysql-proxy">
  <title>mysqlndプラグイン と MySQL Proxyの比較</title>
  <para>
   <literal>mysqlnd</literal>プラグインと MySQL Proxyは、異なるアプローチを用いた異なる技術です。どちらもロードバランシングや監視、パフォーマンスの向上のような共通の様々な課題を解決するのに適したツールです。重要な違いは、MySQL Proxyがあらゆる MySQLクライアント と協調して動作するのに対して、<literal>mysqlnd</literal>プラグインは PHPアプリケーション との協調動作に特化しているということです。
  </para>
  <para>
   PHPエクステンションとして、<literal>mysqlnd</literal>プラグイン はPHPの残りの部分とともに、PHPのアプリケーションサーバにインストールされます。MySQL Proxy はPHPアプリケーションサーバ上でも動作しますし、複数のPHPアプリケーションサーバを扱う専用マシンにもインストール出来ます。
  </para>
  <para>
   MySQL Proxyをアプリケーションサーバにデプロイすることにはふたつの利点があります:
  </para>
  <orderedlist>
   <listitem>
    <para>
     単一障害点がない
    </para>
   </listitem>
   <listitem>
    <para>
     スケールアウトしやすい (水平方向へのスケールアウト、クライアントによるスケーリング)
    </para>
   </listitem>
  </orderedlist>
  <para>
   MySQL Proxy (と、<literal>mysqlnd</literal>プラグイン) は、他のやり方だと既存のアプリケーションを変更しなければならない問題にも容易に対処することができます。
  </para>
  <para>
   しかし、MySQL Proxyにはいくつか欠点があります:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     MySQL Proxy のコンポーネントと技術について新たにマスターし、デプロイしなければなりません。
    </para>
   </listitem>
   <listitem>
    <para>
     MySQL Proxy は Lua スクリプト言語の知識が必要です。
    </para>
   </listitem>
  </itemizedlist>
  <para>
   MySQL Proxy は C言語と プログラミング言語 Lua によってカスタマイズ出来ます。Lua は MySQL Proxy において好ましいスクリプト言語です。ほとんどのPHPエキスパートにとって、Lua は新しく学ばなければならない言語です。<literal>mysqlnd</literal>プラグインは C言語で書くことができます。<link xlink:href="http://pecl.php.net/package/mysqlnd_uh">PECL/mysqlnd_uh</link> を使って、プラグインを PHP で書くこともできます。
  </para>
  <para>
   MySQL Proxy はデーモン - バックグラウンドのプロセスとして動作します。MySQL Proxy は初期の決定を取り消すことも出来ますが、すべての状態を保持することできます。しかしながら <literal>mysqlnd</literal>プラグインは、PHPのリクエスト単位のライフサイクルに結びついています。MySQL Proxy は一度計算された結果を複数のアプリケーションサーバで共有出来ます。<literal>mysqlnd</literal>プラグインでこれを行うには、永続的なストレージにデータを保存する必要があります。この目的のためには Memcache のような別のデーモンが必要です。この場合は、MySQL Proxy に有利です。
  </para>
  <para>
   MySQL Proxy は wire protocol (訳注：ネットワークを通じてデータを転送するプロトコル。<link xlink:href="http://en.wikipedia.org/wiki/Wire_protocol">WikipediaでのWire Protocolの説明</link>, <link xlink:href="http://stackoverflow.com/questions/2324089/can-someone-explain-what-a-wire-level-protocol-is">StackOverflow でのWire Protocolの説明</link>) の上で動作します。MySQL Proxy を使うと、MySQLクライアントサーバプロトコルを解析し、リバースエンジニアリングしなければなりません。MySQL Proxy できることは、通信プロトコルを管理することで達成できることに限られます。wire protocol が変更(滅多にありませんが)されると、MySQL Proxy のスクリプトも変更する必要があります。
  </para>
  <para>
   <literal>mysqlnd</literal>プラグインは C言語のAPI上で動作します。このAPIは <literal>libmysql</literal>クライアント と Connector/C API の動きをそのままコピーしています。この C言語のAPI は、 基本的に MySQLクライアントサーバプロトコル、時に wire protocol と呼ばれるもののラッパーです。開発者は C言語のAPI呼び出しの制御を奪うことができます。それゆえに、wire protocol レベルのプログラムに一切変更を加えることなく、すべてのPHP呼び出しをフックできるのです。
  </para>
  <para>
   <literal>mysqlnd</literal> は wire protocol を実装しています。そのため、プラグインは通信プロトコルを解析し、リバースエンジニアリングし、管理できるばかりか、通信プロトコルを置き換えることだってできます。ただ、こんなことをする必要は通常ありません。
  </para>
  <para>
   プラグインが 2つのレベル(C言語のAPI と wire protocol) を使って実装できるので、MySQL Proxy よりも大きな柔軟性を得られます。 <literal>mysqlnd</literal>プラグインが C言語のAPI を使って実装されれば、wire protocol に対していかなる変更が行われても、プラグインへの変更は必要ありません。
  </para>
 </section>
 <section xml:id="mysqlnd.plugin.obtaining">
  <title>mysqlnd plugin APIを取得する</title>
  <para>
   <literal>mysqlnd</literal>プラグインAPI は、MySQL Native Driver PHPエクステンションである <literal>ext/mysqlnd</literal> の一部です。2009年12月に <literal>mysqlnd</literal>プラグインAPI の開発がスタートしました。これは PHP のソースリポジトリの一分として開発が進められ、git経由で公開されたり、ソースコードのスナップショットがダウンロード可能になっています。
  </para>
  <para>
   次の表は、PHPのバージョンとそれに含まれている <literal>mysqlnd</literal> の対応バージョンを示しています。
  </para>
  <table>
   <title>PHPのリリースにバンドルされた mysqlnd のバージョン</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>PHP のバージョン</entry>
      <entry>MySQL Native Driver のバージョン</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>5.3.0</entry>
      <entry>5.0.5</entry>
     </row>
     <row>
      <entry>5.3.1</entry>
      <entry>5.0.5</entry>
     </row>
     <row>
      <entry>5.3.2</entry>
      <entry>5.0.7</entry>
     </row>
     <row>
      <entry>5.3.3</entry>
      <entry>5.0.7</entry>
     </row>
     <row>
      <entry>5.3.4</entry>
      <entry>5.0.7</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   プラグインの開発者は <literal>mysqlnd</literal> のバージョンを <literal>MYSQLND_VERSION</literal> にアクセスすることで決めることができます。この値は、<quote>mysqlnd 5.0.7-dev - 091210 - $Revision: 300535</quote> という文字列フォーマットです。または、<literal>MYSQLND_VERSION_ID</literal> という値にもアクセスできます。これはたとえば、50007 のような数値です。 開発者は次のようにしてバージョン番号を計算することが出来ます:
  </para>
  <table>
   <title>MYSQLND_VERSION_ID 計算テーブル</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Version (一部)</entry>
      <entry>例</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>Major*10000</entry>
      <entry>5*10000 = 50000</entry>
     </row>
     <row>
      <entry>Minor*100</entry>
      <entry>0*100 = 0</entry>
     </row>
     <row>
      <entry>Patch</entry>
      <entry>7 = 7</entry>
     </row>
     <row>
      <entry>MYSQLND_VERSION_ID</entry>
      <entry>50007</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   開発している間は、開発者は <literal>mysqlnd</literal> のバージョン番号を互換性と対応バージョンのテストとして参照すべきです。PHP本体のひとつのバージョンにおける開発のライフサイクルの間に、<literal>mysqlnd</literal> の開発イテレーションは複数行われる場合があるためです。
  </para>
 </section>
 <section xml:id="mysqlnd.plugin.architecture">
  <title>MySQL Native Driverプラグイン のアーキテクチャ</title>
  <para>
   このセクションでは、<literal>mysqlnd</literal>プラグイン のアーキテクチャについての概要を示します。
  </para>
  <para>
   <emphasis role="bold"> MySQL Native Driver の概要</emphasis>
  </para>
  <para>
   <literal>mysqlnd</literal>プラグイン を開発する前に、<literal>mysqlnd</literal> そのものがどのように成り立っているのかを少し知っておくことは役に立ちます。<literal>mysqlnd</literal> は次に示すモジュールからなります:
  </para>
  <table>
   <title>mysqlnd のモジュール毎のソースコードの組み合わせを示した表</title>
   <tgroup cols="2">
    <tbody>
     <row>
      <entry>モジュールの統計情報</entry>
      <entry>mysqlnd_statistics.c</entry>
     </row>
     <row>
      <entry>データベース接続</entry>
      <entry>mysqlnd.c</entry>
     </row>
     <row>
      <entry>結果セット</entry>
      <entry>mysqlnd_result.c</entry>
     </row>
     <row>
      <entry>結果セットのメタデータ</entry>
      <entry>mysqlnd_result_meta.c</entry>
     </row>
     <row>
      <entry>プリペアドステートメント</entry>
      <entry>mysqlnd_ps.c</entry>
     </row>
     <row>
      <entry>ネットワーク</entry>
      <entry>mysqlnd_net.c</entry>
     </row>
     <row>
      <entry>Wire protocol</entry>
      <entry>mysqlnd_wireprotocol.c</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   <emphasis role="bold">C言語のオブジェクト指向パラダイム</emphasis>
  </para>
  <para>
   ソースコードレベルで、<literal>mysqlnd</literal> は オブジェクト指向を実装するためのパターンを使用しています。
  </para>
  <para>
   C言語では、オブジェクトを表現するために <literal>struct</literal>(構造体) を使います。struct のメンバがオブジェクトのプロパティを表現します。関数を指している struct のメンバがメソッドを表現します。
  </para>
  <para>
   C++ や Java のような言語と異なり、C言語におけるオブジェクト指向のパラダイムでは決まった継承のルールがありませんが、従う必要があるルールはいくつかあります。このルールについては後に述べます。
  </para>
  <para>
   <emphasis role="bold">PHP のライフサイクル</emphasis>
  </para>
  <para>
   PHP のライフサイクルを考えるとき、ふたつの基本的なサイクルが存在します。
  </para>
  <itemizedlist>
   <listitem>
    <para>
     PHPエンジンの起動と終了までのサイクル
    </para>
   </listitem>
   <listitem>
    <para>
     リクエストサイクル
    </para>
   </listitem>
  </itemizedlist>
  <para>
   PHPエンジンが起動するとき、PHP はモジュールを初期化する (MINIT) 関数を登録されたエクステンションごとに呼び出します。これによって、各々のモジュールが PHPエンジンが処理を行うライフサイクルの間存在するリソースを割り当てたり、変数を定義することができます。PHPエンジンが終了するときには、 エンジンが終了(MSHUTDOWN)関数をエクステンション毎に呼び出します。
  </para>
  <para>
   PHPエンジンが起動している間、エンジンはたくさんのリクエストを受けとります。それぞれのリクエストは別のライフサイクルを構成します。リクエスト毎にPHPエンジンはリクエストの初期化関数をエクステンション毎に呼び出します。エクステンション側では、リクエストの処理に必要な変数の定義やリソースの割り当てを行うことが出来ます。リクエストのサイクルが終了するときは、PHPエンジンがリクエストの終了(RSHUTDOWN)関数をエクステンション毎に呼び出します。これによって、エクステンションは必要となるあらゆるクリーンアップ処理を行うことができます。
  </para>
  <para>
   <emphasis role="bold">プラグインはどうやって動くか</emphasis>
  </para>
  <para>
   <literal>mysqlnd</literal>プラグイン は <literal>mysqlnd</literal> を使うエクステンションが <literal>mysqlnd</literal> を呼び出すときの制御を奪うことによって動作します。これは <literal>mysqlnd</literal> の関数テーブルを取得し、バックアップし、カスタムの関数テーブルと置き換えることによって実現されます。この関数テーブルが、プラグインが必要とする関数を呼び出すのです。
  </para>
  <para>
   次のコードは、<literal>mysqlnd</literal> の関数テーブルを置き換える方法を示しています:
  </para>
<programlisting>
<![CDATA[
/* a place to store original function table */
struct st_mysqlnd_conn_methods org_methods;

void minit_register_hooks(TSRMLS_D) {
  /* active function table */
  struct st_mysqlnd_conn_methods * current_methods
    = mysqlnd_conn_get_methods();

  /* backup original function table */
  memcpy(&org_methods, current_methods,
    sizeof(struct st_mysqlnd_conn_methods);

  /* install new methods */
  current_methods->query = MYSQLND_METHOD(my_conn_class, query);
}
]]>
</programlisting>
  <para>
   接続関数テーブルの管理は、モジュールを初期化(MINIT)している間に行わなければなりません。関数テーブルはグローバルに共有されるリソースです。マルチスレッド環境で、TSRMを友好にしてPHPをビルドした環境では、グローバルに共有されたリソースをリクエストを処理している間に操作すると、ほぼ確実に衝突が起こります。
  </para>
  <note>
   <para>
    <literal>mysqlnd</literal> の関数テーブルを管理するときに、固定サイズを割り当てるロジックは絶対に使わないでください。新しいメソッドが関数テーブルの最後に追加される可能性があるからです。関数テーブルは将来どんな場合でも変更される可能性があります。
   </para>
  </note>
  <para>
   <emphasis role="bold">親クラスのメソッドを呼び出す</emphasis>
  </para>
  <para>
   オリジナルの関数テーブルをバックアップしている場合、オリジナルの関数テーブルのエントリに含まれる関数を呼び出すことができます - これが親メソッドです。
  </para>
  <para>
   場合によっては、<literal>Connection::stmt_init()</literal> のように、派生メソッドで他のあらゆる処理より先に親メソッドを呼び出すことが決定的に重要な場合があります。
  </para>
<programlisting>
<![CDATA[
MYSQLND_METHOD(my_conn_class, query)(MYSQLND *conn,
  const char *query, unsigned int query_len TSRMLS_DC) {

  php_printf("my_conn_class::query(query = %s)\n", query);

  query = "SELECT 'query rewritten' FROM DUAL";
  query_len = strlen(query);

  return org_methods.query(conn, query, query_len); /* return with call to parent */
}
]]>
</programlisting>
  <para>
   <emphasis role="bold">プロパティを拡張する</emphasis>
  </para>
  <para>
   <literal>mysqlnd</literal>オブジェクトは C言語の構造体で表現されます。実行時に、C言語の構造体に新たにメンバを追加することは不可能です。<literal>mysqlnd</literal>オブジェクト のユーザーは、プロパティを単純にオブジェクトに追加することはできません。
  </para>
  <para>
   <literal>mysqlnd_plugin_get_plugin_&lt;object&gt;_data()</literal>ファミリーの適切な関数を使って、任意のデータ (プロパティ) を <literal>mysqlnd</literal> オブジェクトに追加することができます。オブジェクトをメモリに割り付ける際に、<literal>mysqlnd</literal> はオブジェクトの最後に 任意のデータ向けの <literal>void *</literal> ポインタを保持するためのメモリ空間を予約しておきます。 <literal>mysqlnd</literal> は プラグインひとつにつき、ひとつの <literal>void *</literal>ポインタ を保持する空間を予約しています。
  </para>
  <para>
   次の表で、特定のプラグインでポインタの位置を計算する方法を示します:
  </para>
  <table>
   <title>mysqlnd のポインタの位置を計算する方法</title>
   <tgroup cols="2">
    <tbody>
     <row>
      <entry>メモリアドレス</entry>
      <entry>メモリの内容</entry>
     </row>
     <row>
      <entry>0</entry>
      <entry>mysqlndオブジェクト を表現する構造体の開始</entry>
     </row>
     <row>
      <entry>n</entry>
      <entry>mysqlndオブジェクト を表現する構造体の終了</entry>
     </row>
     <row>
      <entry>n + (m x sizeof(void*))</entry>
      <entry>m 番目のプラグインのオブジェクトデータを表現する void* ポインタ</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   <literal>mysqlnd</literal>オブジェクト のコンストラクタをサブクラス化する計画がある場合、それが許可されていることを必ず頭にいれておいてください！
  </para>
  <para>
   次のコードはプロパティを拡張する方法を示しています:
  </para>
<programlisting>
<![CDATA[
/* any data we want to associate */
typedef struct my_conn_properties {
  unsigned long query_counter;
} MY_CONN_PROPERTIES;

/* plugin id */
unsigned int my_plugin_id;

void minit_register_hooks(TSRMLS_D) {
  /* obtain unique plugin ID */
  my_plugin_id = mysqlnd_plugin_register();
  /* snip - see Extending Connection: methods */
}

static MY_CONN_PROPERTIES** get_conn_properties(const MYSQLND *conn TSRMLS_DC) {
  MY_CONN_PROPERTIES** props;
  props = (MY_CONN_PROPERTIES**)mysqlnd_plugin_get_plugin_connection_data(
    conn, my_plugin_id);
  if (!props || !(*props)) {
    *props = mnd_pecalloc(1, sizeof(MY_CONN_PROPERTIES), conn->persistent);
    (*props)->query_counter = 0;
  }
  return props;
}
]]>
</programlisting>
  <para>
   プラグインの開発者には、プラグイン用のデータに使われるメモリを管理する責任があります。
  </para>
  <para>
   <literal>mysqlnd</literal> のメモリアロケータを使うことを推奨します。これらのメモリアロケータ関数は次のような規約に従って命名されています: <literal>mnd_*loc()</literal> <literal>mysqlnd</literal> のメモリアロケーターには役に立つ機能がいくつかあります。たとえばデバッグビルドでない環境でデバッグ用のアロケータを使う機能などです。
  </para>
  <table>
   <title>いつ、どのようにサブクラス化するか</title>
   <tgroup cols="4">
    <tbody>
     <row>
      <entry></entry>
      <entry>いつサブクラス化するか?</entry>
      <entry>各々のインスタンスが自分のプライベートな関数テーブルを持っているか?</entry>
      <entry>どのようにサブクラス化するか?</entry>
     </row>
     <row>
      <entry>Connection (MYSQLND)</entry>
      <entry>MINIT</entry>
      <entry>No</entry>
      <entry>mysqlnd_conn_get_methods()</entry>
     </row>
     <row>
      <entry>Resultset (MYSQLND_RES)</entry>
      <entry>MINIT (モジュール初期化) 時 またはその後</entry>
      <entry>Yes</entry>
      <entry>mysqlnd_result_get_methods() または、オブジェクトのメソッド関数テーブルを変更する</entry>
     </row>
     <row>
      <entry>Resultset Meta (MYSQLND_RES_METADATA)</entry>
      <entry>MINIT (モジュール初期化) 時</entry>
      <entry>No</entry>
      <entry>mysqlnd_result_metadata_get_methods()</entry>
     </row>
     <row>
      <entry>Statement (MYSQLND_STMT)</entry>
      <entry>MINIT (モジュール初期化) 時</entry>
      <entry>No</entry>
      <entry>mysqlnd_stmt_get_methods()</entry>
     </row>
     <row>
      <entry>Network (MYSQLND_NET)</entry>
      <entry>MINIT (モジュール初期化) 時 またはその後</entry>
      <entry>Yes</entry>
      <entry>mysqlnd_net_get_methods() または、オブジェクトのメソッド関数テーブルを変更する</entry>
     </row>
     <row>
      <entry>Wire protocol (MYSQLND_PROTOCOL)</entry>
      <entry>MINIT (モジュール初期化) 時 またはその後</entry>
      <entry>Yes</entry>
      <entry>mysqlnd_protocol_get_methods() または、オブジェクトのメソッド関数テーブルを変更する</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   上記の表で許可されていない場合は、モジュールを初期化した(MINIT)後のいかなる場合であっても関数テーブルを変更してはいけません。
  </para>
  <para>
   クラスによっては、メソッドの関数テーブルへのポインタが含まれている場合があります。このようなクラスのインスタンスはすべて、同じ関数テーブルを共有しています。混乱を避けるため、特にマルチスレッドの環境下では、このような関数テーブルは MINIT (モジュール初期化) 時にだけ変更するようにしてください。
  </para>
  <para>
   そうでないクラスでは、グローバルに共有された関数テーブルのコピーを使っています。クラスの関数テーブルのコピーがオブジェクトとともに作成されます。それぞれのオブジェクトは自分の関数テーブルを使います。これによって開発者は二つの選択肢が得られます: MINIT(モジュール初期化) 時にオブジェクトのデフォルトの関数テーブルを変更するか、同じクラスの他のインスタンスに影響を与えることなくオブジェクトのメソッドを追加で変更することができます。
  </para>
  <para>
   関数テーブルを共有することによる利点は、パフォーマンスの向上です。関数テーブルをそれぞれの、すべてのオブジェクトにコピーする必要がないからです。
  </para>
  <table>
   <title>コンストラクタの状態</title>
   <tgroup cols="4">
    <tbody>
     <row>
      <entry></entry>
      <entry>メモリ割り当て、オブジェクトの生成、リセット</entry>
      <entry>変更可能か?</entry>
      <entry>呼び出し元</entry>
     </row>
     <row>
      <entry>Connection (MYSQLND)</entry>
      <entry>mysqlnd_init()</entry>
      <entry>No</entry>
      <entry>mysqlnd_connect()</entry>
     </row>
     <row>
      <entry>Resultset(MYSQLND_RES)</entry>
      <entry><para>
        メモリ割り当て:
       </para>
       <itemizedlist>
        <listitem>
         <para>
          Connection::result_init()
         </para>
        </listitem>
       </itemizedlist>
       <para>
        リセットし、再初期化されるタイミング:
       </para>
       <itemizedlist>
        <listitem>
         <para>
          Result::use_result()
         </para>
        </listitem>
        <listitem>
         <para>
          Result::store_result
         </para>
        </listitem>
       </itemizedlist></entry>
      <entry>Yes, ただし親メソッドを呼び出すこと！</entry>
      <entry><itemizedlist>
        <listitem>
         <para>
          Connection::list_fields()
         </para>
        </listitem>
        <listitem>
         <para>
          Statement::get_result()
         </para>
        </listitem>
        <listitem>
         <para>
          Statement::prepare() (メタデータのみ)
         </para>
        </listitem>
        <listitem>
         <para>
          Statement::resultMetaData()
         </para>
        </listitem>
       </itemizedlist></entry>
     </row>
     <row>
      <entry>Resultset Meta (MYSQLND_RES_METADATA)</entry>
      <entry>Connection::result_meta_init()</entry>
      <entry>Yes, ただし親メソッドを呼び出すこと！</entry>
      <entry>Result::read_result_metadata()</entry>
     </row>
     <row>
      <entry>Statement (MYSQLND_STMT)</entry>
      <entry>Connection::stmt_init()</entry>
      <entry>Yes, ただし親メソッドを呼び出すこと！</entry>
      <entry>Connection::stmt_init()</entry>
     </row>
     <row>
      <entry>Network (MYSQLND_NET)</entry>
      <entry>mysqlnd_net_init()</entry>
      <entry>No</entry>
      <entry>Connection::init()</entry>
     </row>
     <row>
      <entry>Wire protocol (MYSQLND_PROTOCOL)</entry>
      <entry>mysqlnd_protocol_init()</entry>
      <entry>No</entry>
      <entry>Connection::init()</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   It is strongly recommended that you do not entirely replace a
   constructor. The constructors perform memory allocations. The memory
   allocations are vital for the <literal>mysqlnd</literal> plugin API
   and the object logic of <literal>mysqlnd</literal>. If you do not
   care about warnings and insist on hooking the constructors, you
   should at least call the parent constructor before doing anything in
   your constructor.
  </para>
  <para>
   Regardless of all warnings, it can be useful to subclass
   constructors. Constructors are the perfect place for modifying the
   function tables of objects with non-shared object tables, such as
   Resultset, Network, Wire Protocol.
  </para>
  <table>
   <title>Destruction status</title>
   <tgroup cols="3">
    <tbody>
     <row>
      <entry></entry>
      <entry>Derived method must call parent?</entry>
      <entry>Destructor</entry>
     </row>
     <row>
      <entry>Connection</entry>
      <entry>yes, after method execution</entry>
      <entry>free_contents(), end_psession()</entry>
     </row>
     <row>
      <entry>Resultset</entry>
      <entry>yes, after method execution</entry>
      <entry>free_result()</entry>
     </row>
     <row>
      <entry>Resultset Meta</entry>
      <entry>yes, after method execution</entry>
      <entry>free()</entry>
     </row>
     <row>
      <entry>Statement</entry>
      <entry>yes, after method execution</entry>
      <entry>dtor(), free_stmt_content()</entry>
     </row>
     <row>
      <entry>Network</entry>
      <entry>yes, after method execution</entry>
      <entry>free()</entry>
     </row>
     <row>
      <entry>Wire protocol</entry>
      <entry>yes, after method execution</entry>
      <entry>free()</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   The destructors are the appropriate place to free properties,
   <literal>mysqlnd_plugin_get_plugin_<replaceable>&lt;object&gt;</replaceable>_data()</literal>.
  </para>
  <para>
   The listed destructors may not be equivalent to the actual
   <literal>mysqlnd</literal> method freeing the object itself. However,
   they are the best possible place for you to hook in and free your
   plugin data. As with constructors you may replace the methods
   entirely but this is not recommended. If multiple methods are listed
   in the above table you will need to hook all of the listed methods
   and free your plugin data in whichever method is called first by
   <literal>mysqlnd</literal>.
  </para>
  <para>
   The recommended method for plugins is to simply hook the methods,
   free your memory and call the parent implementation immediately
   following this.
  </para>
  <caution>
   <para>
    Due to a bug in PHP versions 5.3.0 to 5.3.3, plugins do not
    associate plugin data with a persistent connection. This is because
    <literal>ext/mysql</literal> and <literal>ext/mysqli</literal> do
    not trigger all the necessary <literal>mysqlnd</literal>
    <literal>end_psession()</literal> method calls and the plugin may
    therefore leak memory. This has been fixed in PHP 5.3.4.
   </para>
  </caution>
 </section>
 <section xml:id="mysqlnd.plugin.api">
  <title>mysqlnd のプラグインAPI</title>
  <para>
   The following is a list of functions provided in the
   <literal>mysqlnd</literal> plugin API:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     mysqlnd_plugin_register()
    </para>
   </listitem>
   <listitem>
    <para>
     mysqlnd_plugin_count()
    </para>
   </listitem>
   <listitem>
    <para>
     mysqlnd_plugin_get_plugin_connection_data()
    </para>
   </listitem>
   <listitem>
    <para>
     mysqlnd_plugin_get_plugin_result_data()
    </para>
   </listitem>
   <listitem>
    <para>
     mysqlnd_plugin_get_plugin_stmt_data()
    </para>
   </listitem>
   <listitem>
    <para>
     mysqlnd_plugin_get_plugin_net_data()
    </para>
   </listitem>
   <listitem>
    <para>
     mysqlnd_plugin_get_plugin_protocol_data()
    </para>
   </listitem>
   <listitem>
    <para>
     mysqlnd_conn_get_methods()
    </para>
   </listitem>
   <listitem>
    <para>
     mysqlnd_result_get_methods()
    </para>
   </listitem>
   <listitem>
    <para>
     mysqlnd_result_meta_get_methods()
    </para>
   </listitem>
   <listitem>
    <para>
     mysqlnd_stmt_get_methods()
    </para>
   </listitem>
   <listitem>
    <para>
     mysqlnd_net_get_methods()
    </para>
   </listitem>
   <listitem>
    <para>
     mysqlnd_protocol_get_methods()
    </para>
   </listitem>
  </itemizedlist>
  <para>
   There is no formal definition of what a plugin is and how a plugin
   mechanism works.
  </para>
  <para>
   Components often found in plugins mechanisms are:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     A plugin manager
    </para>
   </listitem>
   <listitem>
    <para>
     A plugin API
    </para>
   </listitem>
   <listitem>
    <para>
     Application services (or modules)
    </para>
   </listitem>
   <listitem>
    <para>
     Application service APIs (or module APIs)
    </para>
   </listitem>
  </itemizedlist>
  <para>
   The <literal>mysqlnd</literal> plugin concept employs these features,
   and additionally enjoys an open architecture.
  </para>
  <para>
   <emphasis role="bold"> No Restrictions </emphasis>
  </para>
  <para>
   A plugin has full access to the inner workings of
   <literal>mysqlnd</literal>. There are no security limits or
   restrictions. Everything can be overwritten to implement friendly or
   hostile algorithms. It is recommended you only deploy plugins from a
   trusted source.
  </para>
  <para>
   As discussed previously, plugins can use pointers freely. These
   pointers are not restricted in any way, and can point into another
   plugin's data. Simple offset arithmetic can be used to read another
   plugin's data.
  </para>
  <para>
   It is recommended that you write cooperative plugins, and that you
   always call the parent method. The plugins should always cooperate
   with <literal>mysqlnd</literal> itself.
  </para>
  <table>
   <title>Issues: an example of chaining and cooperation</title>
   <tgroup cols="3">
    <tbody>
     <row>
      <entry>Extension</entry>
      <entry>mysqlnd.query() pointer</entry>
      <entry>call stack if calling parent</entry>
     </row>
     <row>
      <entry>ext/mysqlnd</entry>
      <entry>mysqlnd.query()</entry>
      <entry>mysqlnd.query</entry>
     </row>
     <row>
      <entry>ext/mysqlnd_cache</entry>
      <entry>mysqlnd_cache.query()</entry>
      <entry><orderedlist>
        <listitem>
         <para>
          mysqlnd_cache.query()
         </para>
        </listitem>
        <listitem>
         <para>
          mysqlnd.query
         </para>
        </listitem>
       </orderedlist></entry>
     </row>
     <row>
      <entry>ext/mysqlnd_monitor</entry>
      <entry>mysqlnd_monitor.query()</entry>
      <entry><orderedlist>
        <listitem>
         <para>
          mysqlnd_monitor.query()
         </para>
        </listitem>
        <listitem>
         <para>
          mysqlnd_cache.query()
         </para>
        </listitem>
        <listitem>
         <para>
          mysqlnd.query
         </para>
        </listitem>
       </orderedlist></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   In this scenario, a cache (<literal>ext/mysqlnd_cache</literal>) and
   a monitor (<literal>ext/mysqlnd_monitor</literal>) plugin are loaded.
   Both subclass <literal>Connection::query()</literal>. Plugin
   registration happens at <literal>MINIT</literal> using the logic
   shown previously. PHP calls extensions in alphabetical order by
   default. Plugins are not aware of each other and do not set extension
   dependencies.
  </para>
  <para>
   By default the plugins call the parent implementation of the query
   method in their derived version of the method.
  </para>
  <para>
   <emphasis role="bold"> PHP Extension Recap </emphasis>
  </para>
  <para>
   This is a recap of what happens when using an example plugin,
   <literal>ext/mysqlnd_plugin</literal>, which exposes the
   <literal>mysqlnd</literal> C plugin API to PHP:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     Any PHP MySQL application tries to establish a connection to
     192.168.2.29
    </para>
   </listitem>
   <listitem>
    <para>
     The PHP application will either use <literal>ext/mysql</literal>,
     <literal>ext/mysqli</literal> or <literal>PDO_MYSQL</literal>. All
     three PHP MySQL extensions use <literal>mysqlnd</literal> to
     establish the connection to 192.168.2.29.
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>Mysqlnd</literal> calls its connect method, which has been
     subclassed by <literal>ext/mysqlnd_plugin</literal>.
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>ext/mysqlnd_plugin</literal> calls the userspace hook
     <literal>proxy::connect()</literal> registered by the user.
    </para>
   </listitem>
   <listitem>
    <para>
     The userspace hook changes the connection host IP from 192.168.2.29
     to 127.0.0.1 and returns the connection established by
     <literal>parent::connect()</literal>.
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>ext/mysqlnd_plugin</literal> performs the equivalent of
     <literal>parent::connect(127.0.0.1)</literal> by calling the
     original <literal>mysqlnd</literal> method for establishing a
     connection.
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>ext/mysqlnd</literal> establishes a connection and returns
     to <literal>ext/mysqlnd_plugin</literal>.
     <literal>ext/mysqlnd_plugin</literal> returns as well.
    </para>
   </listitem>
   <listitem>
    <para>
     Whatever PHP MySQL extension had been used by the application, it
     receives a connection to 127.0.0.1. The PHP MySQL extension itself
     returns to the PHP application. The circle is closed.
    </para>
   </listitem>
  </itemizedlist>
 </section>
 <section xml:id="mysqlnd.plugin.developing">
  <title>mysqlndプラグインの開発をはじめよう</title>
  <para>
   <literal>mysqlnd</literal>プラグイン それ自体が PHPエクステンション であることを覚えておくことが重要です。
  </para>
  <para>
   次のコードは、典型的な <literal>mysqlnd</literal> プラグインで使われる MINIT 関数の基本構造を示します。
  </para>
<programlisting>
<![CDATA[
/* my_php_mysqlnd_plugin.c */

 static PHP_MINIT_FUNCTION(mysqlnd_plugin) {
  /* globals, ini entries, resources, classes */

  /* register mysqlnd plugin */
  mysqlnd_plugin_id = mysqlnd_plugin_register();

  conn_m = mysqlnd_get_conn_methods();
  memcpy(org_conn_m, conn_m,
    sizeof(struct st_mysqlnd_conn_methods));

  conn_m->query = MYSQLND_METHOD(mysqlnd_plugin_conn, query);
  conn_m->connect = MYSQLND_METHOD(mysqlnd_plugin_conn, connect);
}
]]>
</programlisting>
<programlisting>
<![CDATA[
/* my_mysqlnd_plugin.c */

 enum_func_status MYSQLND_METHOD(mysqlnd_plugin_conn, query)(/* ... */) {
  /* ... */
}
enum_func_status MYSQLND_METHOD(mysqlnd_plugin_conn, connect)(/* ... */) {
  /* ... */
}
]]>
</programlisting>
  <para>
   <emphasis role="bold">タスクの解析: C言語からユーザースペースへ</emphasis>
  </para>
<programlisting>
<![CDATA[
 class proxy extends mysqlnd_plugin_connection {
  public function connect($host, ...) { .. }
}
mysqlnd_plugin_set_conn_proxy(new proxy());
]]>
</programlisting>
  <para>
   プロセス:
  </para>
  <orderedlist>
   <listitem>
    <para>
     PHP: ユーザーがプラグインのコールバックを登録する
    </para>
   </listitem>
   <listitem>
    <para>
     PHP: ユーザーがMySQLに接続するため、任意の PHP MySQL API を呼び出す
    </para>
   </listitem>
   <listitem>
    <para>
     C: ext/*mysql* が mysqlnd のメソッドを呼び出す
    </para>
   </listitem>
   <listitem>
    <para>
     C: mysqlnd が ext/mysqlnd_plugin の中で終了する
    </para>
   </listitem>
   <listitem>
    <para>
     C: ext/mysqlnd_plugin
     <orderedlist>
      <listitem>
       <para>
        ユーザースペースで登録されたコールバックを呼び出す
       </para>
      </listitem>
      <listitem>
       <para>
        また、ユーザースペースのコールバックが登録されていない場合は、<literal>mysqlnd</literal> のメソッドを呼び出す。
       </para>
      </listitem>
     </orderedlist>
    </para>
   </listitem>
  </orderedlist>
  <para>
   次のことを実行する必要があります:
  </para>
  <orderedlist>
   <listitem>
    <para>
     "mysqlnd_plugin_connection" というクラスを C言語で書く
    </para>
   </listitem>
   <listitem>
    <para>
     "mysqlnd_plugin_set_conn_proxy()" 関数を使って、プロキシオブジェクトを受け入れ、登録する
    </para>
   </listitem>
   <listitem>
    <para>
     C言語から、ユーザースペースへのプロキシメソッドを呼び出す (最適化 - zend_interface.h)
    </para>
   </listitem>
  </orderedlist>
  <para>
   ユーザースペースのオブジェクトメソッドは、<literal>call_user_function()</literal> を使うか、<literal>zend_call_method()</literal> を使って Zend Engine に近いレベルで操作を行うことができます。
  </para>
  <para>
   <emphasis role="bold"> 最適化: C言語から zend_call_method を使ってメソッドを呼び出す</emphasis>
  </para>
  <para>
   次に示すコードの断片は、<literal>zend_call_method</literal> のプロトタイプを示しています。これは <filename>zend_interface.h</filename> からとってきたものです。
  </para>
<programlisting>
<![CDATA[
 ZEND_API zval* zend_call_method(
  zval **object_pp, zend_class_entry *obj_ce,
  zend_function **fn_proxy, char *function_name,
  int function_name_len, zval **retval_ptr_ptr,
  int param_count, zval* arg1, zval* arg2 TSRMLS_DC
);
]]>
</programlisting>
  <para>
   Zend API は2つの引数しかサポートしていません。それ以上必要な場合は、たとえば次のようにします。
  </para>
<programlisting>
<![CDATA[
 enum_func_status (*func_mysqlnd_conn__connect)(
  MYSQLND *conn, const char *host,
  const char * user, const char * passwd,
  unsigned int passwd_len, const char * db,
  unsigned int db_len, unsigned int port,
  const char * socket, unsigned int mysql_flags TSRMLS_DC
);
]]>
</programlisting>
  <para>
   この問題に対処するには、<literal>zend_call_method()</literal> のコピーを作り、追加の引数の入れ物を追加する必要があるでしょう。これは、<literal>MY_ZEND_CALL_METHOD_WRAPPER</literal> マクロの組を作ることで実現できます。
  </para>
  <para>
   <emphasis role="bold">PHP のユーザースペースを呼び出す</emphasis>
  </para>
  <para>
   以下のコードは、C言語からユーザースペースの関数を呼ぶための最適化されたやり方を示しています:
  </para>
<programlisting>
<![CDATA[ 
/* my_mysqlnd_plugin.c */

MYSQLND_METHOD(my_conn_class,connect)(
  MYSQLND *conn, const char *host /* ... */ TSRMLS_DC) {
  enum_func_status ret = FAIL;
  zval * global_user_conn_proxy = fetch_userspace_proxy();
  if (global_user_conn_proxy) {
    /* call userspace proxy */
    ret = MY_ZEND_CALL_METHOD_WRAPPER(global_user_conn_proxy, host, /*...*/);
  } else {
    /* or original mysqlnd method = do nothing, be transparent */
    ret = org_methods.connect(conn, host, user, passwd,
          passwd_len, db, db_len, port,
          socket, mysql_flags TSRMLS_CC);
  }
  return ret;
}
]]>
</programlisting>
  <para>
   <emphasis role="bold"> ユーザースペースを呼び出す: 引数が一つの場合
   </emphasis>
  </para>
<programlisting>
<![CDATA[
/* my_mysqlnd_plugin.c */

 MYSQLND_METHOD(my_conn_class,connect)(
  /* ... */, const char *host, /* ...*/) {
  /* ... */
  if (global_user_conn_proxy) {
    /* ... */
    zval* zv_host;
    MAKE_STD_ZVAL(zv_host);
    ZVAL_STRING(zv_host, host, 1);
    MY_ZEND_CALL_METHOD_WRAPPER(global_user_conn_proxy, zv_retval, zv_host /*, ...*/);
    zval_ptr_dtor(&zv_host);
    /* ... */
  }
  /* ... */
}
]]>
</programlisting>
  <para>
   <emphasis role="bold"> ユーザースペースを呼び出す: 構造体を引数にする場合
   </emphasis>
  </para>
<programlisting>
<![CDATA[
/* my_mysqlnd_plugin.c */

MYSQLND_METHOD(my_conn_class, connect)(
  MYSQLND *conn, /* ...*/) {
  /* ... */
  if (global_user_conn_proxy) {
    /* ... */
    zval* zv_conn;
    ZEND_REGISTER_RESOURCE(zv_conn, (void *)conn, le_mysqlnd_plugin_conn);
    MY_ZEND_CALL_METHOD_WRAPPER(global_user_conn_proxy, zv_retval, zv_conn, zv_host /*, ...*/);
    zval_ptr_dtor(&zv_conn);
    /* ... */
  }
  /* ... */
}
]]>
</programlisting>
  <para>
   多くの <literal>mysqlnd</literal> のメソッドがはじめに引数としてとるのが C の "object" です。たとえば、 connect() メソッドのはじめの引数は <literal>MYSQLND</literal>構造体 へのポインタです。MYSQNND構造体 は、<literal>mysqlnd</literal> 接続オブジェクトを表現します。
  </para>
  <para>
   <literal>mysqlnd</literal>接続オブジェクトへのポインタは、標準のI/Oファイルハンドルと比較できます。標準の I/Oファイルハンドルのように <literal>mysqlnd</literal>接続オブジェクトは PHP のリソース変数タイプを使ってユーザースペースに結びついていなければならないのです。
  </para>
  <para>
   <emphasis role="bold">C言語とユーザースペースを行き来する</emphasis>
  </para>
<programlisting>
<![CDATA[
 class proxy extends mysqlnd_plugin_connection {
  public function connect($conn, $host, ...) {
    /* "pre" hook */
    printf("Connecting to host = '%s'\n", $host);
    debug_print_backtrace();
    return parent::connect($conn);
  }

  public function query($conn, $query) {
    /* "post" hook */
    $ret = parent::query($conn, $query);
    printf("Query = '%s'\n", $query);
    return $ret;
  }
}
mysqlnd_plugin_set_conn_proxy(new proxy());
]]>
</programlisting>
  <para>
   PHP ユーザーは、オーバーライドしたメソッドの親の実装を呼び出し可能にしなければいけません。
  </para>
  <para>
   サブクラス化することで、ユーザーが選択したメソッドだけを改善し、"pre" や "post" フックを持たせるかどうかを選択できます。
  </para>
  <para>
   <emphasis role="bold"> ビルトインのクラス:
   mysqlnd_plugin_connection::connect() </emphasis>
  </para>
<programlisting>
<![CDATA[
/*  my_mysqlnd_plugin_classes.c */

 PHP_METHOD("mysqlnd_plugin_connection", connect) {
  /* ... simplified! ... */
  zval* mysqlnd_rsrc;
  MYSQLND* conn;
  char* host; int host_len;
  if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rs",
    &mysqlnd_rsrc, &host, &host_len) == FAILURE) {
    RETURN_NULL();
  }
  ZEND_FETCH_RESOURCE(conn, MYSQLND* conn, &mysqlnd_rsrc, -1,
    "Mysqlnd Connection", le_mysqlnd_plugin_conn);
  if (PASS == org_methods.connect(conn, host, /* simplified! */ TSRMLS_CC))
    RETVAL_TRUE;
  else
    RETVAL_FALSE;
}
]]>
</programlisting>
 </section>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
