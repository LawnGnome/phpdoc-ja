<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.5 $ -->
<!-- splitted from ./ja/functions/xslt.xml, last change in rev 1.1 -->
<!-- EN-Revision: 1.18 Maintainer: shimooka Status: ready -->
<!-- CREDITS: hirokawa -->
  <refentry id="function.xslt-process">
   <refnamediv>
    <refname>xslt_process</refname>
    <refpurpose>XSLデータを有する文字列によりXMLデータを変換する</refpurpose>
   </refnamediv>
   <refsect1>
    <title>説明</title>
     <methodsynopsis>
      <type>mixed</type><methodname>xslt_process</methodname>
       <methodparam><type>resource</type><parameter>xh</parameter></methodparam>
       <methodparam><type>string</type><parameter>xmlcontainer</parameter></methodparam>
       <methodparam><type>string</type><parameter>xslcontainer</parameter></methodparam>
       <methodparam choice="opt"><type>string</type><parameter>resultcontainer</parameter></methodparam>
       <methodparam choice="opt"><type>array</type><parameter>arguments</parameter></methodparam>
       <methodparam choice="opt"><type>array</type><parameter>parameters</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>xslt_process</function>関数は、新規XSLT拡張の中心関数で
     す。引数バッファの概念により、ほとんど全ての型の入力ソース -
     コンテナを用い
     てXSLT変換を実行可能です。引数バッファは、Sablotron XSLTプロセッ
     サ(現在、この拡張モジュールがサポートする惟一のXSLTプロセッサ)か
     ら得た概念です。
     入力コンテナは処理する文章を '含んでいる' ファイル名が
     デフォルトです。結果コンテナは、変換された文章のためのファイル名が
     デフォルトです。もし結果コンテナが指定されていない場合 - 例えば &null; -
     、結果が返されます。
    </para>
    <para>
     <warning>
      <simpara>
       PHP 4.0.6 以降、この関数は <parameter>xmlcontainer</parameter> 関数
       もしくは <parameter>xslcontainer</parameter> 関数で
       XML 文字列を取りません。
       XML を含む文字列を渡すことで、0.95とそれ以降の Sablotron
       バージョンでセグメンテーションフォルトを引き起こします。
      </simpara>
     </warning>
    </para>
    <para>
     また、<parameter>arguments</parameter>
     配列を通じてコンテナを設定することができます (以下参照)。
    </para>
    <para>
     <function>xslt_process</function>関数で変換する最も簡単な方法は、
     XMLファイルをXSLTファイルで変換し、結果を新しいXMLドキュメント(ま
     たはHTMLドキュメント)を含む3番目のファイルに出力することです。
     これをsablotronを行うのは、かなり簡単です。
    </para>
    <example>
     <title>
      XMLファイルとXSLファイルを新規XMLファイルに変換するために
      <function>xslt_process</function>を使用する
     </title>
     <programlisting role="php">
<![CDATA[
<?php

// 新規 XSLT プロセッサを割り当てる
$xh = xslt_create();

// 文章を処理する
if (xslt_process($xh, 'sample.xml', 'sample.xsl', 'result.xml')) {
    echo "SUCCESS, sample.xml was transformed by sample.xsl into result.xml";
    echo ", result.xml has the following contents\n<br />\n";
    echo "<pre>\n";
    readfile('result.xml');
    echo "</pre>\n";
} else {
    echo "Sorry, sample.xml could not be transformed by sample.xsl into";
    echo "  result.xml the reason is that " . xslt_error($xh) . " and the ";
    echo "error code is " . xslt_errno($xh);
}

xslt_free($xh);

?>
]]>
     </programlisting>
    </example>
    <para>
     この機能は優れていますが、特にWeb環境では、結果を直接出力したい場
     合があります。そこで、<function>xslt_process</function>の3番目の
     引数を省略した場合(またはその引数にNULL値を指定した場合)、ファイ
     ルに書き込む替わりに自動的にXSLT変換後の出力を返します。
    </para>
    <para>
     <example>
      <title>
       XMLファイルとXSLファイルを結果XMLデータを含む変数に変換するため
       に<function>xslt_process</function>を使用する
      </title>
     <programlisting role="php">
<![CDATA[
<?php

// 新規 XSLT プロセッサを割り当てる
$xh = xslt_create();

// 文章を処理し、変数 $result に結果を返す
$result = xslt_process($xh, 'sample.xml', 'sample.xsl');
if ($result) {
    print "SUCCESS, sample.xml was transformed by sample.xsl into the \$result";
    print " variable, the \$result variable has the following contents\n<br>\n";
    print "<pre>\n";
    print $result;
    print "</pre>\n";
}
else {
    print "Sorry, sample.xml could not be transformed by sample.xsl into";
    print "  the \$result variable the reason is that " . xslt_error($xh) .
    print " and the error code is " . xslt_errno($xh);
}

xslt_free($xh);

?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     上の二つのケースは、XSLT変換の最も簡単な場合です。これは、多くの
     場合には通用しますが、時々、データベースまたはソケットのような外
     部ソースからXMLとXSLTコードを取得する場合があります。このような場
     合、XMLまたはXSLTデータを変数に有することになります。
     実用アプリケーションでは、これらをファイルにダンプする際のオーバー
     ヘッドは大きいと言えます。このような場合こそ、XSLT
     &quot;argument&quot; 構文が役に立ちます。
     <function>xslt_process</function>関数のXMLおよびXSLT引数としてファ
     イルの替わりに引数配列(<function>xslt_process</function>関数の5番
     目のパラメータ)で指定した値に置換される&quot;argument place
     holders&quot;を指定することが可能です。
     以下にファイルを全く使用せずにXMLおよびXSLTを結果変数に処理する例
     を示します。
    </para>
    <para>
     <example>
      <title>
       XMLデータを含む変数とXSLTデータを含む変数をXMLデータ出力結果を
       含む変数に変換するために<function>xslt_process</function>を使用
       する
      </title>
     <programlisting role="php">
<![CDATA[
<?php
// $xml と $xsl は XML データと XSL データを含む

$arguments = array(
     '/_xml' => $xml,
     '/_xsl' => $xsl
);

// 新規 XSLT プロセッサを割り当てる
$xh = xslt_create();

// 文章を処理する
$result = xslt_process($xh, 'arg:/_xml', 'arg:/_xsl', NULL, $arguments);
if ($result) {
    echo "SUCCESS, sample.xml was transformed by sample.xsl into the \$result";
    echo " variable, the \$result variable has the following contents\n<br />\n";
    echo "<pre>\n";
    echo $result;
    echo "</pre>\n";
} else {
    echo "Sorry, sample.xml could not be transformed by sample.xsl into";
    echo "  the \$result variable the reason is that " . xslt_error($xh);
    echo " and the error code is " . xslt_errno($xh);
}
xslt_free($xh);
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     最後に、<function>xslt_process</function> 関数の最後のパラメータは、
     XSLT 文章に渡したいトップレベルのパラメータの配列です。
     これらのパラメータは、&lt;xsl:param name=&quot;parameter_name&quot;&gt;
     命令を用いて XSL ファイルのなかでアクセスすることができます。
     パラメータは UTF-8 エンコードでなければなりません。また、
     その値は <productname>Sablotron</productname>
     プロセッサによって文字列として解釈されます。その他の場合、
     XSLT 文章へのパラメータとしてノードセットを渡すことはできません。
    </para>
    <para>
     <example>
      <title>PHP 変数を XSL ファイルに渡す</title>
      <programlisting role="php">
<![CDATA[
<?php

// XML 文字列
$xml = '<?xml version="1.0"?>
<para>
 change me
</para>';

// XSL 文字列
$xsl = '
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:output method="html" encoding="ISO-8859-1" indent="no"
 omit-xml-declaration="yes"  media-type="text/html"/>
 <xsl:param name="myvar"/>
 <xsl:param name="mynode"/>
 <xsl:template match="/">
My PHP variable : <xsl:value-of select="$myvar"/><br />
My node set : <xsl:value-of select="$mynode"/>
 </xsl:template>
</xsl:stylesheet>';


$xh = xslt_create();

// 2番目のパラメータは文字列として解釈される
$parameters = array (
  'myvar' => 'test',
  'mynode' => '<foo>bar</foo>'
);

$arguments = array (
  '/_xml' => $xml,
  '/_xsl' => $xsl
);

echo xslt_process($xh, 'arg:/_xml', 'arg:/_xsl', NULL, $arguments, $parameters);

?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
My PHP variable : test<br>
My node set : &lt;foo&gt;bar&lt;/foo&gt;
]]>
      </screen>
     </example>
    </para>
    &note.xslt.windows;
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
