<?xml version="1.0" encoding="UTF-8"?>
<!-- $Revision: 1.2 $ -->
<!-- splitted from ./en/functions/exec.xml, last change in rev 1.28 -->
<!-- sync: 1.3 $ -->
  <refentry id='function.proc-open'>
   <refnamediv>
    <refname>proc_open</refname>
    <refpurpose>
     コマンドを実行し、入出力用にファイルポインタを開く
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>resource</type><methodname>proc_open</methodname>
      <methodparam><type>string</type><parameter>cmd</parameter></methodparam>
      <methodparam><type>array</type><parameter>descriptorspec</parameter></methodparam>
      <methodparam><type>array</type><parameter>pipes</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>proc_open</function> は <function>popen</function> と
     よく似ていますが、プログラムの実行をさらに細かく制御できる点で違います。
     <parameter>cmd</parameter> は、シェルによって実行されるコマンドです。
     <parameter>descriptorspec</parameter> は、キーがディスクリプタの番号で、
     値がどのようにディスクリプタを子プロセスに渡すかを示す配列です。
     <parameter>pipes</parameter> は、生成された、PHP 側のパイプの終端にあたる
     ファイルポインタを格納した配列にセットされます。
     返値はプロセスを表すリソースです。処理が終わったら、
     <function>proc_close</function> を使ってリソースを開放しなくては
     いけません。
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
$descriptorspec = array(
   0 => array("pipe", "r"),  // stdin is a pipe that the child will read from
   1 => array("pipe", "w"),  // stdout is a pipe that the child will write to
   2 => array("file", "/tmp/error-output.txt", "a") // stderr is a file to write to
);
$process = proc_open("php", $descriptorspec, $pipes);
if (is_resource($process)) {
    // $pipes はこの時点で次のような形を取っている
    // 0 => 子プロセスの stdin に繋がれた書き込み可能なハンドル
    // 1 => 子プロセスの stdout に繋がれた読み込み可能なハンドル
    // すべてのエラー出力は /tmp/error-output.txt に書き込みされます。

    fwrite($pipes[0], "<?php echo \"Hello World!\"; ?>");
    fclose($pipes[0]);

    while(!feof($pipes[1])) {
        echo fgets($pipes[1], 1024);
    }
    fclose($pipes[1]);
    // デッドロックを避けるため proc_close を呼ぶ前に、
    // すべてのパイプを閉じることが重要です。
    $return_value = proc_close($process);

    echo "command returned $return_value\n";
}
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     <parameter>descriptorspec</parameter> における
     ファイルディスクリプタの番号は、特に 0, 1, 2 に限られているわけでは
     ありません。有効であるどのようなファイルディスクリプタの番号も指定でき、
     それは子プロセスに渡されます。これにより、あるスクリプトと、
     子プロセスとして起動している別のスクリプトとの間で通信ができます。
     特に、これは PGP や GPG、openssl といったプログラムにパスフレーズを
     より安全な方法で渡したいとき威力を発揮します。
     補助的なファイルディスクリプタを介して、そのようなプログラムの
     状態を取得するのにも便利です。
    </para>
    <note>
     <para>
      Windows における互換性: 2 (stderr) よりも大きな番号のディスクリプタは
      子プロセスに継承可能なハンドルとして渡されますが、
      Windows のアーキテクチャは、ファイルディスクリプタの番号と
      より低レベルなハンドルを関連付けないので、子プロセスは、
      それらのハンドルにアクセスする術を持ちません。stdin, stdout, stderr
      は期待通り動きます。
     </para>
    </note>
    <note>
     <para>
      この関数は PHP 4.3.0 で導入されました。
     </para>
    </note>
    <note>
     <para>
      もし一方向のパイプを利用したいだけでしたら、
      <function>popen</function> を使うほうがより簡単です。
     </para>
    </note>

    <para>
     <function>exec</function>, <function>system</function>,
     <function>passthru</function>, <function>popen</function>,
     <function>escapeshellcmd</function>, <link
     linkend="language.operators.execution">backtick operator</link>
     も参照ください。
    </para>

   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
