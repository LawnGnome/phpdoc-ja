<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 317663 Maintainer: takagi Status: ready -->

<section xml:id="mongo.writes" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>書き込み</title>

 <section>
  <title>安全な操作</title>
  <para>
   デフォルトでは、書き込み (追加、更新および削除) の際にドライバはデータベースの応答を待ちません。
   書き込み操作は高速に行われるけれども、それが実際に成功したのかどうかは判断できないということです。
   書き込みに失敗する可能性はいくつか考えられます。ネットワークに問題があったり、
   データベースサーバが停止していたり、単に無効な書き込み操作だったり
   (システムコレクションに書き込もうとしたなど) といった原因です。
  </para>
  <para>
   データベースからの応答を取得するには、<literal>safe</literal> オプションを使います。
   このオプションは、すべての書き込み操作で使うことができます。
   このオプションを指定すると、データベースに書き込まれたのを確認してから
   成功したと判断して結果を返すようになります。書き込みに失敗した場合は、
   失敗した原因を示す <function>MongoCursorException</function>
   をスローします。
  </para>
  <para>
   開発中は、常に安全な書き込み操作を行うようにすべきでしょう
   (キーの重複エラーなどのうっかりミスを防ぐためにも)。
   運用時は、それほど "重要でない" データについては安全でない書き込みをしてもよいでしょう。
   何が "重要でない" かはアプリケーションによって異なりますが、一般的には
   (ユーザが作成するものではなく) 自動的に生成されるデータや秒間数千件のレコードを取得するデータなどを指します。
   たとえばクリック追跡データや GPS の位置データなどです。
  </para>
  <para>
   パフォーマンスへの悪影響を抑えつつ安全な書き込みを行うには、
   一連の書き込み操作の最後に安全な書き込みを行うことを推奨します。たとえばこのようになります。 
  </para>
  <programlisting role="php">
<![CDATA[

$collection->insert($someDoc);
$collection->update($criteria, $newObj);
$collection->insert($somethingElse);
$collection->remove($something, array("safe" => true));

]]>
  </programlisting>
  <para>
   そうすれば、もしデータベースに何か問題が発生すれば
   最後の書き込みが例外をスローするので気づくことができます。
  </para>
  <para>
   書き込みの安全性を確かめるためのオプションは、他にもいくつかあります。
   <literal>"fsync" =&gt; true</literal> を指定すると、この時点までのすべての書き込みを
   fsync して強制的にディスクに書き出します (デフォルトでは、MongoDB への書き込みの fsync
   は一分おきに行われます)。
  </para>
  <para>
   書き込みを最も安全に行うには、レプリケーションを使い、
   最低何台のサーバへの書き込みが完了したら成功と見なすのかを指定します
   (運用時には常にレプリケーションを使うべきです。レプリカセットに関する詳細な情報は
   "接続" のセクションを参照ください)。
  </para>
  <programlisting role="php">
<![CDATA[

$collection->insert($someDoc, array("safe" => 3));

]]>
  </programlisting>
  <para>
   <literal>"safe" =&gt; N</literal> と設定すると、最低 <literal>N</literal>
   台のサーバに書き込みが反映されるまで MongoDB サーバは書き込みに成功したと判断しません。
   つまり、<literal>N</literal> を 3 にすると、
   マスタと 2 台のスレーブには確実に書き込まれたことになります。
  </para>
 </section>

 <section>
  <title>ネストしたオブジェクトの更新</title>

  <para>
   次のドキュメントで、コメントの author を変更することを考えましょう。

   <programlisting>
<![CDATA[
{ 
    "_id" : ObjectId("4b06c282edb87a281e09dad9"), 
    "content" : "this is a blog post.",
    "comments" : 
    [
        {
            "author" : "Mike",
            "comment" : "I think that blah blah blah...",
        },
        {
            "author" : "John",
            "comment" : "I disagree."
        }
    ]
}
]]>
   </programlisting>

   内部のフィールドを変更するには、$set (他のフィールドが削除されてしまわないように!)
   を使って変更したいコメントのインデックスを指定します。

   <programlisting role="php">
<![CDATA[
<?php

$blog->update($criteria, array('$set' => array("comments.1" => array("author" => "Jim"))));

?>
]]>
   </programlisting>
  </para>
 </section>

 <section>
  <title>位置指定演算子</title>
  <para>
   位置指定演算子 <literal>$</literal> は、配列内のオブジェクトを更新するときに有用です。
   たとえば上の例で、実際に変更したいコメントのインデックスがわからないけれども
   "John" を "Jim" に変更しなければならないという状況を考えてみましょう。
   そんなときには <literal>$</literal> が使えます。
  </para>
  <programlisting role="php">
<![CDATA[
<?php

$blog->update(
    array("comments.author" => "John"), 
    array('$set' => array('comments.$.author' => "Jim")));

?>
]]>
  </programlisting>
 </section>
</section>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

