<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 328496 Maintainer: takagi Status: ready -->

<section xml:id="mongo.tutorial" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>チュートリアル</title>
 <section>
  <title>導入</title>
  <para>
   これは、10gen がサポートする MongoDB 用 PHP ドライバです。
  </para>
  <para>
   簡単なコード例をもとに、MongoDB への接続やドキュメントの追加、
   ドキュメントの問い合わせ、問い合わせ結果の反復処理、
   そして接続の切断の方法を示します。
   各ステップの詳細については後に続くチュートリアルを参照ください。
  </para>
  <programlisting role="php">
<![CDATA[
<?php

// 接続
$m = new MongoClient();

// データベースの選択
$db = $m->comedy;

// コレクション (リレーショナルデータベースのテーブルみたいなもの) の選択
$collection = $db->cartoons;

// レコードの追加
$obj = array( "title" => "Calvin and Hobbes", "author" => "Bill Watterson" );
$collection->insert($obj);

// 構造が異なる別のレコードの追加
$obj = array( "title" => "XKCD", "online" => true );
$collection->insert($obj);

// コレクション内の全件の検索
$cursor = $collection->find();

// 結果の反復処理
foreach ($cursor as $obj) {
    echo $obj["title"] . "\n";
}

?>
]]>
  </programlisting>
  <para>
   この出力は、次のようになります。
  </para>
  <screen>
<![CDATA[
Calvin and Hobbes
XKCD
]]>
  </screen>
 </section>
 <section>
  <title>接続の作成</title>
  <para>
   データベースサーバーに接続するには、次のいずれかの方法を使います。
  </para>

  <programlisting role="php">
<![CDATA[
<?php

$connection = new MongoClient(); // localhost:27017 に接続します
$connection = new MongoClient( "example.com" ); // リモートホスト (デフォルトのポート: 27017) に接続します
$connection = new MongoClient( "example.com:65432" ); // リモートホストの指定したポートに接続します

?>
]]>
  </programlisting>
  <para>
   明示的にデータベースとの接続を切断する必要はありません。
   <literal>$connection</literal> がスコープ外に抜けた時点で接続は自動的に閉じられ、
   使っていたデータベースリソースもすべて開放されます。
  </para>
  <section>
   <title>参考</title>
   <para>
    <link linkend="mongo.connecting">接続</link>のページで、
    さまざまな形式の接続を扱っています。
   </para>
   <para>
    <classname>MongoClient</classname> クラスや
    <function>MongoClient::__construct</function> の API ドキュメントには、
    利用可能なすべてのオプションや多くのサンプルがあります。
   </para>
  </section>

  <section>
  <title>データベースの取得</title>
   <para>
    データベースを選択するには次のようにします。
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$db = $connection->dbname;

?>
]]>
   </programlisting>
   <para>
    データベースを事前に作っておく必要はありません。
    存在しないデータベースを選択すれば、新しいデータベースを作ることができます。
   </para>
   <para>
    Typo には注意しましょう! 意図せずに新しいデータベースを作ってしまい、
    エラーで悩まされる原因になります。

    <programlisting role="php">
<![CDATA[
<?php

$db = $connection->mybiglongdbname;
// 何かをします
$db = $connection->mybiglongdbanme;
// これは別のデータベースに接続してしまいます!

?>
]]>
    </programlisting>
   </para>
   <section>
    <title>参考</title>
    <para>
     <classname>MongoDB</classname> クラスの API ドキュメントに、
     データベースオブジェクトに関する詳細な情報があります。
    </para>
   </section>
  </section>

  <section>
   <title>コレクションの取得</title>
   <para>
    コレクションの取得は、データベースの取得と同じ構文で行えます。
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$db = $connection->baz;
$collection = $db->foobar;

// あるいは、もうすこし簡潔に
$collection = $connection->baz->foobar;

?>
]]>
   </programlisting>
   <para>
    リレーショナルデータベースになじみのある人にとっては、
    コレクションとはテーブルに似たものだと考えればわかりやすいでしょう。
   </para>
   <section>
    <title>参考</title>
    <para>
     <classname>MongoCollection</classname> クラスの API ドキュメントに、
     コレクションオブジェクトに関する詳細な情報があります。
    </para>
   </section>
  </section>

  <section>
   <title>ドキュメントの追加</title>
   <para>
    連想配列は、データベース内のコレクションに保存できる基本的なオブジェクトです。
    何らかの "ドキュメント" はこのような形式になります。
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$doc = array( "name" => "MongoDB",
   "type" => "database",
   "count" => 1,
   "info" => (object)array( "x" => 203, "y" => 102),
   "versions" => array("0.9.7", "0.9.8", "0.9.9")
);

?>
]]>
   </programlisting>
   <para>
    配列やオブジェクトをネストできることに注目しましょう。
   </para>
   <para>
    ドキュメントを追加するには <function>MongoCollection::insert</function> を使います。
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$collection->insert( $doc );

?>
]]>
   </programlisting>
   <section>
    <title>参考</title>
    <para>
     <function>MongoCollection::insert</function> の API ドキュメントに、
     データの追加に関する詳細な情報があります。
    </para>
   </section>
  </section>

  <section>
   <title>
    <function>MongoCollection::findOne</function> によるドキュメントの検索
   </title>
   <para>
    先ほどの例で追加したドキュメントを表示するには、
    シンプルに <function>MongoCollection::findOne</function>
    を実行してコレクションからドキュメントをひとつ取得します。
    このメソッドは、クエリにマッチするドキュメントがひとつだけしかないときや
    一件の結果にだけしか興味がない場合に便利です。
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$obj = $collection->findOne();
var_dump( $obj );

?>
]]>
   </programlisting>
   <para>
    結果は、このようになります。
   </para>
   <programlisting>
<![CDATA[
array(6) {
  ["_id"]=>
  object(MongoId)#8 (1) {
    ["$id"]=>
    string(24) "4e2995576803fab768000000"
  }
  ["name"]=>
  string(7) "MongoDB"
  ["type"]=>
  string(8) "database"
  ["count"]=>
  int(1)
  ["info"]=>
  array(2) {
    ["x"]=>
    int(203)
    ["y"]=>
    int(102)
  }
  ["versions"]=>
  array(3) {
    [0]=>
    string(5) "0.9.7"
    [1]=>
    string(5) "0.9.8"
    [2]=>
    string(5) "0.9.9"
  }
}
]]>
   </programlisting>
   <para>
    <literal>_id</literal> フィールドが
    自動的にドキュメントに追加されていることに注目しましょう。
    <literal>_id</literal> は、いわゆる「主キー」フィールドです。
    ドキュメントにキーがなければ、ドライバが自動的に追加します。
   </para>
   <para>
    自前で <literal>_id</literal> フィールドを指定する場合は、
    コレクション内で一意になるようにしなければなりません。
    例をごらんください。
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$db->foo->insert(array("_id" => 1), array("safe" => true));
// これは例外が発生します
$db->foo->insert(array("_id" => 1), array("safe" => true));

// こちらは別のコレクションなので大丈夫です
$db->bar->insert(array("_id" => 1), array("safe" => true));

?>
]]>
   </programlisting>
   <para>
    これらの追加処理では、二番目の引数で配列
    <literal>array("safe" => true)</literal> を渡していることに注目しましょう。
    これは、追加時のオプションです。デフォルトでは、
    ドライバは書き込み処理の応答を待ちません。そのため、ドライバが
    <literal>_id</literal> を取得できなくなります。
    この操作が "安全な" 書き込みであると指定することで、
    ドライバは書き込み操作の完了を待って書き込みが消えてしまわないようにします。
    一般に、すべての書き込みには "safe" オプションを指定しておくべきです
    (先ほどの例で省略していたのは、コードをシンプルにするためです)。
   </para>
   <section>
    <title>参考</title>
    <para>
     <function>MongoCollection::findOne</function> に、
     データの検索に関する詳細な情報があります。
    </para>
    <para>
     <classname>MongoId</classname> には、一意な ID に関する詳細な説明があります。
    </para>
    <para>
     <link linkend="mongo.writes">書き込み</link>のページでは、
     安全な書き込みについてより詳しく扱っています。
     <function>MongoCollection::insert</function>、
     <function>MongoCollection::update</function> そして
     <function>MongoCollection::remove</function> といった書き込み関数の使いかたもあります。
    </para>
   </section>
  </section>

  <section>
   <title>複数のドキュメントの追加</title>
   <para>
    もう少し意味のある問い合わせをするために、複数のシンプルなドキュメントをコレクションに追加しましょう。
    ドキュメントは
    <literal>array( "i" => <replaceable>value</replaceable> );</literal>
    形式で、これをループ内で処理します。
   </para>
   <programlisting role="php">
<![CDATA[
<?php

for($i=0; $i<100; $i++) {
    $collection->insert( array( "i" => $i ) );
}

?>
]]>
   </programlisting>

   <para>
    先ほどと同じコレクションに、別のキーを持つ配列を追加していることに注目しましょう。
    MongoDB が「スキーマフリー」であると言われるのは、こういう側面があるからです。
   </para>
  </section>

  <section>
   <title>コレクション内のドキュメント数</title>
   <para>
    これで 101 件のドキュメントを追加したことになります
    (先ほどのループで 100 件、そして最初の 1 件)。
    本当にそうなっているか、<function>MongoCollection::count</function> メソッドで確認してみましょう。
    <programlisting role="php">
<![CDATA[
<?php

echo $collection->count();

?>
]]>
    </programlisting>
    結果は 101 と表示されます。
   </para>
  </section>

  <section>
   <title>カーソルを使った全ドキュメントの取得</title>
   <para>
    コレクション内のすべてのドキュメントを取得するには
    <function>MongoCollection::find</function> を使います。
    find() メソッドは <classname>MongoCursor</classname> オブジェクトを返し、
    これを使うとクエリにマッチしたドキュメントすべてに対する反復処理ができるようになります。
    では、すべてのドキュメントを取得して表示させてみましょう。

    <programlisting role="php">
<![CDATA[
<?php

$cursor = $collection->find();
foreach ($cursor as $id => $value) {
    echo "$id: ";
    var_dump( $value );
}

?>
]]>
    </programlisting>

    これは、コレクション内の全 101 ドキュメントを表示します。
    <literal>$id</literal> はドキュメントの <literal>_id</literal> フィールドで、
    <literal>$value</literal> はドキュメントそのものです。
   </para>
   <section>
    <title>参考</title>
    <para>
     <function>MongoCollection::find</function> の API ドキュメントに、
     データの検索に関する詳細な情報があります。
    </para>
   </section>
  </section>

  <section>
   <title>問い合わせの条件の設定</title>
   <para>
    クエリを作って <function>MongoCollection::find</function> メソッドに渡せば、
    コレクション内のドキュメントのサブセットを取得することができます。
    たとえば、"i" フィールドの値が 71 であるドキュメントを探したいときは、
    このようにします。
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$query = array( "i" => 71 );
$cursor = $collection->find( $query );

while( $cursor->hasNext() ) {
    var_dump( $cursor->getNext() );
}

?>
]]>
   </programlisting>
   <para>
    そうすると、ひとつのドキュメントだけが表示されます。
   </para>
   <programlisting>
<![CDATA[
array(2) {
  ["_id"]=>
  object(MongoId)#6 (0) {
  }
  ["i"]=>
  int(71)
  ["_ns"]=>
  "testCollection"
}
]]>
   </programlisting>
  </section>

  <section>
   <title>クエリによる複数ドキュメントの取得</title>
   <para>
    クエリを使って、コレクションからドキュメントのセットを取得することができます。
    たとえば、"i" &gt; 50 であるすべてのドキュメントを取得したい場合は次のようにします。
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$query = array( "i" => array( '$gt' => 50 ) ); // '$gt' と、シングルクォートで囲んでいることに注意しましょう
$cursor = $coll->find( $query );

while( $cursor->hasNext() ) {
    var_dump( $cursor->getNext() );
}

?>
]]>
   </programlisting>
   <para>
    これは、i &gt; 50 であるドキュメントをすべて表示します。
    また、20 &lt; i &lt;= 30 のような範囲を指定することもできます。
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$query = array( "i" => array( "\$gt" => 20, "\$lte" => 30 ) );
$cursor = $coll->find( $query );

while( $cursor->hasNext() ) {
    var_dump( $cursor->getNext() );
}

?>
]]>
   </programlisting>
   <para>
    常に $ 記号をエスケープするか、あるいはシングルクォートを使うことを覚えておきましょう。
    そうしないと、PHP はこれを変数 <varname>$gt</varname> と解釈してしまいます。
   </para>
  </section>

  <section>
   <title>インデックスの作成</title>
   <para>
    MongoDB はインデックスをサポートしています。コレクションにインデックスを追加するのは簡単です。
    インデックスを作るには、対象となるフィールドと並び順を指定します。
    並び順は、昇順 (1) あるいは降順 (-1) のいずれかです。
    この例では、"i" フィールドの昇順でインデックスを作成しています。
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$coll->ensureIndex( array( "i" => 1 ) );  // "i" にインデックスを作ります
$coll->ensureIndex( array( "i" => -1, "j" => 1 ) );  // "i" の降順、"j" の昇順でインデックスを作ります

?>
]]>
   </programlisting>
   <para>
    データが増えてもよいパフォーマンスを維持するためには、インデックスが不可欠です。
    インデックスについてよくわからない場合は、<function>MongoCollection::ensureIndex</function>
    のドキュメントと、本家の
    <link xlink:href="&url.mongodb.dochub.indexes;">インデックスに関するドキュメント</link>
    を参照ください。
   </para>
  </section>
 </section>
</section>
