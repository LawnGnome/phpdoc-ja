<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.14 $ -->
 <reference id="ref.classobj">
  <title>クラス/オブジェクト関数</title>
  <titleabbrev>クラス/オブジェクト</titleabbrev>

  <partintro>
   <sect1 id="classobj.partintro">
    <title>導入</title>
    <sect2 id="classobj.intro">
     <title>概要</title>
     <para>
      以下の関数により、クラスやインスタンスオブジェクトに関する情報を
      得ることが可能となります。オブジェクトが属するクラスの名前、その
      メンバープロパティ、メソッドを取得可能です。
      この関数を使用することにより、オブジェクトのクラスメンバーだけで
      なく親クラス(すなわちそのオブジェクトクラスの派生元)の情報を得る
      ことも可能です。
     </para>
    </sect2>
    <sect2 id="classobj.example">
     <title>使用例</title>
     <para>
      この例では、まず基底クラスおよびそのクラスの派生クラスを定義しま
      す。基底クラスは食用か否か、色とかいった、一般的な野菜を記述しま
      す。サブクラス<varname>spinach</varname>はその野菜の料理法と調理
      済であるかどうかの情報を追加します。
     </para>
     <para>
      <example>
       <title>classes.inc</title>
       <programlisting role="php">
<![CDATA[
<?php

// メンバープロパティとメソッドを有する基底クラス
class Vegetable {

	var $edible;
	var $color;

	function Vegetable( $edible, $color="green" ) {
		$this->edible = $edible;
		$this->color = $color;
	}

	function is_edible() {
		return $this->edible;
	}

	function what_color() {
		return $this->color;
	}
	
} // クラスVegetableの終り


// 基底クラスを拡張する
class Spinach extends Vegetable {

	var $cooked = false;

	function Spinach() {
		$this->Vegetable( true, "green" );
	}

	function cook_it() {
		$this->cooked = true;
	}

	function is_cooked() {
		return $this-&gt;cooked;
	}
	
} // クラスSpinachの終り

?>
]]>
       </programlisting>
      </example>
     </para>
     <para>
      続いて、これらのクラスから二つのオブジェクトのインスタンスを作成し、
      親クラスを含む情報を出力します。
      また、いくつかのユーティリティ関数を定義します。これらは主に変数
      を格好良く表示するためのものです。
     </para>
     <para>
      <example>
       <title>test_script.php</title>
       <programlisting role="php">
<![CDATA[
<pre>
<?php

include "classes.inc";

// ユーティリティ関数

function print_vars($obj) {
	$arr = get_object_vars($obj);
	while (list($prop, $val) = each($arr))
		echo "\t$prop = $val\n";
}

function print_methods($obj) {
	$arr = get_class_methods(get_class($obj));
	foreach ($arr as $method)
		echo "\tfunction $method()\n";
}

function class_parentage($obj, $class) {
	global $$obj;
	if (is_subclass_of($$obj, $class)) {
		echo "Object $obj belongs to class ".get_class($$obj);
		echo " a subclass of $class\n";
	} else {
		echo "Object $obj does not belong to a subclass of $class\n";
	}
}

// 二つのオブジェクトのインスタンスを作成

$veggie = new Vegetable(true,"blue");
$leafy = new Spinach();

// オブジェクトに関する情報を出力
echo "veggie: CLASS ".get_class($veggie)."\n";
echo "leafy: CLASS ".get_class($leafy);
echo " PARENT ".get_parent_class($leafy)."\n";

// veggieのプロパティを表示
echo "\nveggie: プロパティ\n";
print_vars($veggie);

// そしてleafyのメソッドを表示
echo "\nleafy: メソッド\n";
print_methods($leafy);

echo "\nParentage:\n";
class_parentage("leafy", "Spinach");
class_parentage("leafy", "Vegetable");
?>
</pre>
]]>
       </programlisting>
      </example>
     </para>
     <para>
      注意すべき大事な点ですが、上記の例ではオブジェクト
      <varname>$leafy</varname>は
      <classname>Vegetable</classname>のサブクラスであるクラス
      <classname>Spinach</classname>のインスタンスであり、
      このスクリプトの最後の部分は以下のような出力となります。
     </para>
     <para>
      <informalexample>
       <programlisting>
<![CDATA[
	   [...]
Parentage:
Object leafy does not belong to a subclass of Spinach
Object leafy belongs to class spinach a subclass of Vegetable
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect2>
   </sect1>
  </partintro>

  <refentry id="function.call-user-method-array">
   <refnamediv>
    <refname>call_user_method_array</refname>
    <refpurpose>
     パラメータの配列を指定してユーザメソッドをコールする
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>説明</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed 
       <function>call_user_method_array</function>
      </funcdef>
      <paramdef>string 
       <parameter>method_name</parameter>
      </paramdef>
      <paramdef>object 
       <parameter>obj</parameter>
      </paramdef>
      <paramdef>array 
       <parameter><optional>paramarr</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     パラメータ <parameter>paramarr</parameter> を使用してユーザ定義オ
     ブジェクト <parameter>obj</parameter>から
     <parameter>method_name</parameter>で参照されるメソッドをコールし
     ます。
    </para>
    <para>
     <function>call_user_func_array</function>,
     <function>call_user_func</function>,
     <function>call_user_method</function>も参照下さい。
    </para>
    <note>
     <para>
      この関数は、PHP 4.0.4pl1のリリース後にCVSコードに追加されました。
     </para>
    </note>
   </refsect1>
  </refentry>

  <refentry id="function.call-user-method">
   <refnamediv>
    <refname>call_user_method</refname>
    <refpurpose>
     指定したオブジェクトのユーザーメソッドをコールする
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>説明</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed 
       <function>call_user_method</function>
      </funcdef>
      <paramdef>string 
       <parameter>method_name</parameter>
      </paramdef>
      <paramdef>object 
       <parameter>obj</parameter>
      </paramdef>
      <paramdef>mixed 
       <parameter>
	<replaceable><optional>parameter</optional></replaceable>
       </parameter>
      </paramdef>
      <paramdef>mixed 
       <parameter>
	<replaceable><optional>...</optional></replaceable>
       </parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     ユーザ定義のオブジェクト<parameter>obj</parameter>から
     <parameter>method_name</parameter>により参照されるメソッドをコー
     ルします。以下に使用例を示します。ここでは、クラスを定義し、オブ
     ジェクトのインスタンスを作成し、
     <function>call_user_method</function>を用いて、間接的に
     そのクラスのメソッド<varname>print_info</varname>をコールします。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class Country {
    var $NAME;
    var $TLD;
    
    function Country($name, $tld) {
        $this->NAME = $name;
        $this->TLD = $tld;
    }

    function print_info($prestr="") {
        echo $prestr."Country: ".$this->NAME."\n";
        echo $prestr."Top Level Domain: ".$this->TLD."\n";
    }
}

$cntry = new Country("Peru","pe");

echo "* Calling the object method directly\n";
$cntry->print_info();

echo "\n* Calling the same method indirectly\n";
call_user_method ("print_info", $cntry, "\t");
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     <function>call_user_func_array</function>,
     <function>call_user_func</function>,
     <function>call_user_method_array</function> も参照下さい。
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.class-exists">
   <refnamediv>
    <refname>class_exists</refname>
    <refpurpose>クラスが定義済か確認する</refpurpose>
   </refnamediv>
   <refsect1>
    <title>説明</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>bool <function>class_exists</function></funcdef>
      <paramdef>string <parameter>class_name</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     この関数は、<parameter>class_name</parameter>で指定したクラスが定
     義されている場合に&true;、その他の場合に&false;を返します。
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.get-class">
   <refnamediv>
    <refname>get_class</refname>
    <refpurpose>オブジェクトのクラス名を返す</refpurpose>
   </refnamediv>
   <refsect1>
    <title>説明</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>get_class</function></funcdef>
      <paramdef>object <parameter>obj</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     このクラスはオブジェクト<parameter>obj</parameter>がインスタンス
     であるクラスの名前を返します。
    </para>
    <simpara>
     <function>get_parent_class</function>、
     <function>get_type</function>、
     <function>is_subclass_of</function>も参照下さい。
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.get-class-methods">
   <refnamediv>
    <refname>get_class_methods</refname>
    <refpurpose>クラスメソッドの名前を連想配列として返す</refpurpose>
   </refnamediv>
   <refsect1>
    <title>説明</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>get_class_methods</function></funcdef>
      <paramdef>string <parameter>class_name</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     この関数は、指定したクラス<parameter>class_name</parameter>に
     ついてメソッドの名前を連想配列として返します。
    </para>
    <note>
     <para>
      PHP 4.0.6 以降では、<parameter>class_name</parameter> の替わりに
      オブジェクト自身を指定することが可能です。例えば、
      <informalexample>
       <programlisting>
<![CDATA[
$class_methods = get_class_methods($my_class);
]]>
       </programlisting>
      </informalexample>
     </para>
    </note>
    <para>
     <example>
      <title><function>get_class_methods</function>の例</title> 
      <programlisting role="php">
<![CDATA[
<?php

class myclass {
    // コンストラクタ
    function myclass() {
        return(true);
    }
    
    // メソッド1
    function myfunc1() {
        return(true);
    }

    // メソッド2
    function myfunc2() {
        return(true);
    }
}

$my_class = new myclass();

$class_methods = get_class_methods(get_class($my_class));

foreach ($class_methods as $method_name) {
    echo "$method_name\n";
}

?>
]]>      
      </programlisting>
     </example>
    </para>
    <para>
     上の例の出力は次のようになります。
     <informalexample>
      <programlisting>
<![CDATA[
myclass
myfunc1
myfunc2
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     <function>get_class_vars</function>、
     <function>get_object_vars</function>も参照下さい。
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.get-class-vars">
   <refnamediv>
    <refname>get_class_vars</refname>
    <refpurpose>
     クラスのデフォルトプロパティを配列として返す
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>説明</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>get_class_vars</function></funcdef>
      <paramdef>string <parameter>class_name</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     この関数は、クラスのデフォルトプロパティを有する連想配列を返しま
     す。返される配列要素は、<parameter>変数名 => 値</parameter> の形
     式となります。
    </para>
    <note>
     <para>
      初期化されていないクラス変数は、
      <function>get_class_vars</function> で返されません。
     </para>
    </note>
    <para>
     <example>
      <title><function>get_class_vars</function> の例</title>
      <programlisting role="php">
<![CDATA[
<?php

class myclass {

    var $var1; // この変数にはデフォルト値がありません...
    var $var2 = "xyz";
    var $var3 = 100;
    
    // コンストラクタ
    function myclass() {
        return(true);
    }

}

$my_class = new myclass();

$class_vars = get_class_vars(get_class($my_class));

foreach ($class_vars as $name => $value) {
    echo "$name : $value\n";
}

?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     この例の出力は次のようになります。
     <informalexample>
      <programlisting>
<![CDATA[
var2 : xyz
var3 : 100
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     <function>get_class_methods</function>、
     <function>get_object_vars</function>も参照下さい。
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.get-declared-classes">
   <refnamediv>
    <refname>get_declared_classes</refname>
    <refpurpose>定義済のクラスの名前を配列として返す</refpurpose>
   </refnamediv>
   <refsect1>
    <title>説明</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>get_declared_classes</function></funcdef>
      <void/>
     </funcprototype>
    </funcsynopsis>
    <para>
     この関数は、カレントのスクリプトで宣言されたクラスの名前の配列を
     返します。
    </para>
    <note>
     <para>
      PHP 4.0.1pl2では、この他に次の3つのクラスが配列の先頭に返されま
      す。: <varname>stdClass</varname>
      (<filename>Zend/zend.c</filename>で定義)、
      <varname>OverloadedTestClass</varname>
      (<filename>ext/standard/basic_functions.c</filename>で定義)、
      <varname>Directory</varname>
      (<filename>ext/standard/dir.c</filename>で定義)
     </para>
     <para>
      PHPにコンパイルされているライブラリの種類に依存して、他のクラス
      も存在する可能性があることにも注意して下さい。
     </para>
    </note>
   </refsect1>
  </refentry>

  <refentry id="function.get-object-vars">
   <refnamediv>
    <refname>get_object_vars</refname>
    <refpurpose>オブジェクトプロパティを配列として返す</refpurpose>
   </refnamediv>
   <refsect1>
    <title>説明</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>get_object_vars</function></funcdef>
      <paramdef>object <parameter>obj</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     この関数は、指定したオブジェクト<parameter>obj</parameter>の
     オブジェクトプロパティを配列として返します。
     <parameter>obj</parameter> をインスタンスとするクラスで宣言された
     変数が値を有していない場合、これらの変数は配列として返されません。
    </para>
    <para>
     <example>
      <title><function>get_object_vars</function>の使用例</title>
      <programlisting role="php">
<![CDATA[
<?php
class Point2D {
    var $x, $y;
    var $label;

    function Point2D($x, $y) {
        $this->x = $x;
        $this->y = $y;
    }

    function setLabel($label) {
        $this->label = $label;
    }

    function getPoint() {
        return array("x" => $this->x,
                     "y" => $this->y,
                     "label" => $this->label);
    }
}

$p1 = new Point2D(1.233, 3.445);
print_r(get_object_vars($p1));
// "$label" は宣言されていますが、未定義です。
// Array
// (
//     [x] => 1.233
//     [y] => 3.445
// )

$p1->setLabel("point #1");
print_r(get_object_vars($p1));
// Array
// (
//     [x] => 1.233
//     [y] => 3.445
//     [label] => point #1
// )

?>
]]>
      </programlisting>
     </example>
    </para>
    <simpara>
     <function>get_class_methods</function>、
     <function>get_class_vars</function>も参照下さい。
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.get-parent-class">
   <refnamediv>
    <refname>get_parent_class</refname>
    <refpurpose>オブジェクトの親クラスの名前を返す</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>get_parent_class</function></funcdef>
      <paramdef>mixed <parameter>obj</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <parameter>obj</parameter>がオブジェクトの場合、
     <parameter>obj</parameter>がインスタンスであるクラスの親クラスの
     名前を返します。
    </para>
    <para>
     <parameter>obj</parameter>が文字列の場合、これを名前とするクラス
     の親クラスの名前を返します。この機能は、PHP 4.0.5で追加されました。
    </para>
    <simpara>
     <function>get_class</function>、
     <function>is_subclass_of</function>も参照下さい。
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.is-subclass-of">
   <refnamediv>
    <refname>is_subclass_of</refname>
    <refpurpose>
     あるオブジェクトが指定したクラスのサブクラスに属するかどうかを調
     べる
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>説明</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>bool <function>is_subclass_of</function></funcdef>
      <paramdef>object <parameter>obj</parameter></paramdef>
      <paramdef>string <parameter>superclass</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     この関数は、オブジェクト<parameter>obj</parameter>が
     <parameter>superclass</parameter>のサブクラスであるクラスに属する
     場合に&true;、その他の場合に&false;を返します。
    </para>
    <simpara>
     <function>get_class</function>,
     <function>get_parent_class</function>も参照下さい。
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.method-exists">
   <refnamediv>
    <refname>method_exists</refname>
    <refpurpose>クラスメソッドが存在するかどうかを確認する</refpurpose>
   </refnamediv>
   <refsect1>
    <title>説明</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>bool <function>method_exists</function></funcdef>
      <paramdef>object <parameter>object</parameter></paramdef>
      <paramdef>string <parameter>method_name</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     この関数は、<parameter>method_name</parameter>で指定したメソッドが
     指定した<parameter>object</parameter>において定義されている
     場合に&true;、そうでない場合に&false;を返します。
    </para>
   </refsect1>
  </refentry>

 </reference>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
