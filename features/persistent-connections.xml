 <chapter id="features.persistent-connections">
  <title>持続的データベース接続</title>

  <simpara>
  持続的接続は、スクリプトの実行終了時にも閉じられないSQLリンク
  です。
  持続的接続が要求された時、PHPは(前もってオープンされたままになっている)
  同じ持続的接続が既にオープンされていないかどうかを確認します。
  そして、存在する場合には、それを使用します。存在しない場合には、
  そのリンクを作成します。'同じ'接続とは、同じホスト、同じユーザー名、
  同じパスワード(利用可能な場合)でオープンされた接続のことを意味します。</simpara>

  <simpara>
  Webサーバーの動作及び負荷の分散に関して熟知していない
  人は、持続的接続において何が行われないかに関してミスを犯す可能性があります。
  特に、持続的接続は、同じSQLリンクで'ユーザーセッション'をオープンする
  機能やトランザクションを効率的に確立する機能やその他のあらゆる機能を
  提供しません。
   つまり、言いたいことを極めて簡単に述べると、持続的接続は非持続的接続で
   使用できない <emphasis>いかなる</emphasis> 機能も提供しません。</simpara>

  <simpara>
   なぜ? </simpara>

  <simpara>
  これは、Webサーバーの動作により行われるべきものです。
  Webページを生成するためにPHPを利用するWebサーバーには、
  3種類の方法があります。</simpara>

  <simpara>
  最初は、CGI "ラッパー"としてPHPを使用する方法です。
  このように実行した場合、PHPインタプリタのインスタンスは、
  Webサーバーに(PHPページに関する)ページがリクエストされる度に生成され、
  破棄されます。
  リクエスト毎に破棄されるために、(SQLデータベースサーバーへのリンクのような)
  必要な全てのリソースは破棄される際にクローズされます。
  この場合、持続的接続を使用することから得るものは何もありません。
  持続的接続は持続しないのです。</simpara>

  <simpara>
  2番目は、最も一般的ですが、PHPをマルチプロセスWebサーバー(現在は
  Apacheのみが含まれます)のモジュールとして
  実行する方法です。マルチプロセスサーバーは、通常、実際に
  Webページを送信する複数のプロセス(子)を管理するプロセス(親)
  を有しています。
  リクエストがクライアントから来ると、親プロセスは、
  他のクライアントにすでに送信を
  行っていないクライアントの一つに渡します。
  このため、同じクライアントが2番目のリクエストをサーバーに送信した際に
  最初のではなく他の子プロセスにより送信が行われる可能性があります。
  この場合、持続的接続が行うのは、
  SQLサーバーに接続を行うページを送信する各子プロセスが、
  最初にSQLサーバーに接続する場合にのみ、接続を行う必要があるようにする
  ことです。
  別のページがSQLサーバーに接続要求を出した場合、以前に子が確立した
  接続を再使用することが可能です。</simpara>

  <simpara>
  最後のは、PHPをマルチスレッドWebサーバーのプラグインとして
  使用する方法です。
  現在、この方法は理論的なものにとどまっています。PHPは、
  まだマルチスレッド型Webサーバーでプラグインとして動作しません。
  (Windows上で) ISAPI、WSAPI、NSAPI をサポートする作業が進行中です。
  これにより、PHPを Netscape FastTrack、Microsoft の Internet Information Server 
  (IIS)、O'Reilly の WebSite Pro のようなマルチスレッド型サーバーのプラグインとして
  使用することが可能となります。  
  これが実現した場合、動作は先に記したマルチプロセスモデルと同じになるでしょう。</simpara>

  <simpara>
  持続的接続が機能を全く付加しないとしたら、優れている点は
  なんでしょう?</simpara>

  <simpara>
  答えはかなり簡単です。効率です。持続的接続は、SQLサーバーへ接続する
  オーバーヘッドが大きい場合には有効です。
  このオーバーヘッドが実際に大きいがどうかは様々な要因に依存します。
  例えば、
  データベースの種類、Webサーバーが動作するのと同じコンピューター
  で動作しているか、SQLサーバーを動作させているマシンの負荷、等となります。
  肝心なのは、接続のオーバーヘッドが高い場合、持続的接続は著しいということ
  です。

  持続的接続は、
  SQLサーバーへの接続を要求するページをリクエスト毎に処理する
  代わりに子プロセスが動作中の間一回しかサーバーへの接続を行わないように
  します。
  このことは、持続的接続をオープンしたプロセス毎に
  サーバーへの持続的接続をオープンするということになります。
  例えば、20の異なった子プロセスがSQLサーバーへの持続的接続を
  行うスクリプトを実行した場合、各子プロセス毎にSQLサーバーへの20の異なった
  接続が行われます。</simpara>

  <simpara>
  重要なことをまとめます。持続的接続は、標準的な接続に1対1の割りつけ
  を行うように設計されています。
  このことは、<emphasis>常に</emphasis> 持続的接続を非持続的接続で
  置きかえ、かつ動作を変更しないということができることを意味します。
  持続的接続は、スクリプトの効率を変更するでしょうが、動作は変更しません!</simpara>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
