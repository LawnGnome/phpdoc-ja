<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.14 $ -->
<!-- EN-Revision: 1.45 Maintainer: hirokawa Status: ready -->
<!-- CREDITS: shimooka,takagi -->
 <chapter id="features.commandline">
  <title>PHP をコマンドラインから使用する</title>
  <para>
   4.3 以降で PHP は
   <emphasis>Command Line Interface</emphasis> を意味する
   <literal>CLI</literal> という名前の新しい <literal>SAPI</literal> 型
   (Server Application Programming Interface)をサポートします。
   名前から分かるように、この <literal>SAPI</literal> 型は、
   PHP によるシェル(またはデスクトップ)アプリケーションの開発を
   主な対象としています。
   <literal>CLI SAPI</literal> と他の <literal>SAPI</literal> の間には、
   いくつかの違いがあります。本章では、これらについて詳細を説明します。
   <literal>CLI</literal> と <literal>CGI</literal> はその振る舞いの多くが
   共通であるにもかかわらず、違う SAPI であることに留意してください。
  </para>
  <para>
   <literal>CLI SAPI</literal> は、当初 PHP 4.2.0 でリリースされましたが、
   この時点では実験的なステータスにあったため、
   <literal>./configure</literal> を実行する際に、明示的に
   <option role="configure">--enable-cli</option> を指定することにより、
   有効とする必要がありました。PHP 4.3.0 以降、
   <literal>CLI SAPI</literal> はもはや実験的なステータスではなくなり、
   <option role="configure">--enable-cli</option> はデフォルトでオンとなりました。
   <option role="configure">--disable-cli</option> によりこれを無効とする
   ことも可能です。
  </para>
  <para>
   PHP 4.3.0 以降、システムにPHPがどのようにインストールされているかによって
   CLI/CGI バイナリの名前、位置、存在が異なります。デフォルトでは
   <command>make</command> を実行すると CGI と CLI の両方がビルドされ
   ソースディレクトリの <filename>sapi/cgi/php</filename> と
   <filename>sapi/cli/php</filename> にそれぞれ配置されます。両方とも
   php という名前であることに注意してください
   <command>make install</command> でどうなるかは configure に因ります。
   configure で例えば apxs のような SAPI モジュールが選択された場合、または
   <option role="configure">--disable-cgi</option> が指定された場合、
   <command>make install</command> によって CLI が <filename>{PREFIX}/bin/php</filename>
   にコピーされます。さもなければ CGI がそこにコピーされます。
   既にインストールされている CGI バイナリを上書きしたい場合には、
   <command>make install</command> の後に <command>make install-cli</command>
   を実行してください。あるいは configure で
   <option role="configure">--disable-cgi</option> を指定することもできます。
  </para>
  <note>
   <para>
    <option role="configure">--enable-cli</option>
    と <option role="configure">--enable-cgi</option>
    の両方がデフォルトで有効になっています。そのため、configure で
    <option role="configure">--enable-cli</option>
    を指定したからといって、<command>make install</command> で
    <filename>{PREFIX}/bin/php</filename> 
    にコピーされるのが必ずしも CLI になるとは限りません。
   </para>
  </note>
  <para>
   PHP 4.2.0 から PHP 4.2.3 までの Windows パッケージでは CLI は
   CGI <filename>php.exe</filename> と同じフォルダに
   <filename>php-cli.exe</filename> として配布されていました。
   PHP 4.3.0 からは Windows パッケージでは CLI は
   <filename class="directory">cli</filename> という
   別のフォルダに <filename>php.exe</filename> として配布されます。
   したがって <literal>cli/php.exe</literal> となります。
   PHP 5 以降、CLI はメインフォルダ内で <filename>php.exe</filename>
   という名前で配布されます。CGI バージョンは、<filename>php-cgi.exe</filename>
   として配布されます。
  </para>
  <para>
   PHP 5 では、新しく <filename>php-win.exe</filename> というファイルが
   配布されます。これは CLI バージョンとほぼ同じですが、php-win は何も
   出力しないため、コンソールを必要としません（画面に「DOS 窓」が表示
   されません）。この振る舞いは、php-gtk と似ています。このためには
   <option role="configure">--enable-cli-win32</option> オプションを
   含めて configure を行います。
  </para>
  <note>
   <title>自分の SAPI は何か?</title>
   <para>
    シェルで <command>php -v</command> をタイプすると、
    <filename>php</filename> が CGI なのか CLI なのかわかります。
    <function>php_sapi_name</function> と定数 <constant>PHP_SAPI</constant>
    も参照してください。
   </para>
  </note>
  <note>
   <para>
    Unix の <literal>man</literal> ページが PHP 4.3.2 で追加されました。
    シェル環境から <command>man php</command> とすることで見ることができます。
   </para>
  </note>
  <para>
   <literal>CLI SAPI</literal> を他の <literal>SAPI</literal> と比べた時の
   大きな違いを以下に示します。
   <itemizedlist>
    <listitem>
     <para>
      <literal>CGI SAPI</literal> と異なり、ヘッダが出力されません。
     </para>
     <para>
      <literal>CGI SAPI</literal> は HTTP ヘッダの出力を抑制する機能を
      提供していますが、等価な機能は <literal>CLI SAPI</literal> では
      サポートされていません。
     </para>
    <para>
     デフォルトでは CLI は静寂モードで起動されます。古い CGI スクリプトと互換性を
     保って使えるように <option>-q</option> スイッチが残されています。
    </para>
    <para>
     動作するディレクトリはスクリプトの場所に変更されることはありません
     （<option>-C</option> および <option>--no-chdir</option> スイッチは
     互換性のために残されています）。
    </para>
    <para>
     エラーメッセージはプレーンテキストで表示されます
     （HTML でフォーマットされません）。
    </para>
    </listitem>
    <listitem>
     <para>
      以下に示すいくつかの &php.ini; ディレクティブは、<literal>CLI
      SAPI</literal> により上書きされます。これは、シェル環境では意味が
      ないためです。
      <table>
       <title>上書きされる &php.ini; のディレクティブ</title>
       <tgroup cols="3">
        <thead>
         <row>
          <entry>ディレクティブ</entry>
          <entry><literal>CLI SAPI</literal> のデフォルト値</entry>
          <entry>コメント</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><link linkend="ini.html-errors">html_errors</link></entry>
          <entry>&false;</entry>
          <entry>
           エラーメッセージに含まれる <literal>HTML</literal> タグは
           シェル上では意味がなく、可読性をかなり低下させるため、この
           ディレクティブはデフォルトで &false; となっています。
          </entry>
         </row>
         <row>
          <entry><link linkend="ini.implicit-flush">implicit_flush</link></entry>
          <entry>&true;</entry>
          <entry>
           <function>print</function>, <function>echo</function> および
           関連するものによる全ての出力は、直ちに出力され、バッファに
           キャッシュされないことが望ましいと言えます。この場合でも、
           標準出力を保留または操作したい場合には、
           <link linkend="ref.outcontrol">output buffering</link> を
           使用することが可能です。
          </entry>
         </row>
         <row>
          <entry><link linkend="ini.max-execution-time">max_execution_time</link></entry>
          <entry>0 (unlimited)</entry>
          <entry>
           シェル環境では、PHP を際限なく使用できる
           ようにするために、最大実行時間の制限は無しに設定されています。
           Web 用アプリケーションは数秒単位で実行されるよう作られて
           いますが、シェルアプリケーションの実行時間は、これよりかなり
           長くなる傾向があります。
          </entry>
         </row>
         <row>
          <entry><link linkend="ini.register-argc-argv">register_argc_argv</link></entry>
          <entry>&true;</entry>
          <entry>
          <para>
           <literal>CLI SAPI</literal> を使用している場合、グローバル
           PHP 変数 <literal>$argc</literal>
           (アプリケーションに渡される引数の数)と
           <literal>$argv</literal> (引数の値の配列)は常に登録され、
           適切な値が代入されます。
          </para>
          <para>
           PHP 4.3.0以降、<literal>CLI SAPI</literal> を使用するときに
           PHP の <varname>$argc</varname> 変数と
           <varname>$argv</varname> 変数が登録され、適切な値がセットされます。
           このバージョンより前では、<literal>CGI</literal> や
           <literal>MODULE</literal> がこれらの変数を生成するには PHP の
           <link linkend="ini.register-globals">register_globals</link>
           ディレクティブがオンになっている必要がありました。
           バージョンや register_globals の設定がどうであろうと、
           <link linkend="reserved.variables.server">$_SERVER</link> または
           <varname>$HTTP_SERVER_VARS</varname> は常に使用可能です。
           例：<varname>$_SERVER['argv']</varname>
          </para>
          </entry>
         </row>
        </tbody>
       </tgroup>
      </table>
     </para>
     <note>
      <para>
       これらのディレクティブは、設定ファイル &php.ini; またはカスタム
       設定ファイル(指定した場合のみ)で他の値に初期化できません。
       この制限は、これらのデフォルト値が全ての設定ファイルをパースした後に
       適用されるためです。しかし、これらの値は実行時に変更することが
       可能です
       (上記のディレクティブの全てについてこれが当てはまるわけでは
       ありません。例えば、<link
       linkend="ini.register-argc-argv">register_argc_argv</link>)。
      </para>
     </note>
    </listitem>
    <listitem>
     <para>
      シェル環境での動作を容易とするために、以下の定数が定義されています。
      <table>
       <title>CLI 固有の定数</title>
       <tgroup cols="2">
        <thead>
         <row>
          <entry>定数</entry>
          <entry>説明</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><constant>STDIN</constant></entry>
          <entry>
           <literal>stdin</literal> へのオープン済みのストリーム。
           これにより、以下のようにオープンする必要がなくなります。
           <programlisting role="php">
<![CDATA[
<?php

$stdin = fopen('php://stdin', 'r');

?>
]]>
           </programlisting>
           <literal>stdin</literal> から1行読み込みたい場合、以下のようにします。
           <programlisting role="php">
<![CDATA[
<?php
$line = trim(fgets(STDIN)); // STDIN から 1 行読み込む
fscanf(STDIN, "%d\n", $number); // STDIN から数値を読み込む
?>
]]>
           </programlisting>
          </entry>
         </row>
         <row>
          <entry><constant>STDOUT</constant></entry>
          <entry>
           <literal>stdout</literal> へのオープン済みのストリーム。
           これにより、以下のようにオープンする必要がなくなります。
           <programlisting role="php">
<![CDATA[
<?php

$stdout = fopen('php://stdout', 'w');

?>
]]>
           </programlisting>
          </entry>
         </row>
         <row>
          <entry><constant>STDERR</constant></entry>
          <entry>
           <literal>stderr</literal> へのオープン済みのストリーム。
           これにより、以下のようにオープンする必要がなくなります。
           <programlisting role="php">
<![CDATA[
<?php

$stderr = fopen('php://stderr', 'w');

?>
]]>
           </programlisting>
          </entry>
         </row>
        </tbody>
       </tgroup>
      </table>
     </para>
     <para>
      上記のように、<literal>stderr</literal> のようなストリームを自分で
      オープンする必要はなく、以下のようにストリームリソースの代わりに
      定数を使用するだけでかまいません。
     <programlisting role="shell">
<![CDATA[
php -r 'fwrite(STDERR, "stderr\n");'
]]>
     </programlisting>
      これらのストリームを明示的に閉じる必要はありません。これは、
      PHP により自動的に行われます。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>CLI SAPI</literal> は、実行されるスクリプトのディレクトリに
      カレントディレクトリを変更<emphasis role="strong">しません
      </emphasis>!
    </para>
    <informalexample>
     <para>
      <literal>CGI SAPI</literal> との違いを示す例を以下に示します。
     </para>
      <programlisting role="php">
<![CDATA[
<?php
// シンプルなテストアプリケーション
echo getcwd(), "\n";
?>
]]>
      </programlisting>
     <para>
      <literal>CGI</literal> 版により実行した場合、出力は以下のようになります。
     </para>
     <screen>
<![CDATA[
$ pwd
/tmp

$ php-cgi -f another_directory/test.php
/tmp/another_directory
]]>
     </screen>
     <para>
      これは、PHP が実行するスクリプトのディレクトリに
      カレントディレクトリを変更することを明らかに示しています。
     </para>
     <para>
      <literal>CLI SAPI</literal> を使用した場合の出力は次のようになります。
     </para>
     <screen>
<![CDATA[
$ pwd
/tmp

$ php -f another_directory/test.php
/tmp
]]>
      </screen>
     <para>
      これにより、PHP でシェルツールを書く際の柔軟性をより大きくすることができます。
     </para>
    </informalexample>
     <note>
      <para>
       <literal>CGI SAPI</literal> は、この <literal>CLI SAPI</literal>
       の動作をコマンドライン実行時のスイッチ <literal>-C</literal>
       によりサポートしています。
      </para>
    </note>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   PHP バイナリにより提供されるコマンドラインオプションの一覧は、
   <option>-h</option> スイッチを指定して PHP を実行することにより
   いつでも調べることができます。
   <screen>
<![CDATA[
Usage: php [options] [-f] <file> [--] [args...]
       php [options] -r <code> [--] [args...]
       php [options] [-B <begin_code>] -R <code> [-E <end_code>] [--] [args...]
       php [options] [-B <begin_code>] -F <file> [-E <end_code>] [--] [args...]
       php [options] -- [args...]
       php [options] -a

  -a               Run as interactive shell
  -c <path>|<file> Look for php.ini file in this directory
  -n               No php.ini file will be used
  -d foo[=bar]     Define INI entry foo with value 'bar'
  -e               Generate extended information for debugger/profiler
  -f <file>        Parse and execute <file>.
  -h               This help
  -i               PHP information
  -l               Syntax check only (lint)
  -m               Show compiled in modules
  -r <code>        Run PHP <code> without using script tags <?..?>
  -B <begin_code>  Run PHP <begin_code> before processing input lines
  -R <code>        Run PHP <code> for every input line
  -F <file>        Parse and execute <file> for every input line
  -E <end_code>    Run PHP <end_code> after processing all input lines
  -H               Hide any passed arguments from external tools.
  -s               Display colour syntax highlighted source.
  -v               Version number
  -w               Display source with stripped comments and whitespace.
  -z <file>        Load Zend extension <file>.

  args...          Arguments passed to script. Use -- args when first argument
                   starts with - or script is read from stdin

  --rf <name>      Show information about function <name>.
  --rc <name>      Show information about class <name>.
  --re <name>      Show information about extension <name>.
  --ri <name>      Show configuration for extension <name>.
]]>
   </screen>
  </para>
  <para>
   <literal>CLI SAPI</literal> は、実行する PHP コードを
   取得するために三種類の異なる手段をサポートしています。
   <orderedlist>
   <listitem>
     <para>
      PHP に特定のファイルの実行を指示する。
     </para>
    <informalexample>
      <screen>
<![CDATA[
php my_script.php

php -f my_script.php
]]>
      </screen>
    </informalexample>
    <para>
      上記の方法は共に(<option>-f</option> スイッチの使用の如何に関らず)
      指定したファイル <filename>my_script.php</filename> を実行します。
      実行ファイルとしてあらゆるファイルを指定することができ、
      PHP スクリプトは拡張子
      <literal>.php</literal> で終わる必要がなく、任意の名前や拡張子を
      使用することができます。
     </para>
    </listitem>
    <listitem>
     <para>
      実行する PHP コードをコマンドラインで直接指定する。
     </para>
    <informalexample>
      <screen>
<![CDATA[
php -r 'print_r(get_defined_constants());'
]]>
      </screen>
    </informalexample>
    <para>
      シェル変数の置換と引用符の使用については特に注意してください。
     </para>
     <note>
      <para>
       この例をよくみてください。開始/終了タグがありません!
       <option>-r</option> スイッチを使用した場合、これらのタグは不要と
       なります。これらのタグを使用するとパーサエラーを発生します。
      </para>
     </note>
    </listitem>
    <listitem>
     <para>
      実行する PHP コードを標準入力
      (<literal>stdin</literal>)で指定する。
     </para>
     <para>
      これは強力な機能で、以下の(仮想的な)例に示すように、動的に
      PHP コードを生成し、実行バイナリに入力すること
      ができます。
    </para>
    <informalexample>
      <screen>
<![CDATA[
$ some_application | some_filter | php | sort -u >final_output.txt
]]>
      </screen>
    </informalexample>
    </listitem>
  </orderedlist>
   これらのコードを実行する三種類の方法を組み合わせて使用することは
   できません。
  </para>
  <para>
   他のシェルアプリケーションのように、PHP バイナリに
   引数を指定することができるだけでなく、PHP スクリプトが
   この引数を取得することも可能です。スクリプトに指定できる
   引数の数は PHP による制限を受けません
   (シェルは指定可能な文字数の最大値を設定しています。通常、この制限値を
   越えることはできません)。スクリプトに指定した引数は、グローバル配列
   <varname>$argv</varname> でアクセス可能です。
   添字 0 は、常にスクリプト名が含まれています
   (PHP コードが標準入力またはコマンドラインスイッチ
   <literal>-r</literal> により指定された場合、スクリプト名は
   <literal>-</literal> となります)。
   登録される第 2 のグローバル変数は <varname>$argc</varname> で
   (スクリプトに指定された引数の数では<emphasis role="strong">なく
   </emphasis>)、配列 <varname>$argv</varname> の要素数が含まれます。
  </para>
  <para>
   スクリプトに指定する引数が文字 <literal>-</literal> で始まっていない
   限り、特に留意すべきことはありません。スクリプトに指定する引数が文字
   <literal>-</literal> で始まる場合、PHP 自体がこれを
   パースする必要があるとみなすため、問題を発生します。
   これを防止するため、引数リストセパレータ <literal>--</literal> を
   使用してください。PHP にパースされる引数の後に
   このセパレータを置くと、その後の全ての引数はそのままパースされずに
   スクリプトに渡されます。
  </para>
 <informalexample>
  <screen>
<![CDATA[
# これは、指定したコードを実行せずに PHP の使用法を示します
$ php -r 'var_dump($argv);' -h
Usage: php [options] [-f] <file> [args...]
[...]

# これは '-h' を引数として解釈し、PHP の使用法を表示しません
$ php -r 'var_dump($argv);' -- -h
array(2) {
  [0]=>
  string(1) "-"
  [1]=>
  string(2) "-h"
}
]]>
  </screen>
 </informalexample>
  <para>
   また、PHP をシェルスクリプトとして使用する他の手段があります。
   最初の行が <literal>#!/usr/bin/php</literal> で始まり、
   PHP の開始/終了タグの中に通常の
   PHP コードが続くスクリプトを書き、適当なファイル
   実行属性を設定する(例: <command>chmod +x test</command>)ことが可能です。
   この方法は、通常のシェル/Perl スクリプトと同様に実行することができます。
 </para>
 <example>
  <title>シェルスクリプトとしての PHP スクリプトの実行</title>
   <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php
var_dump($argv);
?>
]]>
   </programlisting>
  <para>
    このファイルの名前が <filename>test</filename> で、カレントディレクトリに
    あるとすると、以下のように実行することができます。
  </para>
   <screen>
<![CDATA[
$ chmod +x test
$ ./test -h -- foo
array(4) {
  [0]=>
  string(6) "./test"
  [1]=>
  string(2) "-h"
  [2]=>
  string(2) "--"
  [3]=>
  string(3) "foo"
}
]]>
   </screen>
 </example>
 <para>
   見て分かるように、<literal>-</literal> で始まるスクリプトのパラメータを
   指定する際に、特に注意する必要はありません。
  </para>
  <para>
   長いオプション指定は、PHP 4.3.3 以降で利用可能です。
   <table>
    <title>コマンドラインオプション</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>オプション</entry>
       <entry>長いオプション</entry>
       <entry>説明</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>-a</entry>
       <entry>--interactive</entry>
       <entry>
        <para>
         PHP を対話的に実行します。PHP のコンパイル時に <link
          linkend="ref.readline">Readline</link> 拡張モジュール（Windows 
         版では利用できません）を含めた場合、補完（例: 変数名の一部を
         入力して TAB キーを押すと、PHP が完全な変数名に変換する）・
         矢印キーによるコマンド履歴
         などの高度な機能が利用できます。コマンドの履歴は
         <filename>~/.php_history</filename> ファイルに保存されます。
        </para>
       <note>
        <para>
         <link
         linkend="ini.auto-prepend-file">auto_prepend_file</link> および <link
         linkend="ini.auto-append-file">auto_append_file</link> で
         インクルードされたファイルはこのモードでもパースされますが、
         いくつかの制限があります。例えば、関数はそれがコールされる前に
         定義されていなければなりません。
        </para>
       </note>
       </entry>
      </row>
      <row>
       <entry>-c</entry>
       <entry>--php-ini</entry>
       <entry>
        <para>
         このオプションを使用することにより、&php.ini; を探すディレクトリを
         指定したり、カスタマイズされた <literal>INI</literal> ファイル
         (&php.ini; という名前である必要はありません)を直接指定する
         ことが可能です。例：
       </para>
       <para><informalexample>
         <screen>
<![CDATA[
$ php -c /custom/directory/ my_script.php

$ php -c /custom/directory/custom-file.ini my_script.php
]]>
         </screen>
       </informalexample></para>
       <para>
         このオプションを指定しない場合、ファイルは、
         <link linkend="configuration.file">デフォルトの位置</link>
         で探索されます。
        </para>
       </entry>
      </row>
      <row>
       <entry>-n</entry>
       <entry>--no-php-ini</entry>
       <entry>
        <para>
         &php.ini; を完全に無視します。このスイッチは、PHP 4.3.0 以降で
         利用可能です。
        </para>
       </entry>
      </row>
      <row>
       <entry>-d</entry>
       <entry>--define</entry>
       <entry>
        <para>
         このオプションにより &php.ini; で指定できる設定ディレクティブに
         カスタム値を設定することができます。構文は以下のようになります。
         <screen>
<![CDATA[
-d configuration_directive[=value]
]]>
         </screen>
        </para>
       <para><informalexample>
        <para>
         例 (レイアウト上の理由により、長い行が折りたたまれています):
        </para>
         <screen>
<![CDATA[
# 値の部分を省略すると、設定ディレクティブに"1"を指定します
$ php -d max_execution_time
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(1) "1"

# 空の値を渡すと設定ディレクティブに""を設定します
php -d max_execution_time=
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(0) ""

# 設定ディレクティブは文字'='の後に指定したものを設定します
$  php -d max_execution_time=20
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(2) "20"
$  php
        -d max_execution_time=doesntmakesense
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(15) "doesntmakesense"
]]>
         </screen>
       </informalexample></para>
       </entry>
      </row>
      <row>
       <entry>-e</entry>
       <entry>--profile-info</entry>
       <entry>
        <para>
         デバッガ/プロファイラ用の拡張情報を出力します。
        </para>
       </entry>
      </row>
      <row>
       <entry>-f</entry>
       <entry>--file</entry>
       <entry>
        <para>
         <option>-f</option> オプションに指定したファイル名をパースし、
         実行します。このスイッチはオプションで省略することもできます。
         実行するスクリプトを指定するだけで充分です。
        </para>
       </entry>
      </row>
      <row>
       <entry>-h と -?</entry>
       <entry>--help と --usage</entry>
       <entry>
        このオプションを使用すると、実際の一連のコマンドラインオプションと
        各1行の説明が情報を取得できます。
       </entry>
      </row>
      <row>
       <entry>-i</entry>
       <entry>--info</entry>
       <entry>
        このコマンドラインオプションは、<function>phpinfo</function> をコールし、
        結果を出力します。PHP が正しく動作していない場合、
        <command>php -i</command> を実行し、情報テーブルの前または中に
        出力されるエラーメッセージを調べることをお勧めします。
        出力は、<literal>HTML</literal> 形式で行なわれるため、かなり
        量が多くなることに注意してください。
       </entry>
      </row>
      <row>
       <entry>-l</entry>
       <entry>--syntax-check</entry>
       <entry>
       <para>
         このオプションにより、指定した PHP コードの
         構文チェックのみを簡単に行なうことができます。成功した場合、
         テキスト
         <literal>No syntax errors detected in &lt;filename&gt;</literal>
         が標準出力に書き込まれ、リターンコードは <literal>0</literal>
         となります。失敗した場合、テキスト <literal>Errors parsing
          &lt;filename&gt;</literal> に加え、内部パーサエラーメッセージ
         が標準出力に書き込まれ、シェルリターンコードは、
         <literal>255</literal> となります。
        </para>
        <para>
         このオプションは、(未定義の関数のような)致命的なエラー(fatal error)
         はみつけません。致命的なエラーについても調べたい場合は、
         <option>-f</option> を使用してください。
        </para>
        <note>
         <para>
          このオプションは、オプション <option>-r</option> と共に使用することは
          できません。
         </para>
        </note>
       </entry>
      </row>
      <row>
       <entry>-m</entry>
       <entry>--modules</entry>
       <entry>
       <para><informalexample>
        <para>
         このオプションを使用すると、PHP に組み込まれた
         (そしてロードされた) Zend モジュールを出力します。
        </para>
         <screen>
<![CDATA[
$ php -m
[PHP Modules]
xml
tokenizer
standard
session
posix
pcre
overload
mysql
mbstring
ctype

[Zend Modules]
]]>
        </screen>
       </informalexample></para>
      </entry>
      </row>
      <row>
       <entry>-r</entry>
       <entry>--run</entry>
       <entry>
        <para>
         このオプションにより、コマンドラインのみで PHP
         の実行ができるようになります。
         PHP の開始および終了タグ
         (<literal>&lt;?php</literal> および <literal>?&gt;</literal>)
         は<emphasis role="strong">不要</emphasis>で、これらを付けると
         パーサエラーとなります。
        </para>
        <note>
         <para>
          このように PHP を実行する際に、コマンドラインの
          変数がシェルにより行なわれる置換と干渉しないように注意してください。
         </para>
        <informalexample>
         <para>
          パーサエラーを生じる例
         </para>
          <screen>
<![CDATA[
$ php -r "$foo = get_defined_constants();"
Command line code(1) : Parse error - parse error, unexpected '='
]]>
          </screen>
        </informalexample>
        <para>
          ここでの問題は、2 重引用符 <literal>"</literal> を用いた場合でも
          sh/bash が変数置換を行うことです。
          <varname>$foo</varname> はおそらく定義されていないので、
          空文字列に展開された後、実行用に PHP に
          そのコードが渡され、以下のように読み込むことになります。
        </para>
        <informalexample>
          <screen>
<![CDATA[
$ php -r " = get_defined_constants();"
]]>
          </screen>
         <para>
          正しい方法は、1 重引用符<literal>'</literal>を使用することです。
          1 重引用符で括られた文字列の中の変数は、sh/bash により展開されません。
         </para>
          <screen>
<![CDATA[
$ php -r '$foo = get_defined_constants(); var_dump($foo);'
array(370) {
  ["E_ERROR"]=>
  int(1)
  ["E_WARNING"]=>
  int(2)
  ["E_PARSE"]=>
  int(4)
  ["E_NOTICE"]=>
  int(8)
  ["E_CORE_ERROR"]=>
  [...]
]]>
          </screen>
        </informalexample>
        <para>
          sh/bash 以外のシェルを使用している場合には、別の問題を経験したことが
          あるかもしれません。バグを
          <ulink url="&url.php.bugs;">&url.php.bugs;</ulink>
          に報告してください。
          シェル変数をコードに取得しようとしたり、エスケープを行なうために
          バックスラッシュを使用したりした場合にも、容易に問題を発生する
          可能性があります。注意が必要です。
         </para>
        </note>
       <note>
        <para>
         <option>-r</option> は <emphasis>CLI</emphasis>
         SAPI で有効で、<emphasis>CGI</emphasis> SAPI では使用できません。
        </para>
       </note>
       <note>
        <para>
         このオプションはあくまで基本的な機能を提供するものです。そのため、
         いくつかの設定ディレクティブ（例: <link
         linkend="ini.auto-prepend-file">auto_prepend_file</link> および <link
         linkend="ini.auto-append-file">auto_append_file</link>）は
         このモードでは無視されます。
        </para>
       </note>
       </entry>
      </row>
     <row>
      <entry>-B</entry>
      <entry>--process-begin</entry>
      <entry>
       <para>
        標準入力を処理する前に実行する PHP コードを指定します。
        PHP 5 で追加されました。
       </para>
      </entry>
     </row>
     <row>
      <entry>-R</entry>
      <entry>--process-code</entry>
      <entry>
       <para>
        それぞれの入力行に対して実行する PHP コードを指定します。
        PHP 5 で追加されました。
       </para>
       <para>
        このモードには 2 つの特別な変数
        <varname>$argn</varname> と <varname>$argi</varname>
        が用意されています。
        <varname>$argn</varname> は PHP がその瞬間に処理している行を含み、
        <varname>$argi</varname> はその行番号を含んでいます。
       </para>
      </entry>
     </row>
     <row>
      <entry>-F</entry>
      <entry>--process-file</entry>
      <entry>
       <para>
        全ての入力行に対して実行する PHP ファイルを指定します。
        PHP 5 で追加されました。
       </para>
      </entry>
     </row>
     <row>
      <entry>-E</entry>
      <entry>--process-end</entry>
      <entry>
       <para>
        入力を処理した後に実行する PHP コードを指定します。
        PHP 5 で追加されました。
       </para>
       <para><example>
        <title>
         とあるプロジェクトの行数をカウントするための
         <option>-B</option>, <option>-R</option> そして <option>-E</option>
         オプションの使用例
        </title>
        <screen>
<![CDATA[
$ find my_proj | php -B '$l=0;' -R '$l += count(@file($argn));' -E 'echo "Total Lines: $l\n";'
Total Lines: 37328
]]>
        </screen>
        </example></para>
      </entry>
     </row>
      <row>
       <entry>-s</entry>
       <entry>--syntax-highlight と --syntax-highlight</entry>
       <entry>
        <para>
         カラー構文ハイライト表示されたソースを表示します。
        </para>
       <para>
         このオプションは、ファイルをパースし、<literal>HTML</literal>
         ハイライト表示版のファイルを生成し、標準出力に書き出す内部機
         構を使用します。行うのは
         <literal>&lt;code&gt; [...] &lt;/code&gt;</literal> のブロックを
         生成することだけで、<literal>HTML</literal> ヘッダは
         出力されないことに注意してください。
        </para>
        <note>
         <para>
          このオプションは、<option>-r</option> オプションと同時に
          使用することはできません。
        </para>
        </note>
       </entry>
      </row>
      <row>
       <entry>-v</entry>
       <entry>--version</entry>
       <entry>
       <para><informalexample>
        <para>
         PHP, PHP SAPI, Zend のバージョンを標準出力に出力します。例：
        </para>
         <screen>
<![CDATA[
$ php -v
PHP 4.3.0 (cli), Copyright (c) 1997-2002 The PHP Group
Zend Engine v1.3.0, Copyright (c) 1998-2002 Zend Technologies
]]>
         </screen>
       </informalexample></para>
       </entry>
      </row>
      <row>
       <entry>-w</entry>
       <entry>--strip</entry>
       <entry>
        <para>
         コメントと空白文字を削除してソースを表示します。
        </para>
       <note>
         <para>
          このオプションは、<option>-r</option> オプションと同時に
          使用することはできません。
         </para>
        </note>
       </entry>
      </row>
      <row>
       <entry>-z</entry>
       <entry>--zend-extension</entry>
       <entry>
        <para>
         Zend エクステンションをロードします。ファイル名のみが指定された場合、
         PHP はこの拡張をカレントのシステムのデフォルトライブラリパスから
         ロードしようとします
         (Linux システムの場合は <filename>/etc/ld.so.conf</filename> で
         指定されています)。
         ファイル名を絶対パスで指定した場合、システムのライブラリサーチパスを
         使用しません。ディレクトリ情報を有する相対ファイル名を
         指定すると、PHP は
         カレントのディレクトリの相対パスから拡張モジュールをロードする
         ことのみを行ないます。
       </para>
      </entry>
     </row>
     <row>
      <entry>--rf</entry>
      <entry>--rfunction</entry>
      <entry>
       <para>
        指定した関数あるいはクラスメソッドについての情報
        (たとえばパラメータの数と名前など) を表示します。
        PHP 5.1.2 以降で使用可能です。
       </para>
       <para>
        <example>
         <title>基本的な <literal>--rf</literal> の使用法</title>
         <programlisting role="shell">
<![CDATA[
$ php --rf var_dump
Function [ <internal> public function var_dump ] {

  - Parameters [2] {
    Parameter #0 [ <required> $var ]
    Parameter #1 [ <optional> $... ]
  }
}
]]>
         </programlisting>
        </example>
       </para>
      </entry>
     </row>
     <row>
      <entry>--rc</entry>
      <entry>--rclass</entry>
      <entry>
       <para>
        指定したクラスについての情報 (定数、プロパティおよびメソッドの一覧)
        を表示します。PHP 5.1.2 以降で使用可能です。
       </para>
      </entry>
     </row>
     <row>
      <entry>--re</entry>
      <entry>--rextension</entry>
      <entry>
       <para>
        指定した拡張モジュールについての情報 (&php.ini; オプション、
        定義されている関数、定数およびクラスの一覧) を表示します。
        PHP 5.1.2 以降で使用可能です。
       </para>
      </entry>
     </row>
     <row>
      <entry>-ri</entry>
      <entry>--rextinfo</entry>
      <entry>
       <para>
        指定した拡張モジュールについての設定情報 (<function>phpinfo</function>
        が返す情報と同じもの) を表示します。
        PHP 5.2.2 以降で使用可能です。
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>
  <para>
   PHP 実行バイナリは、Web サーバから完全に独立して PHP スクリプトを
   実行するために使用することができます。Unix システムを使用している場合、
   実行可能とするためには PHP スクリプトの先頭に特別な一行を追加する必要が
   あります。これにより、システムがそのスクリプトを実行するプログラムを
   知ることができます。
   Windows 環境では、<literal>.php</literal> ファイルのダブルクリック
   オプションに <filename>php.exe</filename> を関連づけることができます。
   または、PHP によりスクリプトを実行するバッチファイルを作成することも
   可能です。Unix 上で動作させるためにスクリプトに追加された先頭行は、
   Windows 環境での動作に悪影響を与えません。このため、この手法により、
   クロスプラットフォーム環境で動作するプログラムを書くことができます。
   コマンドライン PHP プログラムの書方の簡単な例を以下に示します。
  </para>
  <example>
   <title>
    コマンドラインから実行されることを意図したスクリプト(script.php)
   </title>
  <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php

if ($argc != 2 || in_array($argv[1], array('--help', '-help', '-h', '-?'))) {
?>

これは、ひとつのオプションをとるコマンドラインの PHP スクリプトです。

  使用法:
  <?php echo $argv[0]; ?> <option>

  <option> は出力したい単語です。
  --help, -help, -h, あるいは -? を指定すると、
  このヘルプが表示されます。

<?php
} else {
    echo $argv[1];
}
?>
]]>
   </programlisting>
  </example>
  <para>
   上のスクリプトでは、特殊な先頭行が用いられており、このファイルが
   PHP により実行されることを示しています。ここでは CLI 版を使用しているため、
   HTTP ヘッダは出力されません。PHP で
   コマンドラインアプリケーションを使用する際には、2 つの変数
   <varname>$argc</varname> および <varname>$argv</varname> を使用することが
   できます。
   最初の変数は、引数の数に 1 (実行中のスクリプトの名前)を加えたものです。
   2 番目の変数は、引数を保持する配列で、スクリプト名を有する
   要素 0 (<varname>$argv[0]</varname>) から始まっています。
  </para>
  <para>
   上のプログラムでは、引数が 1 より少ないかまたは多いかを調べています。
   また、引数が <option>--help</option>, <option>-help</option>,
   <option>-h</option> または <option>-?</option> の場合、
   ヘルプメッセージを出力し、動的にスクリプト名を出力します。
   他の引数を受け取った場合、これを出力します。
  </para>
  <para>
   上のスクリプトを Unix で実行する場合、実行可能とした後、
   <command>script.php echothis</command> または
   <command>script.php -h</command> とする必要があります。
   Windows では、この処理を行なう以下のようなバッチファイルを作成することが
   できます。
  </para>
  <example>
   <title>
    コマンドライン PHP スクリプトを実行するバッチファイル(script.bat)
   </title>
   <programlisting role="shell">
<![CDATA[
@C:\php\php.exe script.php %1 %2 %3 %4
]]>
   </programlisting>
  </example>
  <para>
   上のプログラムが <filename>script.php</filename> という名前であるとし、
   <filename>c:\php\php.exe</filename> に <filename>php.exe</filename>
   があるとすると、このバッチファイルは、追加オプション
   <command>script.bat echothis</command> または
   <command>script.bat -h</command>
   を指定して、スクリプトを実行します。
  </para>
  <para>
   PHP のコマンドラインアプリケーションを拡張するために使用できる
   その他の関数については、拡張モジュール
   <link linkend="ref.readline">Readline</link> に関する
   ドキュメントも参照してください。
  </para>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
