<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.7 $ -->
<!-- EN-Revision: 1.38 Maintainer: hirokawa Status: ready -->
 <chapter id="features.commandline">
  <title>PHPをコマンドラインから使用する</title>
  <!-- NEW DOCUMENTATION STARTS -->
  <para>
   4.3以降でPHPは
   <emphasis>Command Line Interface</emphasis>を意味する
   <literal>CLI</literal>という名前の新しい<literal>SAPI</literal>型
   (Server Application Programming Interface)をサポートします。
   名前から分かるように、この<literal>SAPI</literal>型は、
   PHPによるシェル(またはデスクトップ)アプリケーショ
   ンの開発を主な対象としています。
   <literal>CLI SAPI</literal>と他の<literal>SAPI</literal>の間には、
   いくつかの違いがあります。本章では、これらについて詳細を説明します。
   <literal>CLI</literal>と<literal>CGI</literal>はその振る舞いの多くが
   共通であるにもかかわらず、違うSAPIであることに留意してください。
  </para>
  <para>
   <literal>CLI SAPI</literal>は、当初PHP 4.2.0でリリースされましたが、
   この時点では実験的なステータスにあったため、
   <literal>./configure</literal>を実行する際に、明示的に
   <option role="configure">--enable-cli</option>を指定することにより、
   有効とする必要がありました。PHP 4.3.0以降、
   <literal>CLI SAPI</literal>はもはや実験的なステータスではなくなり、
   <option role="configure">--enable-cli</option> はデフォルトでオンとなりました。
   <option role="configure">--disable-cli</option> によりこれを無効とする
   ことも可能です。
  </para>
  <para>
   PHP4.3.0以降、システムにPHPがどのようにインストールされているかによって
   CLI/CGIバイナリの名前、位置、存在が異なります。デフォルトでは
   <command>make</command>を実行するとCGIとCLIの両方がビルドされ
   ソースディレクトリの<filename>sapi/cgi/php</filename>と
   <filename>sapi/cli/php</filename>にそれぞれ配置されます。両方とも
   php という名前であることに注意してください
   <command>make install</command>でどうなるかはconfigureに因ります。
   configureで例えばapxsのようなSAPIモジュールが選択された場合、または
   <option role="configure">--disable-cgi</option> が指定された場合、
   <command>make install</command>によってCLIが<filename>{PREFIX}/bin/php</filename>
   にコピーされます。さもなければCGIがそこにコピーされます。
   既にインストールされているCGIバイナリを上書きしたい場合には、
   <command>make install</command>の後に<command>make install-cli</command>
   を実行してください。あるいはconfigureで
   <option role="configure">--disable-cgi</option> を指定することもできます。
  </para>
  <para>
   <note>
    <para>
     <option role="configure">--enable-cli</option>
     と<option role="configure">--enable-cgi</option> の両方が
     デフォルトで有効になっているため、configureで
     <option role="configure">--enable-cli</option>
     をconfigureで指定しなくても必然的に<command>make install</command>で
     CLIが<filename>{PREFIX}/bin/php</filename>としてコピーされます。
    </para>
   </note>
  </para>
  <para>
   PHP4.2.0からPHP4.2.3までのWindowsパッケージではCLIは
   CGI <filename>php.exe</filename>と同じフォルダに
   <filename>php-cli.exe</filename>として配布されていました。
   PHP4.3.0からはWindowsパッケージではCLIは
   <filename class="directory">cli</filename> という
   別のフォルダに<filename>php.exe</filename>として配布されます。
   したがって<literal>cli/php.exe</literal>となります。
   Starting with PHP 5, the CLI is distributed in the main folder,
   named  <filename>php.exe</filename>. The CGI version is distributed as
   <filename>php-cgi.exe</filename>.
  </para>
  <para>
   As of PHP 5, a new <filename>php-win.exe</filename> file is distributed.
   This is equal to the CLI version, except that php-win doesn't output
   anything and thus provides no console (no "dos box" appears on the screen).
   This  behavior is similar to php-gtk. You should configure with
   <option role="configure">--enable-cli-win32</option>.
  </para>
  <para>
   <note>
    <title>自分のSAPIは何か?</title>
    <para>
     シェルで <command>php -v</command> をタイプすると、
     <filename>php</filename> がCGIなのかCLIなのかわかります。
     <function>php_sapi_name</function>と定数<constant>PHP_SAPI</constant>
     も参照してください。
    </para>
   </note>
  </para>
  <para>
   <note>
    <para>
     Unixの<literal>man</literal>ualページがPHP4.3.2で追加されました。
     シェル環境から <command>man php</command> とすることで見ることができます。
    </para>
   </note>
  </para>
  <para>
   <literal>CLI SAPI</literal>を他の<literal>SAPI</literal>と比べた時
   の大きな違いを以下に示します。
   <itemizedlist>
    <listitem>
     <para>
      <literal>CGI SAPI</literal>と異なり、ヘッダが出力されません。
     </para>
     <para>
      <literal>CGI SAPI</literal>は、HTTPヘッダの出力を抑制する機能を
      提供していますが、等価な機能は<literal>CLI SAPI</literal>ではサ
      ポートされていません。
     </para>
    <para>
     デフォルトではCLIは静寂モードで起動されます。古いCGIスクリプトと互換性を
     保って使えるように<option>-q</option> スイッチが残されています。
    </para>
    <para>
     動作するディレクトリはスクリプトの場所に変更されることはありません。
     (<option>-C</option>および<option>--no-chdir</option>スイッチは
      互換性のために残されています)
    </para>
    <para>
     エラーメッセージはプレーンテキストで表示されます。
     （HTMLでフォーマットされません）
    </para>
    </listitem>
    <listitem>
     <para>
      以下に示すいくつかの&php.ini;ディレクティブは、<literal>CLI
      SAPI</literal>により上書きされます。これは、シェル環境では意味が
      ないためです。
      <table>
       <title>上書きされる&php.ini;のディレクティブ</title>
       <tgroup cols="3">
        <thead>
         <row>
          <entry>ディレクティブ</entry>
          <entry><literal>CLI SAPI</literal>のデフォルト値</entry>
          <entry>コメント</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><link linkend="ini.html-errors">html_errors</link></entry>
          <entry>&false;</entry>
          <entry>
           エラーメッセージに含まれる<literal>HTML</literal>タグはシェ
           ル上では意味がなく、可読性をかなり低下させるため、このディ
           レクティブはデフォルトで&false;となっています。
          </entry>
         </row>
         <row>
          <entry><link linkend="ini.implicit-flush">implicit_flush</link></entry>
          <entry>&true;</entry>
          <entry>
           <function>print</function>, <function>echo</function>および
           関連するものによる全ての出力は、直ちに出力され、バッファに
           キャッシュされないことが望ましいと言えます。この場合でも、
           標準出力を保留または操作したい場合には、
           <link linkend="ref.outcontrol">output buffering</link>を使
           用することが可能です。
          </entry>
         </row>
         <row>
          <entry><link linkend="ini.max-execution-time">max_execution_time</link></entry>
          <entry>0 (unlimited)</entry>
          <entry>
           シェル環境では、PHPを際限なく使用できる
           ようにするために、最大実行時間の制限は無しに設定されていま
           す。Web用アプリケーションは数秒単位で実行されるよう作られて
           いますが、シェルアプリケーションの実行時間は、これよりかな
           り長くなる傾向があります。
          </entry>
         </row>
         <row>
          <entry><link linkend="ini.register-argc-argv">register_argc_argv</link></entry>
          <entry>&true;</entry>
          <entry>
          <para>
           <literal>CLI SAPI</literal>を使用している場合、グローバル
           PHP変数<literal>$argc</literal>
           (アプリケーションに渡される引数の数)と
           <literal>$argv</literal> (引数の値の配列)は常に登録され、
           適切な値が代入されます。
          </para>
          <para>
           PHP4.3.0以降、<literal>CLI SAPI</literal>を使用するときに
           PHPの<varname>$argc</varname>変数と
           <varname>$argv</varname>変数が登録され、適切な値がセットされます。
           このバージョンより前では、<literal>CGI</literal>や
           <literal>MODULE</literal>がこれらの変数を生成するにはPHPの
           <link linkend="ini.register-globals">register_globals</link>
           ディレクティブがオンになっている必要がありました。
           バージョンやregister_globalsの設定がどうであろうと、
           <link linkend="reserved.variables.server">$_SERVER</link>または
           <varname>$HTTP_SERVER_VARS</varname>は常に使用可能です。
           例：<varname>$_SERVER['argv']</varname>
          </para>
          </entry>
         </row>
        </tbody>
       </tgroup>
      </table>
     </para>
     <note>
      <para>
       これらのディレクティブは、設定ファイル&php.ini;またはカスタム設
       定ファイル(指定した場合のみ)で他の値に初期化できません。この制
       限は、これらのデフォルト値が全ての設定ファイルをパースした後に
       適用されるためです。しかし、これらの値は実行時に変更することが
       可能です。
       (上記のディレクティブの全てについてこれが当てはまるわけではあり
       ません。例えば、<link
       linkend="ini.register-argc-argv">register_argc_argv</link>)
      </para>
     </note>
    </listitem>
    <listitem>
     <para>
      シェル環境での動作を容易とするために、以下の定数が定義されていま
      す。
      <table>
       <title>CLI固有の定数</title>
       <tgroup cols="2">
        <thead>
         <row>
          <entry>定数</entry>
          <entry>説明</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><constant>STDIN</constant></entry>
          <entry>
           <literal>stdin</literal>へのオープン済みのストリーム。これ
           により、以下のようにオープンする必要がなくなります。
           <programlisting role="php">
<![CDATA[
<?php

$stdin = fopen('php://stdin', 'r');

?>
]]>
           </programlisting>
           <literal>stdin</literal>から1行読み込みたい場合、以下のようにします。
           <programlisting role="php">
<![CDATA[
<?php
$line = trim(fgets(STDIN)); // reads one line from STDIN
fscanf(STDIN, "%d\n", $number); // reads number from STDIN
?>
]]>
           </programlisting>
          </entry>
         </row>
         <row>
          <entry><constant>STDOUT</constant></entry>
          <entry>
           <literal>stdout</literal>へのオープン済みのストリーム。これ
           により、以下のようにオープンする必要がなくなります。
           <programlisting role="php">
<![CDATA[
<?php

$stdout = fopen('php://stdout', 'w');

?>
]]>
           </programlisting>
          </entry>
         </row>
         <row>
          <entry><constant>STDERR</constant></entry>
          <entry>
           <literal>stderr</literal>へのオープン済みのストリーム。これ
           により、以下のようにオープンする必要がなくなります。
           <programlisting role="php">
<![CDATA[
<?php

$stderr = fopen('php://stderr', 'w');

?>
]]>
           </programlisting>
          </entry>
         </row>
        </tbody>
       </tgroup>
      </table>
     </para>
     <para>
      上記のように、<literal>stderr</literal>のようなストリームを自分
      でオープンする必要はなく、以下のようにストリームリソースの代わり
      に定数を使用するだけでかまいません。
     <programlisting role="shell">
<![CDATA[
php -r 'fwrite(STDERR, "stderr\n");'
]]>
     </programlisting>
      これらのストリームを明示的に閉じる必要はありません。これは、
      PHPにより自動的に行われます。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>CLI SAPI</literal>は、実行されるスクリプトのディレクト
      リにカレントディレクトリを変更<emphasis role="strong">しません
      </emphasis>!
    </para>
    <para>
      <literal>CGI SAPI</literal>との違いを示す例を以下に示します。
      <programlisting role="php">
<![CDATA[
<?php
// Our simple test application
echo getcwd(), "\n";
?>
]]>
      </programlisting>
     </para>
     <para>
      <literal>CGI</literal>版により実行した場合、出力は以下のようにな
      ります。
     <screen>
<![CDATA[
$ pwd
/tmp

$ php-cgi -f another_directory/test.php
/tmp/another_directory
]]>
     </screen>
      これは、PHPが実行するスクリプトのディレクトリ
      にカレントディレクトリを変更することを明らかに示しています。
     </para>
     <para>
      <literal>CLI SAPI</literal>を使用した場合の出力は次のようになり
      ます。
     <screen>
<![CDATA[
$ pwd
/tmp

$ php -f another_directory/test.php
/tmp
]]>
      </screen>
      これにより、PHPでシェルツールを書く際の柔軟性
      をより大きくすることができます。
     </para>
     <note>
      <para>
       <literal>CGI SAPI</literal>は、この<literal>CLI SAPI</literal>
       の動作をコマンドライン実行時のスイッチ<literal>-C</literal>によ
       りサポートしています。
      </para>
    </note>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   PHPバイナリにより提供されるコマンドラインオプショ
   ンの一覧は、<option>-h</option> スイッチを指定して
   PHPを実行することによりいつでも調べることができます。
   <screen>
<![CDATA[
Usage: php [options] [-f] <file> [args...]
       php [options] -r <code> [args...]
       php [options] [-- args...]
  -s               Display colour syntax highlighted source.
  -w               Display source with stripped comments and whitespace.
  -f <file>        Parse <file>.
  -v               Version number
  -c <path>|<file> Look for php.ini file in this directory
  -a               Run interactively
  -d foo[=bar]     Define INI entry foo with value 'bar'
  -e               Generate extended information for debugger/profiler
  -z <file>        Load Zend extension <file>.
  -l               Syntax check only (lint)
  -m               Show compiled in modules
  -i               PHP information
  -r <code>        Run PHP <code> without using script tags <?..?>
  -h               This help

  args...          Arguments passed to script. Use -- args when first argument 
                   starts with - or script is read from stdin
]]>
   </screen>
  </para>
  <para>
   <literal>CLI SAPI</literal>は、実行するPHPコード
   を取得するために三種類の異なる手段をサポートしています。
   <orderedlist>
   <listitem>
     <para>
      PHPに特定のファイルの実行を指示する。
     </para>
     <para>
      <screen>
<![CDATA[
php my_script.php

php -f my_script.php
]]>
      </screen>
      上記の方法は共に(<option>-f</option>スイッチの使用の如何に関ら
      ず)指定したファイル<filename>my_script.php</filename>を実行しま
      す。実行ファイルとしてあらゆるファイルを指定することができ、
      PHPスクリプトは拡張子
      <literal>.php</literal> で終わる必要がなく、任意の名前や拡張子
      を使用することができます。
     </para>
    </listitem>
    <listitem>
     <para>
      実行するPHPコードをコマンドラインで直接指定する。
     </para>
     <para>
      <screen>
<![CDATA[
php -r 'print_r(get_defined_constants());'
]]>
      </screen>
      シェル変数の置換と引用符の使用については特に注意して下さい。
     </para>
     <note>
      <para>
       この例をよくみて下さい。開始/終了タグがありません! 
       <option>-r</option>スイッチを使用した場合、これらのタグは不要
       となります。これらのタグを使用するとパーサエラーを発生します。
      </para>
     </note>
    </listitem>
    <listitem>
     <para>
      実行するPHPコードを標準入力
      (<literal>stdin</literal>)で指定する。
     </para>
     <para>
      これは強力な機能で、以下の(仮想的な)例に示すように、動的に
      PHPコードを生成し、実行バイナリに入力すること
      ができます。
      <screen>
<![CDATA[
$ some_application | some_filter | php | sort -u >final_output.txt
]]>
      </screen>
     </para>
    </listitem>
  </orderedlist>
   これらのコードを実行する三種類の方法を組み合わせて使用することはで
   きません。
  </para>
  <para>
   他のシェルアプリケーションのように、PHPバイナリ
   に引数を指定することができるだけでなく、PHPスク
   リプトがこの引数を取得することも可能です。スクリプトに指定できる引
   数の数はPHPによる制限を受けません。
   (シェルは指定可能な文字数の最大値を設定しています。通常、この制限値
   を越えることはできません。) スクリプトに指定した引数は、グローバル
   配列 <varname>$argv</varname> でアクセス可能です。
   添字0は、常にスクリプト名が含まれています。
   ( PHPコードが標準入力またはコマンドラインスイッ
   チ<literal>-r</literal>により指定された場合、スクリプト名は
   <literal>-</literal>となります。)
   登録される第2のグローバル変数は <varname>$argc</varname> で、
   (スクリプトに指定された引数の数では<emphasis role="strong">なく
   </emphasis>、)配列 <varname>$argv</varname> の要素数が含まれます。
  </para>
  <para>
   スクリプトに指定する引数が文字<literal>-</literal>で始まっていない
   限り、特に留意すべきことはありません。スクリプトに指定する引数が文
   字<literal>-</literal>で始まる場合、PHP自体がこ
   れをパースする必要があるとみなすため、問題を発生します。
   これを防止するため、引数リストセパレータ<literal>--</literal>を使用
   して下さい。PHPにパースされる引数の後に
   このセパレータを置くと、その後の全ての引数はそのままパースされずに
   スクリプトに渡されます。
  </para>
  <screen>
<![CDATA[
# This will not execute the given code but will show the PHP usage
$ php -r 'var_dump($argv);' -h
Usage: php [options] [-f] <file> [args...]
[...]

# This will pass the '-h' argument to your script and prevent PHP from showing it's usage
$ php -r 'var_dump($argv);' -- -h
array(2) {
  [0]=>
  string(1) "-"
  [1]=>
  string(2) "-h"
}
]]>
  </screen>
  <para>
   また、PHPをシェルスクリプトとして使用する他の
   手段があります。最初の行が<literal>#!/usr/bin/php</literal>で始まり、
   PHPの開始/終了タグの中に通常の
   PHPコードが続くスクリプトを書き、適当なファイル
   実行属性を設定する(例: <command>chmod +x test</command>)ことが可能です。
   この方法は、通常のシェル/Perlスクリプトと同様に実行することができます。
   <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php
var_dump($argv);
?>
]]>
   </programlisting>
   このファイルの名前が<filename>test</filename>で、カレントディレクト
   リにあるとすると、以下のように実行することができます。
   <screen>
<![CDATA[
$ chmod +x test
$ ./test -h -- foo
array(4) {
  [0]=>
  string(6) "./test"
  [1]=>
  string(2) "-h"
  [2]=>
  string(2) "--"
  [3]=>
  string(3) "foo"
}
]]>
   </screen>
   見て分かるように、<literal>-</literal>で始まるスクリプトのパラメー
   タを指定する際に、特に注意する必要はありません。
  </para>
  <para>
   長いオプション指定は、PHP 4.3.3以降で利用可能です。
   <table>
    <title>コマンドラインオプション</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>オプション</entry>
       <entry>長いオプション</entry>
       <entry>説明</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>-s</entry>
       <entry>--syntax-highlight</entry>
       <entry>
        <para>
         カラー構文ハイライト表示されたソースを表示します。
        </para>
       <para>
         このオプションは、ファイルをパースし、<literal>HTML</literal>
         ハイライト表示版のファイルを生成し、標準出力に書き出す内部機
         構を使用します。行うのは、
         <literal>&lt;code&gt; [...] &lt;/code&gt;</literal>のブロック
         を生成することだけで、<literal>HTML</literal>ヘッダは出力され
         ないことに注意して下さい。
        </para>
        <note>
         <para>
          このオプションは、<option>-r</option>オプションと同時に使
          用することはできません。
        </para>
        </note>
       </entry>
      </row>
     <row>
      <entry>-s</entry>
      <entry>--syntax-highlighting</entry>
      <entry>
       <para>
        <option>--syntax-highlight</option>の別名
       </para>
      </entry>
     </row>
      <row>
       <entry>-w</entry>
       <entry>--strip</entry>
       <entry>
        <para>
         コメントと空白文字を削除してソースを表示します。
        </para>
       <note>
         <para>
          このオプションは、<option>-r</option> オプションと同時に使
          用することはできません。
         </para>
        </note>
       </entry>
      </row>
      <row>
       <entry>-f</entry>
       <entry>--file</entry>
       <entry>
        <para>
         <option>-f</option> オプションに指定したファイル名をパースし、
         実行します。このスイッチはオプションで省略することもできます。
         実行するスクリプトを指定するだけで充分です。
        </para>
       </entry>
      </row>
      <row>
       <entry>-v</entry>
       <entry>--version</entry>
       <entry>
        <para>
         PHP, PHP SAPI, Zendのバージョンを標準出力に出力します。例：
         <screen>
<![CDATA[
$ php -v
PHP 4.3.0 (cli), Copyright (c) 1997-2002 The PHP Group
Zend Engine v1.3.0, Copyright (c) 1998-2002 Zend Technologies
]]>
         </screen>
        </para>
       </entry>
      </row>
     <row>
       <entry>-c</entry>
       <entry>--php-ini</entry>
       <entry>
        <para>
         このオプションを使用することにより、&php.ini;を探すディレクト
         リを指定したり、カスタマイズされた<literal>INI</literal>ファ
         イル(&php.ini;という名前である必要はありません)を直接指定する
         ことが可能です。例：
         <screen>
<![CDATA[
$ php -c /custom/directory/ my_script.php

$ php -c /custom/directory/custom-file.ini my_script.php
]]>
         </screen>
         このオプションを指定しない場合、ファイルは、
         <link linkend="configuration.file">デフォルトの位置</link>
         で探索されます。
        </para>
       </entry>
      </row>
      <row>
       <entry>-n</entry>
       <entry>--no-php-ini</entry>
       <entry>
        <para>
         &php.ini; を完全に無視します。このスイッチは、PHP 4.3.0以降で
         利用可能です。
        </para>
       </entry>
      </row>
      <row>
       <entry>-d</entry>
       <entry>--define</entry>
       <entry>
        <para>
         このオプションにより &php.ini; で指定できる設定ディレクティブ
         にカスタム値を設定することができます。構文は以下のようになります。
         <screen>
<![CDATA[
-d configuration_directive[=value]
]]>
         </screen>
        </para>
        <para>
         例:
         <screen>
<![CDATA[
# 値の部分を省略すると、設定ディレクティブに"1"を指定します
$ php -d max_execution_time
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(1) "1"

# 空の値を渡すと設定ディレクティブに""を設定します
php -d max_execution_time=
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(0) ""

# 設定ディレクティブは文字'='の後に指定したものを設定します
$  php -d max_execution_time=20
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(2) "20"
$  php
        -d max_execution_time=doesntmakesense
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(15) "doesntmakesense"
]]>
         </screen>
        </para>
       </entry>
      </row>
      <row>
       <entry>-a</entry>
       <entry>--interactive</entry>
       <entry>
        <para>
         PHPを対話的に実行します。
         <!-- 
         mfischer, 20020510: Couldn't come up with a decent useful description
         of the current implementation of the interactive mode.
         -->
        </para>
       </entry>
      </row>
      <row>
       <entry>-e</entry>
       <entry>--profile-info</entry>
       <entry>
        <para>
         デバッガ/プロファイラ用の拡張情報を出力します。
       <!-- 
        mfischer, 20020510: Anyone who can provide more information what it
        really does (even if it's only for developers) ?
        -->
        </para>
       </entry>
      </row>
      <row>
       <entry>-z</entry>
       <entry>--zend-extension</entry>
       <entry>
        <para>
         Zendエクステンションをロードします。ファイル名のみが指定された場合、
         PHPはこの拡張をカレントのシステムのデフォルトライブラリパスから
         ロードしようとします。
         (Linuxシステムの場合は<filename>/etc/ld.so.conf</filename>で
         指定されています)
         ファイル名を絶対パスで指定した場合、システムのライブラリサーチパスを
         使用しません。ディレクトリ情報を有する相対ファイル名を
         指定すると、PHPは、
         カレントのディレクトリの相対パスから拡張モジュールをロードする
         ことのみを行ないます。
        </para>
       </entry>
      </row>
      <row>
       <entry>-l</entry>
       <entry>--syntax-check</entry>
       <entry>
       <para>
         このオプションにより、指定したPHPコードの
         構文チェックのみを簡単に行なうことができます。成功した場合、
         テキスト
         <literal>No syntax errors detected in &lt;filename&gt;</literal>
         が、標準出力に書き込まれ、リターンコードは<literal>0</literal>
         となります。失敗した場合、テキスト <literal>Errors parsing
          &lt;filename&gt;</literal> に加えて、内部パーサエラーメッセージ
         が標準出力に書き込まれ、シェルリターンコードは、
         <literal>255</literal>となります。
        </para>
        <para>
         このオプションは、(未定義の関数のような)致命的なエラー(fatal error)
         はみつけません。致命的なエラーについても調べたい場合は、
         <option>-f</option> を使用してください。
        </para>
        <note>
         <para>
          このオプションは、オプション <option>-r</option> と共に使用することは
          できません。
         </para>
        </note>
       </entry>
      </row>
     <row>
       <entry>-m</entry>
       <entry>--modules</entry>
       <entry>
        <para>
         このオプションを使用すると、PHPは、PHPに組み込まれた
         (そしてロードされた) Zend モジュールを出力します。
         <screen>
<![CDATA[
$ php -m
[PHP Modules]
xml
tokenizer
standard
session
posix
pcre
overload
mysql
mbstring
ctype

[Zend Modules]
]]>
         </screen>
        </para>
       </entry>
      </row>
      <row>
       <entry>-i</entry>
       <entry>--info</entry>
       <entry>
        このコマンドラインオプションは、<function>phpinfo</function>をコールし、
        結果を出力します。PHP が正しく動作していない場合、
        <command>php -i</command> を実行し、情報テーブルの前または中に出力
        されるエラーメッセージを調べることをお勧めします。
        出力は、<literal>HTML</literal> 形式で行なわれるため、かなり量が
        多くなることに注意して下さい。
       </entry>
      </row>
      <row>
       <entry>-r</entry>
       <entry>--run</entry>
       <entry>
        <para>
         このオプションにより、コマンドラインのみでPHP
         の実行ができるようになります。
         PHPの開始および終了タグ
         (<literal>&lt;?php</literal> および <literal>?&gt;</literal>)
         は<emphasis role="strong">不要</emphasis>で、これらを付けると
         パーサエラーとなります。
        </para>
        <note>
         <para>
          このようにPHPを実行する際に、コマンドラインの
          変数がシェルにより行なわれる置換と干渉しないように注意して下さい。
         </para>
         <para>
          パーサエラーを生じる例
          <screen>
<![CDATA[
$ php -r "$foo = get_defined_constants();"
Command line code(1) : Parse error - parse error, unexpected '='
]]>
          </screen>
          ここでの問題は、2重引用符 <literal>"</literal> を用いた場合でも
          sh/bashが変数置換を行うことです。
          <varname>$foo</varname> はおそらく定義されていないので、
          空文字列に展開された後、実行用にPHPに
          そのコードが渡され、以下のように読み込むことになります。
          <screen>
<![CDATA[
$ php -r " = get_defined_constants();"
]]>
          </screen>
          正しい方法は、1重引用符<literal>'</literal>を使用することです。
          1重引用符で括られた文字列の中の変数は、sh/bashにより展開されません。
          <screen>
<![CDATA[
$ php -r '$foo = get_defined_constants(); var_dump($foo);'
array(370) {
  ["E_ERROR"]=>
  int(1)
  ["E_WARNING"]=>
  int(2)
  ["E_PARSE"]=>
  int(4)
  ["E_NOTICE"]=>
  int(8)
  ["E_CORE_ERROR"]=>
  [...]
]]>
          </screen>
          sh/bash以外のシェルを使用している場合には、別の問題を経験したことが
          あるかもしれません。バグレポートを
          <ulink url="&url.php.bugs;">&url.php.bugs;</ulink> に報告するか、
           &email.php.doc; にメールを送ってください。
          シェル変数をコードに取得しようとしたり、エスケープを行なうために
          バックスラッシュを使用したりした場合にも、容易に問題を発生する
          可能性があります。注意が必要です。
         </para>
        </note>
       </entry>
      </row>
      <row>
       <entry>-h</entry>
       <entry>--help</entry>
       <entry>
        このオプションを使用すると、実際の一連のコマンドラインオプションと
        各1行の説明が情報を取得できます。
       </entry>
      </row>
      <row>
       <entry>-?</entry>
       <entry>--usage</entry>
       <entry>
        <option>--help</option>の別名
       </entry>
      </row>
     <!--
     new, not in PHP 4.3.4, but are in php_cli.c 1.102 or cgi_main.c 1.243
     -b <address:port>|<port> bindpath Bind Path for external FASTCGI Server mode, only CGI, no Windows
     -B <begin_code>     process-begin Run PHP <begin_code> before processing input lines
     -R <code>           process-code  Run PHP <code> for every input line
     -F <file>           process-file  Parse and execute <file> for every input line
     -E <end_code>       process-end   Run PHP <end_code> after processing all input lines
     -H                  hide-args     Hide any passed arguments from external tools.
     -g                  global        Define global variables on command line
     -->
     </tbody>
    </tgroup>
   </table>
  </para>
  <!-- NEW DOCUMENTATION ENDS -->
  <para>
   PHP実行バイナリは、Webサーバから完全に独立してPHPスクリプトを実行す
   るために使用することができます。Unixシステムを使用している場合、実
   行可能とするために、PHPスクリプトの先頭に特別な一行を追加する必要が
   あります。これにより、システムがそのスクリプトを実行するプログラム
   を知ることができます。
   Windows環境では、<literal>.php</literal>ファイルのダブルクリックオ
   プションに <filename>php.exe</filename> を関連づけることができます。
   または、PHPによりスクリプトを実行するバッチファイルを作成することも
   可能です。Unix上で動作させるためにスクリプトに追加された先頭行は、
   Windows環境での動作に悪影響を与えません。このため、この手法により、
   黒須プラットフォーム環境で動作するプログラムを書くことができます。
   コマンドラインPHPプログラムの書方の簡単な例を以下に示します。
  </para>
  <example>
   <title>
    コマンドラインから実行されることを意図したスクリプト(script.php)
   </title>
  <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php

if ($argc != 2 || in_array($argv[1], array('--help', '-help', '-h', '-?'))) {
?>

This is a command line PHP script with one option.

  Usage:
  <?php echo $argv[0]; ?> <option>

  <option> can be some word you would like
  to print out. With the --help, -help, -h,
  or -? options, you can get this help.

<?php
} else {
    echo $argv[1];
}
?>
]]>
   </programlisting>
  </example>
  <para>
   上のスクリプトでは、特殊な先頭行が用いられており、このファイルが
   PHPにより実行されることを示しています。ここではCLI版を使用しているため、
   HTTPヘッダは出力されません。PHPで
   コマンドラインアプリケーションを使用する際には、2つの変数
   <varname>$argc</varname> and <varname>$argv</varname> を使用することが
   できます。
   最初の変数は、引数の数に1(実行中のスクリプトの名前)を加えたものです。
   2番目の変数は、引数を保持する配列で、スクリプト名を有する
   要素0(<varname>$argv[0]</varname>)から始まっています。
  </para>
  <para>
   上のプログラムでは、引数が1より少ないかまたは多いかを調べています。
   また、引数が <option>--help</option>, <option>-help</option>,
   <option>-h</option> または <option>-?</option>の場合、
   ヘルプメッセージを出力し、動的にスクリプト名を出力します。
   他の引数を受け取った場合、これを出力します。
  </para>
  <para>
   上のスクリプトをUnixで実行する場合、実行可能とした後、
   <command>script.php echothis</command> または
   <command>script.php -h</command> とする必要があります。
   Windowsでは、この処理を行なう以下のようなバッチファイルを作成することが
   できます。
  </para>
  <example>
   <title>
    コマンドラインPHPスクリプトを実行するバッチファイル(script.bat)
   </title>
   <programlisting role="shell">
<![CDATA[
@c:\php\cli\php.exe script.php %1 %2 %3 %4
]]>
   </programlisting>
  </example>
  <para>
   上のプログラムが<filename>script.php</filename>という名前であると
   し、<filename>c:\php\php.exe</filename>に<filename>php.exe</filename>
   があるとすると、このバッチファイルは、追加オプション
   <command>script.bat echothis</command> または
   <command>script.bat -h</command>
   を指定して、スクリプトを実行します。
  </para>
  <para>
   PHPのコマンドラインアプリケーションを拡張するために使用できる
   その他の関数については、拡張モジュール
   <link linkend="ref.readline">Readline</link>に関する
   ドキュメントも参照してください。
  </para>
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
