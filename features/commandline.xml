<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.4 $ -->
 <chapter id="features.commandline">
  <title>PHPをコマンドラインから使用する</title>
  <!-- NEW DOCUMENTATION STARTS -->
  <para>
   4.3以降で<literal>PHP</literal>は
   <emphasis>Command Line Interface</emphasis>を意味する
   <literal>CLI</literal>という名前の新しい<literal>SAPI</literal>型
   (Server Application Programming Interface)をサポートします。
   名前から分かるように、この<literal>SAPI</literal>型は、
   <literal>PHP</literal>によるシェル(またはデスクトップ)アプリケーショ
   ンの開発を主な対象としています。
   <literal>CLI SAPI</literal>と他の<literal>SAPI</literal>の間には、
   いくつかの違いがあります。本章では、これらについて詳細を説明します。
  </para>
  <para>
   <literal>CLI SAPI</literal>は、当初<literal>PHP 4.2.0</literal>でリ
   リースされましたが、この時点では実験的なステータスにあったため、
   <literal>./configure</literal>を実行する際に、明示的に
   <literal>--enable-cli</literal>を指定することにより、有効とする必要
   がありました。<literal>PHP 4.3.0</literal>以降、
   <literal>CLI SAPI</literal>はもはや実験的なステータスではなくなりま
   した。このため、 <emphasis role="strong">常に</emphasis>構築され、
   <filename>php</filename>(Windowsでは<filename>php.exe</filename>と
   いう名前となります)バイナリとしてインストールされます。
  </para>
  <para>
   <literal>CLI SAPI</literal>を他の<literal>SAPI</literal>と比べた時
   の大きな違いを以下に示します。
   <itemizedlist>
    <listitem>
     <para>
      <literal>CGI SAPI</literal>と異なり、ヘッダが出力されません。
     </para>
     <para>
      <literal>CGI SAPI</literal>は、HTTPヘッダの出力を抑制する機能を
      提供していますが、等価な機能は<literal>CLI SAPI</literal>ではサ
      ポートされていません。
     </para>
    </listitem>
    <listitem>
     <para>
      以下に示すいくつかの&php.ini;ディレクティブは、<literal>CLI
      SAPI</literal>により上書きされます。これは、シェル環境では意味が
      ないためです。
      <table>
       <title>上書きされる&php.ini;のディレクティブ</title>
       <tgroup cols="3">
        <thead>
         <row>
          <entry>ディレクティブ</entry>
          <entry><literal>CLI SAPI</literal>のデフォルト値</entry>
          <entry>コメント</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><link linkend="ini.html-errors">html_errors</link></entry>
          <entry>&false;</entry>
          <entry>
           エラーメッセージに含まれる<literal>HTML</literal>タグはシェ
           ル上では意味がなく、可読性をかなり低下させるため、このディ
           レクティブはデフォルトで&false;となっています。
          </entry>
         </row>
         <row>
          <entry><link linkend="ini.implicit-flush">implicit_flush</link></entry>
          <entry>&true;</entry>
          <entry>
           <function>print</function>, <function>echo</function>および
           関連するものによる全ての出力は、直ちに出力され、バッファに
           キャッシュされないことが望ましいと言えます。この場合でも、
           標準出力を保留または操作したい場合には、
           <link linkend="ref.outcontrol">output buffering</link>を使
           用することが可能です。
          </entry>
         </row>
         <row>
          <entry><link linkend="ini.max-execution-time">max_execution_time</link></entry>
          <entry>0 (unlimited)</entry>
          <entry>
           シェル環境では、<literal>PHP</literal>を際限なく使用できる
           ようにするために、最大実行時間の制限は無しに設定されていま
           す。Web用アプリケーションは数秒単位で実行されるよう作られて
           いますが、シェルアプリケーションの実行時間は、これよりかな
           り長くなる傾向があります。
          </entry>
         </row>
         <row>
          <entry><link linkend="ini.register-argc-argv">register_argc_argv</link></entry>
          <entry>&true;</entry>
          <entry>
           <literal>CLI SAPI</literal>を使用している場合、グローバル
           <literal>PHP</literal>変数<literal>$argc</literal>
           (アプリケーションに渡される引数の数)と
           <literal>$argv</literal> (引数の値の配列)は常に登録され、
           適切な値が代入されます。
          </entry>
         </row>
        </tbody>
       </tgroup>
      </table>
     </para>
     <note>
      <para>
       これらのディレクティブは、設定ファイル&php.ini;またはカスタム設
       定ファイル(指定した場合のみ)で他の値に初期化できません。この制
       限は、これらのデフォルト値が全ての設定ファイルをパースした後に
       適用されるためです。しかし、これらの値は実行時に変更することが
       可能です。
       (上記のディレクティブの全てについてこれが当てはまるわけではあり
       ません。例えば、<link
       linkend="ini.register-argc-argv">register_argc_argv</link>)
      </para>
     </note>
    </listitem>
    <listitem>
     <para>
      シェル環境での動作を容易とするために、以下の定数が定義されていま
      す。
      <table>
       <title>CLI固有の定数</title>
       <tgroup cols="2">
        <thead>
         <row>
          <entry>定数</entry>
          <entry>説明</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><constant>STDIN</constant></entry>
          <entry>
           <literal>stdin</literal>へのオープン済みのストリーム。これ
           により、以下のようにオープンする必要がなくなります。
           <programlisting role="php">
$stdin = fopen('php://stdin', 'r');
           </programlisting>
          </entry>
         </row>
         <row>
          <entry><constant>STDOUT</constant></entry>
          <entry>
           <literal>stdout</literal>へのオープン済みのストリーム。これ
           により、以下のようにオープンする必要がなくなります。
           <programlisting role="php">
$stdout = fopen('php://stdout', 'w');
           </programlisting>
          </entry>
         </row>
         <row>
          <entry><constant>STDERR</constant></entry>
          <entry>
           <literal>stderr</literal>へのオープン済みのストリーム。これ
           により、以下のようにオープンする必要がなくなります。
           <programlisting role="php">
$stderr = fopen('php://stderr', 'w');
           </programlisting>
          </entry>
         </row>
        </tbody>
       </tgroup>
      </table>
     </para>
     <para>
      上記のように、<literal>stderr</literal>のようなストリームを自分
      でオープンする必要はなく、以下のようにストリームリソースの代わり
      に定数を使用するだけでかまいません。
     <programlisting role="php">
php -r 'fwrite(STDERR, "stderr\n");'
     </programlisting>
      これらのストリームを明示的に閉じる必要はありません。これは、
      <literal>PHP</literal>により自動的に行われます。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>CLI SAPI</literal>は、実行されるスクリプトのディレクト
      リにカレントディレクトリを変更<emphasis role="strong">しません
      </emphasis>!
    </para>
    <para>
      <literal>CGI SAPI</literal>との違いを示す例を以下に示します。
      <programlisting role="php">
<![CDATA[
<?php
    /* Our simple test application */
    echo getcwd(), "\n";
?>
]]>
      </programlisting>
     </para>
     <para>
      <literal>CGI</literal>版により実行した場合、出力は以下のようにな
      ります。
     <screen>
<![CDATA[
$ pwd
/tmp

$ php-cgi -f another_directory/test.php
/tmp/another_directory
]]>
     </screen>
      これは、<literal>PHP</literal>が実行するスクリプトのディレクトリ
      にカレントディレクトリを変更することを明らかに示しています。
     </para>
     <para>
      <literal>CLI SAPI</literal>を使用した場合の出力は次のようになり
      ます。
     <screen>
<![CDATA[
$ pwd
/tmp

$ php -f another_directory/test.php
/tmp
]]>
      </screen>
      これにより、<literal>PHP</literal>でシェルツールを書く際の柔軟性
      をより大きくすることができます。
     </para>
     <note>
      <para>
       <literal>CGI SAPI</literal>は、この<literal>CLI SAPI</literal>
       の動作をコマンドライン実行時のスイッチ<literal>-C</literal>によ
       りサポートしています。
      </para>
    </note>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   <literal>PHP</literal>バイナリにより提供されるコマンドラインオプショ
   ンの一覧は、<literal>-h</literal>スイッチを指定して
   <literal>PHP</literal>を実行することによりいつでも調べることができ
   ます。
   <screen>
<![CDATA[
Usage: php [options] [-f] <file> [args...]
       php [options] -r <code> [args...]
       php [options] [-- args...]
  -s               Display colour syntax highlighted source.
  -w               Display source with stripped comments and whitespace.
  -f <file>        Parse <file>.
  -v               Version number
  -c <path>|<file> Look for php.ini file in this directory
  -a               Run interactively
  -d foo[=bar]     Define INI entry foo with value 'bar'
  -e               Generate extended information for debugger/profiler
  -z <file>        Load Zend extension <file>.
  -l               Syntax check only (lint)
  -m               Show compiled in modules
  -i               PHP information
  -r <code>        Run PHP <code> without using script tags <?..?>
  -h               This help

  args...          Arguments passed to script. Use -- args when first argument 
                   starts with - or script is read from stdin
]]>
   </screen>
  </para>
  <para>
   <literal>CLI SAPI</literal>は、実行する<literal>PHP</literal>コード
   を取得するために三種類の異なる手段をサポートしています。
   <orderedlist>
   <listitem>
     <para>
      <literal>PHP</literal>に特定のファイルの実行を指示する。
     </para>
     <para>
      <screen>
<![CDATA[
php my_script.php

php -f my_script.php
]]>
      </screen>
      上記の方法は共に(<literal>-f</literal>スイッチの使用の如何に関ら
      ず)指定したファイル<filename>my_script.php</filename>を実行しま
      す。実行ファイルとしてあらゆるファイルを指定することができ、
      <literal>PHP</literal>スクリプトは拡張子
      <filename>.php</filename>で終わる必要がなく、任意の名前や拡張子
      を使用することができます。
     </para>
    </listitem>
    <listitem>
     <para>
      実行する<literal>PHP</literal>コードをコマンドラインで直接指定する。
     </para>
     <para>
      <screen>
<![CDATA[
php -r 'print_r(get_defined_constants());'
]]>
      </screen>
      シェル変数の置換と引用符の使用については特に注意して下さい。
     </para>
     <note>
      <para>
       この例をよくみて下さい。開始/終了タグがありません! 
       <literal>-r</literal>スイッチを使用した場合、これらのタグは不要
       となります。これらのタグを使用するとパーサエラーを発生します。
      </para>
     </note>
    </listitem>
    <listitem>
     <para>
      実行する<literal>PHP</literal>コードを標準入力
      (<literal>stdin</literal>)で指定する。
     </para>
     <para>
      これは強力な機能で、以下の(仮想的な)例に示すように、動的に
      <literal>PHP</literal>コードを生成し、実行バイナリに入力すること
      ができます。
      <screen>
<![CDATA[
$ some_application | some_filter | php | sort -u >final_output.txt
]]>
      </screen>
     </para>
    </listitem>
  </orderedlist>
   これらのコードを実行する三種類の方法を組み合わせて使用することはで
   きません。
  </para>
  <para>
   他のシェルアプリケーションのように、<literal>PHP</literal>バイナリ
   に引数を指定することができるだけでなく、<literal>PHP</literal>スク
   リプトがこの引数を取得することも可能です。スクリプトに指定できる引
   数の数は<literal>PHP</literal>による制限を受けません。
   (シェルは指定可能な文字数の最大値を設定しています。通常、この制限値
   を越えることはできません。) スクリプトに指定した引数は、グローバル
   配列<literal>$argv</literal>でアクセス可能です。
   添字0は、常にスクリプト名が含まれています。
   ( <literal>PHP</literal>コードが標準入力またはコマンドラインスイッ
   チ<literal>-r</literal>により指定された場合、スクリプト名は
   <literal>-</literal>となります。)
   登録される第2のグローバル変数は<literal>$argc</literal>で、
   (スクリプトに指定された引数の数では<emphasis role="strong">なく
   </emphasis>、)配列<literal>$argv</literal>の要素数が含まれます。
  </para>
  <para>
   スクリプトに指定する引数が文字<literal>-</literal>で始まっていない
   限り、特に留意すべきことはありません。スクリプトに指定する引数が文
   字<literal>-</literal>で始まる場合、<literal>PHP</literal>自体がこ
   れをパースする必要があるとみなすため、問題を発生します。
   これを防止するため、引数リストセパレータ<literal>--</literal>を使用
   して下さい。<literal>PHP</literal>にパースされる引数の後に
   このセパレータを置くと、その後の全ての引数はそのままパースされずに
   スクリプトに渡されます。
  </para>
  <screen>
<![CDATA[
# This will not execute the given code but will show the PHP usage
$ php -r 'var_dump($argv);' -h
Usage: php [options] [-f] <file> [args...]
[...]

# This will pass the '-h' argument to your script and prevent PHP from showing it's usage
$ php -r 'var_dump($argv);' -- -h
array(2) {
  [0]=>
  string(1) "-"
  [1]=>
  string(2) "-h"
}
]]>
  </screen>
  <para>
   また、<literal>PHP</literal>をシェルスクリプトとして使用する他の
   手段があります。最初の行が<literal>#!/usr/bin/php</literal>で始まり、
   <literal>PHP</literal>の開始/終了タグの中に通常の
   <literal>PHP</literal>コードが続くスクリプトを書き、適当なファイル
   実行属性を設定することが可能です。この方法は、通常のシェル/Perlスク
   リプトと同様に実行することができます。
   <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php
    var_dump($argv);
?>
]]>
   </programlisting>
   このファイルの名前が<filename>test</filename>で、カレントディレクト
   リにあるとすると、以下のように実行することができます。
   <screen>
<![CDATA[
$ chmod 755 test
$ ./test -h -- foo
array(4) {
  [0]=>
  string(6) "./test"
  [1]=>
  string(2) "-h"
  [2]=>
  string(2) "--"
  [3]=>
  string(3) "foo"
}
]]>
   </screen>
   見て分かるように、<literal>-</literal>で始まるスクリプトのパラメー
   タを指定する際に、特に注意する必要はありません。
  </para>
  <para>
   <table>
    <title>コマンドラインオプション</title>
    <tgroup cols="2">
    <thead>
     <row>
      <entry>オプション</entry>
      <entry>説明</entry>
     </row>
    </thead>
     <tbody>
      <row>
       <entry>-s</entry>
       <entry>
        <para>
         カラー構文ハイライト表示されたソースを表示します。
        </para>
       <para>
         このオプションは、ファイルをパースし、<literal>HTML</literal>
         ハイライト表示版のファイルを生成し、標準出力に書き出す内部機
         構を使用します。行うのは、
         <literal>&lt;code&gt; [...] &lt;/code&gt;</literal>のブロック
         を生成することだけで、<literal>HTML</literal>ヘッダは出力され
         ないことに注意して下さい。
        </para>
        <note>
         <para>
          このオプションは、<literal>-r</literal>オプションと同時に使
          用することはできません。
        </para>
        </note>
       </entry>
      </row>
      <row>
       <entry>-w</entry>
       <entry>
        <para>
         コメントと空白文字を削除してソースを表示します。
        </para>
       <note>
         <para>
          このオプションは、<literal>-r</literal>オプションと同時に使
          用することはできません。
         </para>
        </note>
       </entry>
      </row>
      <row>
       <entry>-f</entry>
       <entry>
        <para>
         <literal>-f</literal>オプションに指定したファイル名をﾊﾟｰｽし、
         実行します。このスイッチはオプションで省略することもできます。
         実行するスクリプトを指定するだけで充分です。
        </para>
       </entry>
      </row>
      <row>
       <entry>-v</entry>
       <entry>
        <para>
         PHP, PHP SAPI, Zendのバージョンを標準出力に出力します。例：
         <screen>
<![CDATA[
$ php -v
PHP 4.3.0-dev (cli), Copyright (c) 1997-2002 The PHP Group
Zend Engine v1.2.1, Copyright (c) 1998-2002 Zend Technologies
]]>
         </screen>
        </para>
       </entry>
      </row>
     <row>
       <entry>-c</entry>
       <entry>
        <para>
         このオプションを使用することにより、&php.ini;を探すディレクト
         リを指定したり、カスタマイズされた<literal>INI</literal>ファ
         イル(&php.ini;という名前である必要はありません)を直接指定する
         ことが可能です。例：
         <screen>
<![CDATA[
$ php -c /custom/directory/ my_script.php

$ php -c /custom/directory/custom-file.ini my_script.php
]]>
         </screen>
        </para>
       </entry>
      </row>
      <row>
       <entry>-a</entry>
       <entry>
        <para>
         PHPを対話的に実行します。
         <!-- 
         mfischer, 20020510: Couldn't come up with a decent useful description
         of the current implementation of the interactive mode.
         -->
        </para>
       </entry>
      </row>
      <row>
       <entry>-d</entry>
       <entry>
        <para>
         このオプションにより &php.ini; で指定できる設定ディレクティブ
         にカスタム値を設定することができます。構文は以下のようになります。
         <screen>
<![CDATA[
-d configuration_directive[=value]
]]>
         </screen>
        </para>
        <para>
         例:
         <screen>
<![CDATA[
# 値の部分を省略すると、設定ディレクティブに"1"を指定します
$ php -d max_execution_time -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(1) "1"

# 空の値を渡すと設定ディレクティブに""を設定します
php -d max_execution_time= -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(0) ""

# 設定ディレクティブは文字'='の後に指定したものを設定します
$  php -d max_execution_time=20 -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(2) "20"
$  php -d max_execution_time=doesntmakesense -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(15) "doesntmakesense"
]]>
         </screen>
        </para>
       </entry>
      </row>
      <row>
       <entry>-e</entry>
       <entry>
        <para>
         デバッガ/プロファイラ用の拡張情報を出力します。
       <!-- 
        mfischer, 20020510: Anyone who can provide more information what it
        really does (even if it's only for developers) ?
        -->
        </para>
       </entry>
      </row>
      <row>
      <entry>-z</entry>
       <entry>
        <para>
         Zendエクステンションをロードします。ファイル名のみが指定された場合、
         PHPはこの拡張をカレントのシステムのデフォルトライブラリパスから
         ロードしようとします。
         (Linuxシステムの場合は<filename>/etc/ld.so.conf</filename>で
         指定されています)
         ファイル名を絶対パスで指定した場合、システムのライブラリサーチパスを
         使用しません。ディレクトリ情報を有する相対ファイル名を
         指定すると、<literal>PHP</literal>は、
         カレントのディレクトリの相対パスから拡張モジュールをロードする
         ことのみを行ないます。
        </para>
       </entry>
      </row>
      <row>
      <entry>-l</entry>
       <entry>
       <para>
         このオプションにより、指定した<literal>PHP</literal>コードの
         構文チェックのみを簡単に行なうことができます。成功した場合、
         テキスト
         <literal>No syntax errors detected in &lt;filename&gt;</literal>
         が、標準出力に書き込まれ、リターンコードは<literal>0</literal>
         となります。失敗した場合、テキスト <literal>Errors parsing
          &lt;filename&gt;</literal> に加えて、内部パーサエラーメッセージ
         が標準出力に書き込まれ、シェルリターンコードは、
         <literal>255</literal>となります。
        </para>
        <para>
         このオプションは、(未定義の関数のような)致命的なエラー(fatal error)
         はみつけません。致命的なエラーについても調べたい場合は、
         <literal>-f</literal> を使用してください。
        </para>
        <note>
         <para>
          このオプションは、オプション<literal>-r</literal>と共に使用することは
          できません。
         </para>
        </note>
       </entry>
      </row>
     <row>
       <entry>-m</entry>
       <entry>
        <para>
         このオプションを使用すると、PHPは、PHPに組み込まれた
         (そしてロードされた) Zend モジュールを出力します。
         <screen>
<![CDATA[
$ php -m
[PHP Modules]
xml
tokenizer
standard
session
posix
pcre
overload
mysql
mbstring
ctype

[Zend Modules]
]]>
         </screen>
        </para>
       </entry>
      </row>
      <row>
       <entry>-i</entry>
       <entry>
        このコマンドラインオプションは、<function>phpinfo</function>をコールし、
        結果を出力します。<literal>PHP</literal> が正しく動作していない場合、
        <literal>php -i</literal>を実行し、情報テーブルの前または中に出力
        されるエラーメッセージを調べることをお勧めします。
        出力は、<literal>HTML</literal> 形式で行なわれるため、かなり量が
        多くなることに注意して下さい。
       </entry>
      </row>
      <row>
       <entry>-r</entry>
       <entry>
        <para>
         このオプションにより、コマンドラインのみで<literal>PHP</literal>
         の実行ができるようになります。
         <literal>PHP</literal>の開始および終了タグ
         (<literal>&lt;?php</literal> および <literal>?&gt;</literal>)
         は<emphasis role="strong">不要</emphasis>で、これらを付けると
         パーサエラーとなります。
        </para>
        <note>
         <para>
          このように<literal>PHP</literal>を実行する際に、コマンドラインの
          変数がシェルにより行なわれる置換と干渉しないように注意して下さい。
         </para>
         <para>
          パーサエラーを生じる例
          <screen>
<![CDATA[
$ php -r "$foo = get_defined_constants();"
Command line code(1) : Parse error - parse error, unexpected '='
]]>
          </screen>
          ここでの問題は、2重引用符 <literal>"</literal> を用いた場合でも
          sh/bashが変数置換を行うことです。
          <literal>$foo</literal>はおそらく定義されていないので、
          空文字列に展開された後、実行用に<literal>PHP</literal>に
          そのコードが渡され、以下のように読み込むことになります。
          <screen>
<![CDATA[
$ php -r " = get_defined_constants();"
]]>
          </screen>
          正しい方法は、1重引用符<literal>'</literal>を使用することです。
          1重引用符で括られた文字列の中の変数は、sh/bashにより展開されません。
          <screen>
<![CDATA[
$ php -r '$foo = get_defined_constants(); var_dump($foo);'
array(370) {
  ["E_ERROR"]=>
  int(1)
  ["E_WARNING"]=>
  int(2)
  ["E_PARSE"]=>
  int(4)
  ["E_NOTICE"]=>
  int(8)
  ["E_CORE_ERROR"]=>
  [...]
]]>
          </screen>
          sh/bash以外のシェルを使用している場合には、別の問題を経験したことが
          あるかもしれません。バグレポートを作成するか
          phpdoc@lists.php.netにメールを送ってください。
          シェル変数をコードに取得しようとしたり、エスケープを行なうために
          バックスラッシュを使用したりした場合にも、容易に問題を発生する
          可能性があります。注意が必要です。
         </para>
        </note>
       </entry>
      </row>
      <row>
       <entry>-h</entry>
       <entry>
        このオプションを使用すると、実際の一連のコマンドラインオプションと
        各1行の説明が情報を取得できます。
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>
  <!-- NEW DOCUMENTATION ENDS -->
  <para>
   PHP実行バイナリは、Webサーバから完全に独立してPHPスクリプトを実行す
   るために使用することができます。Unixシステムを使用している場合、実
   行可能とするために、PHPスクリプトの先頭に特別な一行を追加する必要が
   あります。これにより、システムがそのスクリプトを実行するプログラム
   を知ることができます。
   Windows環境では、<literal>.php</literal>ファイルのダブルクリックオ
   プションに<literal>php.exe</literal>を関連づけることができます。
   または、PHPによりスクリプトを実行するバッチファイルを作成することも
   可能です。Unix上で動作させるためにスクリプトに追加された先頭行は、
   Windows環境での動作に悪影響を与えません。このため、この手法により、
   黒須プラットフォーム環境で動作するプログラムを書くことができます。
   コマンドラインPHPプログラムの書方の簡単な例を以下に示します。
  </para>
  <example>
   <title>
    コマンドラインから実行されることを意図したスクリプト(script.php)
   </title>
  <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php

if ($argc != 2 || in_array($argv[1], array('--help', '-help', '-h', '-?'))) {
?>

This is a command line PHP script with one option.

  Usage:
  <?php echo $argv[0]; ?> <option>

  <option> can be some word you would like
  to print out. With the --help, -help, -h,
  or -? options, you can get this help.

<?php
} else {
    echo $argv[1];
}
?>
]]>
   </programlisting>
  </example>
  <para>
   上のスクリプトでは、特殊な先頭行が用いられており、このファイルが
   PHPにより実行されることを示しています。ここではCLI版を使用しているため、
   HTTPヘッダは出力されません。PHPで
   コマンドラインアプリケーションを使用する際には、2つの変数
   <varname>$argc</varname> and <varname>$argv</varname> を使用することが
   できます。
   最初の変数は、引数の数に1(実行中のスクリプトの名前)を加えたものです。
   2番目の変数は、引数を保持する配列で、スクリプト名を有する
   要素0(<varname>$argv[0]</varname>)から始まっています。
  </para>
  <para>
   上のプログラムでは、引数が1より少ないかまたは多いかを調べています。
   また、引数が <literal>--help</literal>, <literal>-help</literal>, 
   <literal>-h</literal>, <literal>-?</literal>の場合、
   ヘルプメッセージを出力し、動的にスクリプト名を出力します。
   他の引数を受け取った場合、これを出力します。
  </para>
  <para>
   上のスクリプトをUnixで実行する場合、実行可能とした後、
   <literal>script.php echothis</literal> または
   <literal>script.php -h</literal> とする必要があります。
   Windowsでは、この処理を行なう以下のようなバッチファイルを作成することが
   できます。
  </para>
  <example>
   <title>
    コマンドラインPHPスクリプトを実行するバッチファイル(script.bat)
   </title>
   <programlisting role="winbat">
@c:\php\php.exe script.php %1 %2 %3 %4
   </programlisting>
  </example>
  <para>
   上のプログラムが<filename>script.php</filename>という名前であると
   し、<filename>c:\php\php.exe</filename>に<filename>php.exe</filename>
   があるとすると、このバッチファイルは、追加したオプション
   <literal>script.bat echothis</literal> または
   <literal>script.bat -h</literal> を指定して、スクリプトを実行します。
  </para>
  <para>
   PHPのコマンドラインアプリケーションを拡張するために使用できる
   その他の関数については、拡張モジュール
   <link linkend="ref.readline">Readline</link>に関する
   ドキュメントも参照してください。
  </para>
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
