<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.15 $ -->
 <chapter id="features.http-auth">
  <title>PHP による HTTP 認証</title>

  <simpara>
   PHPによるHTTP認証のフックは、Apacheモジュールとして実行した時のみ
   有効で、CGI版では利用できません。Apache モジュールPHPスクリプトにお
   いて、<function>header</function> 関数を使用して "Authentication
   Required" メッセージをクライアントブラウザに送ることが可能です。
   これにより、クライアントブラウザにユーザー名とパスワードを入力する
   ウインドウがポップアップ表示されます。一度、ユーザーがユーザー名と
   パスワードを入力すると、PHP スクリプトを含むその URL は、次回以降、
   <link linkend="reserved.variables">定義済みの変数</link> 
   <varname>PHP_AUTH_USER</varname>, <varname>PHP_AUTH_PW</varname>, 
   and <varname>PHP_AUTH_TYPE</varname>にそれぞれユーザー名、
   パスワード、認証型を入力してコールされます。
   定義済みの変数は、配列
   <link linkend="reserved.variables.server">$_SERVER</link> および 
   <varname>$HTTP_SERVER_VARS</varname>　でアクセス可能です。
   "Basic" 認証のみがサポートされています。詳細は、
   <function>header</function>を参照下さい。
  </simpara>

  <note>
   <title>PHP バージョンに関する注意</title>
   <para>
    <link linkend="reserved.variables.server">$_SERVER</link>のような
    <link linkend="language.variables.superglobals">オートグローバル</link>は、
    PHPバージョン <ulink url="&url.php.release4.1.0;">4.1.0</ulink>
    で利用可能です。
    <varname>$HTTP_SERVER_VARS</varname>は、PHP 3以降で利用可能です。
   </para>
  </note>

  <para>   
   ページ上でクライアント認証を強制するスクリプトの例を以下に示します。
   <example>
    <title>HTTP 認証の例</title>
    <programlisting role="php">
<![CDATA[
<?php
  if (!isset($_SERVER['PHP_AUTH_USER'])) {
    header("WWW-Authenticate: Basic realm=\"My Realm\"");
    header("HTTP/1.0 401 Unauthorized");
    echo "ユーザーがキャンセルボタンを押した時に送信されるテキスト\n";
    exit;
  } else {
    echo "<p>こんにちは、{$_SERVER['PHP_AUTH_USER']} さん。</p>";
	echo "<p>あなたは、{$_SERVER['PHP_AUTH_PW']} をパスワードとして入力しました。</p>";
  }
?>
]]>
    </programlisting>
   </example>
  </para>

  <note>
   <title>互換製に関する注意</title>
   <para>
    HTTPヘッダ行をコーディングする際には注意を要します。全てのクライア
    ントへの互換性を最大限に保証するために、キーワード "Basic" には、
    大文字の"B"を使用して書くべきです。realm文字列は(一重引用符ではな
    く)二重引用符で括る必要があります。また、"HTTP/1.0 401"ヘッダ行の
    コード"401"の前には、1つだけ空白を置く必要があります。
   </para>
  </note>

  <para>
   単に <varname>PHP_AUTH_USER</varname>および<varname>PHP_AUTH_PW</varname>
   を出力するのではなく、ユーザー名とパスワードの有効性をチェックしたいと
   思うかもしれません。
   その場合、クエリーをデータベースに送るか、ある dbm ファイル中の
   ユーザーを調べるといったことをすることになるでしょう。
  </para>

  <para>
   バグのある Internet Explorer ブラウザには注意してください。このブラ
   ウザは、ヘッダの順序に関してとてもうるさいようです。今のところ、
   <literal>HTTP/1.0 401</literal> ヘッダの前に
   <emphasis>WWW-Authenticate</emphasis> ヘッダを送るのが効果があるよ
   うです。
  </para>

  <simpara>
   誰かが従来の外部機構による認証を行ってきたページのパスワードを暴く
   ようなスクリプトを書くことを防ぐために、特定のページに関して外部認
   証が可能である場合、PHP_AUTH 変数はセットされません。この場合、外部
   認証されたユーザーかどうかを確認するために 
   <varname>REMOTE_USER</varname>変数、すなわち、
   <varname>$_SERVER['REMOTE_USER']</varname>を使用することができます。
  </simpara>

  <note>
   <title>設定上の注意</title>
   <para>
    PHP は、外部認証が動作しているかどうかの判定を
    <literal>AuthType</literal>ディレクティブの有無で行います。
    PHP認証を使用するコンテキストについてこのディレクティブを避けるよ
    うにして下さい。(さもないと、各認証は失敗します。)
   </para>
  </note>

  <simpara>
   しかし、上記の機能も、認証を要求されないURLを管理する人が同じサーバー
   にある認証を要するURLからパスワードを盗むことを防ぐわけではありませ
   ん。
  </simpara>
  <simpara>
   サーバーからリターンコード401を受けた際に、Netscape Navigatorおよび
   Internet Explorerは共にローカルブラウザのウインドウ上の認証キャッシュ
   を消去します。この機能により、簡単にユーザーを"ログアウト"させ、強
   制的にユーザー名とパスワードを再入力させることができます。この機能
   は、"タイムアウト"付きのログインや、"ログアウト"ボタンに適用されて
   います。
  </simpara>
  <example>
   <title>新規に名前/パスワードを入力させるHTTP 認証の例</title>
   <programlisting role="php">
<![CDATA[
<?php
  function  authenticate() {
    header('WWW-Authenticate: Basic realm="Test Authentication System"');
    header('HTTP/1.0 401 Unauthorized');
    echo "このリソースにアクセスする際には有効なログインIDとパスワードを入力する必要があります。\n";
    exit;
  }

  if (!isset($_SERVER['PHP_AUTH_USER']) || ($_POST['SeenBefore'] == 1 && $_POST['OldAuth'] == $_SERVER['PHP_AUTH_USER'])) {
    authenticate();
  }  
  else  {
   echo "<p>Welcome: {$_SERVER['PHP_AUTH_USER']}<br>";
   echo "Old: {$_REQUEST['OldAuth']}";
   echo "<form action='{$_SERVER['PHP_SELF']}' METHOD='POST'>\n";
   echo "<input type='hidden' name='SeenBefore' value='1'>\n";
   echo "<input type='hidden' name='OldAuth' value='{$_SERVER['PHP_AUTH_USER']}'>\n";
   echo "<input type='submit' value='Re Authenticate'>\n";
   echo "</form></p>\n";
  }
?>
]]>
   </programlisting>
  </example>
  <simpara>
   この動作は、HTTP Basic認証の標準に基づいていません。よって、この機
   能に依存しないように注意する必要があります。Lynx によるテストの結果、
   Lynx は、認証証明書を 401 サーバー応答によりクリアしないことが明ら
   かになっています。このため、back を押してから foward を再度押すこと
   により証明書の要件が変更されない限りリソースをオープンすることがで
   きます。しかし、ユーザは'_'キーを押すことにより認証情報をクリアする
   ことが可能です。
  </simpara>
  <simpara>
   MicrosoftのIISサーバーとCGI版のPHPの組み合わせでは、この機能は、IIS
   の制約により使用することができないということにも注意して下さい。
  </simpara>

  <note>
   <para>
    <link linkend="ini.safe-mode">セーフモード</link> が有効の場合、
    <literal>WWW-Authenticate</literal>ヘッダの
    <literal>realm</literal>部にスクリプトのuidが追加されます。
   </para>
  </note>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
