<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.26 $ -->
<!-- EN-Revision: 1.44 Maintainer: hirokawa Status: ready -->
<!-- CREDITS: shimooka,takagi -->
 <chapter id="features.http-auth">
  <title>PHP による HTTP 認証</title>

  <simpara>
   PHP による <acronym>HTTP</acronym> 認証のフックは、
   Apache モジュールとして実行した時のみ
   有効で、CGI 版では利用できません。Apache モジュール上の PHP スクリプトに
   おいては、<function>header</function> 関数を使用して
    "Authentication Required" メッセージをクライアントブラウザに
   送ることが可能です。
   これにより、クライアントブラウザではユーザー名とパスワードの入力要求
   ウインドウがポップアップ表示されます。一度、ユーザーがユーザー名と
   パスワードを入力すると、PHP スクリプトを含むその URL は、次回以降、
   <link linkend="reserved.variables">定義済みの変数</link>
   <varname>PHP_AUTH_USER</varname> と、 <varname>PHP_AUTH_PW</varname> と、
   <varname>PHP_AUTH_TYPE</varname> にそれぞれユーザー名、
   パスワード、認証型が代入された状態で呼ばれます。
   定義済みの変数は、配列
   <link linkend="reserved.variables.server">$_SERVER</link> および
   <varname>$HTTP_SERVER_VARS</varname>　でアクセス可能です。
   "Basic" 認証および "Digest" 認証 (PHP 5.1.0 以降)
   の両者がサポートされています。詳細は、
   <function>header</function>を参照ください。
  </simpara>

  <note>
   <title>PHP バージョンに関する注意</title>
   <para>
    <link linkend="reserved.variables.server">$_SERVER</link>のような
    <link linkend="language.variables.superglobals">オートグローバル</link>は、
    PHP <ulink url="&url.php.release4.1.0;">4.1.0</ulink>
    以降で利用可能となりました。
    <varname>$HTTP_SERVER_VARS</varname>は、PHP 3以降で利用可能です。
   </para>
  </note>

  <para>
   ページ上でクライアント認証を強制するスクリプトの例を以下に示します。
   <example>
    <title>Basic HTTP 認証の例</title>
    <programlisting role="php">
<![CDATA[
<?php
  if (!isset($_SERVER['PHP_AUTH_USER'])) {
    header("WWW-Authenticate: Basic realm=\"My Realm\"");
    header("HTTP/1.0 401 Unauthorized");
    echo "ユーザーがキャンセルボタンを押した時に送信されるテキスト\n";
    exit;
  } else {
    echo "<p>こんにちは、{$_SERVER['PHP_AUTH_USER']} さん。</p>";
    echo "<p>あなたは、{$_SERVER['PHP_AUTH_PW']} をパスワードとして入力しました。</p>";
  }
?>
]]>
    </programlisting>
   </example>
  </para>

  <para>
   <example>
    <title>Digest HTTP 認証の例</title>
    <para>
     この例は、シンプルな Digest HTTP 認証スクリプトをどの様に実装するか
     を示しています。
     その他情報については、<ulink url="&url.rfc;2617">RFC 2617</ulink>
      を読んでください。
    </para>
    <programlisting role="php">
<![CDATA[
<?php
$realm = 'Restricted area';

//user => password
$users = array('admin' => 'mypass', 'guest' => 'guest');


if (empty($_SERVER['PHP_AUTH_DIGEST'])) {
    header('HTTP/1.1 401 Unauthorized');
    header('WWW-Authenticate: Digest realm="'.$realm.
           '" qop="auth" nonce="'.uniqid().'" opaque="'.md5($realm).'"');

    die('ユーザーがキャンセルボタンを押した時に送信されるテキスト');
}


// PHP_AUTH_DIGEST 変数を精査する
if (!($data = http_digest_parse($_SERVER['PHP_AUTH_DIGEST'])) ||
    !isset($users[$data['username']]))
    die('誤った証明書です!');


// 有効なレスポンスを生成する
$A1 = md5($data['username'] . ':' . $realm . ':' . $users[$data['username']]);
$A2 = md5($_SERVER['REQUEST_METHOD'].':'.$data['uri']);
$valid_response = md5($A1.':'.$data['nonce'].':'.$data['nc'].':'.$data['cnonce'].':'.$data['qop'].':'.$A2);

if ($data['response'] != $valid_response)
    die('誤った証明書です!');

// OK, 有効なユーザー名とパスワードだ
echo 'あなたは次のユーザーとしてログインしています: ' . $data['username'];

// http auth ヘッダをパースする関数
function http_digest_parse($txt)
{
    // データが失われている場合への対応
    $needed_parts = array('nonce'=>1, 'nc'=>1, 'cnonce'=>1, 'qop'=>1, 'username'=>1, 'uri'=>1, 'response'=>1);
    $data = array();

    preg_match_all('@(\w+)=([\'"]?)([a-zA-Z0-9=./\_-]+)\2@', $txt, $matches, PREG_SET_ORDER);

    foreach ($matches as $m) {
        $data[$m[1]] = $m[3];
        unset($needed_parts[$m[1]]);
    }

    return $needed_parts ? false : $data;
}
?>
]]>
    </programlisting>
   </example>
  </para>

  <note>
   <title>互換製に関する注意</title>
   <para>
    HTTPヘッダ行をコーディングする際には注意を要します。全てのクライアントへの
    互換性を最大限に保証するために、キーワード "Basic" には、
    大文字の"B"を使用して書くべきです。realm文字列は(一重引用符ではなく)
    二重引用符で括る必要があります。また、<emphasis>HTTP/1.0 401</emphasis>
    ヘッダ行のコード <emphasis>401</emphasis> の前には、
    1つだけ空白を置く必要があります。
   </para>
  </note>

  <para>
   単に <varname>PHP_AUTH_USER</varname>および<varname>PHP_AUTH_PW</varname>
   を出力するのではなく、ユーザー名とパスワードの有効性をチェックしたいと
   思うかもしれません。
   その場合、クエリーをデータベースに送るか、ある dbm ファイル中の
   ユーザーを調べるといったことをすることになるでしょう。
  </para>

  <para>
   バグのある Internet Explorer ブラウザには注意してください。このブラ
   ウザは、ヘッダの順序に関してとてもうるさいようです。今のところ、
   <literal>HTTP/1.0 401</literal> ヘッダの前に
   <emphasis>WWW-Authenticate</emphasis> ヘッダを送るのが効果があるようです。
  </para>

  <simpara>
   PHP 4.3.0 以降、誰かが従来の外部機構による認証を行ってきたページの
   パスワードを暴くようなスクリプトを書くことを防ぐために、
   特定のページに関して外部認証が可能でかつ &safemode; が有効の場合、
   PHP_AUTH 変数はセットされません。
   この場合、外部認証されたユーザーかどうかを確認するために
   <varname>REMOTE_USER</varname> 変数、すなわち、
   <varname>$_SERVER['REMOTE_USER']</varname> を使用することができます。
  </simpara>

  <note>
   <title>設定上の注意</title>
   <para>
    PHP は、外部認証が動作しているかどうかの判定を
    <literal>AuthType</literal> ディレクティブの有無で行います。
   </para>
  </note>

  <simpara>
   しかし、上記の機能も、認証を要求されないURLを管理する人が同じサーバー
   にある認証を要するURLからパスワードを盗むことを防ぐわけではありませ
   ん。
  </simpara>
  <simpara>
   サーバーからレスポンスコード 401 を受けた際に、Netscape Navigatorおよび
   Internet Explorer は共にローカルブラウザのウインドウ上の認証キャッシュを
   消去します。この機能により、簡単にユーザーを"ログアウト"させ、強制的に
   ユーザー名とパスワードを再入力させることができます。この機能は、
   "タイムアウト" 付きのログインや、"ログアウト" ボタンに適用されています。
  </simpara>
  <example>
   <title>新規に名前 / パスワードを入力させる HTTP 認証の例</title>
   <programlisting role="php">
<![CDATA[
<?php
  function  authenticate() {
    header('WWW-Authenticate: Basic realm="Test Authentication System"');
    header('HTTP/1.0 401 Unauthorized');
    echo "このリソースにアクセスする際には有効なログインIDとパスワードを入力する必要があります。\n";
    exit;
  }

  if (!isset($_SERVER['PHP_AUTH_USER']) || ($_POST['SeenBefore'] == 1 && $_POST['OldAuth'] == $_SERVER['PHP_AUTH_USER'])) {
    authenticate();
  }
  else  {
   echo "<p>Welcome: {$_SERVER['PHP_AUTH_USER']}<br>";
   echo "Old: {$_REQUEST['OldAuth']}";
   echo "<form action='{$_SERVER['PHP_SELF']}' METHOD='POST'>\n";
   echo "<input type='hidden' name='SeenBefore' value='1'>\n";
   echo "<input type='hidden' name='OldAuth' value='{$_SERVER['PHP_AUTH_USER']}'>\n";
   echo "<input type='submit' value='Re Authenticate'>\n";
   echo "</form></p>\n";
  }
?>
]]>
   </programlisting>
  </example>
  <simpara>
   この動作は、HTTP Basic 認証の標準に基づいていません。よって、この機能に
   依存しないように注意する必要があります。Lynx によるテストの結果、
   Lynx は、認証証明書を 401 サーバー応答によりクリアしないことが明らかに
   なっています。このため、back を押してから foward を再度押すことにより
   証明書の要件が変更されない限りリソースをオープンすることができます。
   しかし、ユーザは '_' キーを押すことにより認証情報をクリアすることが可能です。
  </simpara>

  <simpara>
  </simpara>

  <simpara>
   PHP4.3.3 までは、Microsoft の IIS サーバーと CGI 版の PHP の組み合わせでは、
   この機能は、IIS の制約により使用することができなかったことにも
   注意してください。PHP 4.3.3 以降においてこの機能を使用するには、
   IIS の設定の "ディレクトリセキュリティ" の "編集" ボタンを押して
   "匿名アクセス" のみをオンにしてください。その他のフィールドは
   オフのままにしてください。
  </simpara>
  <simpara>
   他の制限としては、IIS モジュール (ISAPI) と PHP 4 を使用している場合に、
   <literal>PHP_AUTH_*</literal> 変数が使用できないことがあります。
   しかし、代わりに<literal>HTTP_AUTHORIZATION</literal> を使うことができます。
   例えば、次のようなコードを考慮してください。<literal>list($user, $pw) = explode(':',
   base64_decode(substr($_SERVER['HTTP_AUTHORIZATION'], 6)));</literal>
  </simpara>
  <note>
   <title>IIS に関する注意:</title>
   <simpara>
    IIS上 で HTTP 認証を使用する場合、PHP の
    <link linkend="ini.cgi.rfc2616-headers">cgi.rfc2616_headers</link>
    ディレクティブは<literal>0</literal> (デフォルト値) にセットされて
    いなければなりません。
   </simpara>
  </note>

  <note>
   <para>
    <link linkend="ini.safe-mode">セーフモード</link> が有効の場合、
    <literal>WWW-Authenticate</literal>ヘッダの
    <literal>realm</literal>部にスクリプトの uid が追加されます。
   </para>
  </note>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
