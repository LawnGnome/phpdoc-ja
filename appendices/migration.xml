<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.16 $ -->
<!-- EN-Revision: 1.27 Maintainer: hirokawa Status: ready -->
<!-- CREDITS: elf -->
<appendix xml:id="migration" xmlns="http://docbook.org/ns/docbook">
 <title>PHP/FI 2 から PHP 3 への移行</title>

 <section xml:id="migration.about">
  <title>3.0 における互換性</title>

  <simpara>
   PHP 3.0 は 1 から書き直されました。
   これには 2.0 のパーサに比べ、
   より堅牢で一貫性のある適切なパーサが内蔵されています。
   3.0 はまた、劇的に速くなり、メモリ消費量も少なくなっています。
   しかしながら、これらの改善事項のうちのいくつかは、
   書式と機能の両面において互換性を欠いた変更になってしまっています。
  </simpara>

  <simpara>
   加えて、PHP の開発者は、
   PHP 3.0 における書式と意味の双方をきれいにし直そうとしましたが、
   これも互換性を欠く要因となっています。
   長い目で見れば、
   これらの変更はより良いものであると私たちは信じています。
  </simpara>

  <simpara>
   この章では、あなたが PHP/FI 2.0 から PHP 3.0
   へ移行する際に遭遇するであろう非互換性と、
   それらへの解決策についてのガイドを提供しようと思います。
   必要でない限り、新しい機能については述べられていません。
  </simpara>

  <simpara>
   あなたの古い PHP/FI 2.0
   スクリプトを自動的に変換できる変換プログラムがあります。
   これは PHP 3.0 ディストリビューションの 
   <filename class="directory">convertor</filename>
   サブディレクトリにあります。
   このプログラムは文法的な変更を捕らえるだけですので、
   どちらにしてもこの章を注意深く読む必要があるでしょう。
  </simpara>
 </section>

 <section xml:id="migration.old-function">
  <title><literal>old_function</literal></title>
  <simpara>
   <literal>old_function</literal> を使用すると、
   PHP/FI2 と同じ構文で関数を宣言できるようになります
   (ただし、'function' を 'old_function' に書き換える必要があります)。
  </simpara>
  <simpara>
   この機能は非推奨です。PHP/FI2-&gt;PHP 3
   コンバータ以外で使用してはいけません。
  </simpara>
  <warning>
   <para>
    <literal>old_function</literal> で宣言した関数は、
    PHP の内部コードからコールすることはできません。
    つまり、<function>usort</function>
    や <function>array_walk</function>、そして
    <function>register_shutdown_function</function>
    といった関数内では使用できないということです。
    この制限を回避するには、その
    <literal>old_function</literal>
    をコールするラッパー関数を (通常の PHP 3 形式で)
    作成します。
   </para>
  </warning>
 </section>

 <section xml:id="migration.startendtags">
  <title>開始／終了タグ</title>

  <para>
   PHP の開始と終了のタグが変わっていることに、
   おそらく最初に気付かれるでしょう。
   古い <literal>&lt;? &gt;</literal> 形式は、3 つの新しい
   形式に置き換えられました。
   <example>
    <title>移行: 古い開始／終了タグ</title>
    <programlisting role="php">
<![CDATA[
<? echo "これは PHP/FI 2.0 のコードです。\n"; >
]]>
    </programlisting>
   </example>
   バージョン 2.0 で、
   PHP/FI は次のバリエーションもサポートするようになりました。
   <example>
    <title>移行: 最初の新しい開始／終了タグ</title>
    <programlisting role="php">
<![CDATA[
<? echo "これは PHP 3.0 のコードです!\n"; ?>
]]>
    </programlisting>
   </example>

   終了タグは、単なる '&gt;' に代わり '?&gt;' で構成されます。
   しかしながら、サーバ上で XML を使いたい場合は、
   この最初の形式では不具合が生じるでしょう。
   なぜなら、PHP は XML ドキュメントの中の XML マークアップを
   PHP コードとして実行しようとするかもしれないからです。
   このため、以下のバリエーションが導入されました。

   <example>
   <title>移行: 2 番目の新しい開始／終了タグ</title>
    <programlisting role="php">
<![CDATA[
<?php echo "これは PHP 3.0 のコードです!\n"; ?>
]]>
    </programlisting>
   </example>

   エディタ上で、
   処理している命令タグが全く認識されないという問題が発生した方がいました。
   Microsoft FrontPage はそんなエディタのうちの 1 つです。
   これらを回避するため、さらに以下のバリエーションが導入されました。

   <example>
    <title>移行: 3 番目の新しい開始／終了タグ</title>
    <programlisting role="php">
<![CDATA[
<script language="php">

  echo "これは PHP 3.0 のコードです!\n";

</script>
]]>
    </programlisting>
   </example>
  </para>
 </section>

 <section xml:id="migration.if-endif">
  <title>if..endif の文法</title>

  <para>
   if(); elseif(); else; endif; を使って if/elseif/else
   ステートメントを記述するための「選択肢」については、
   3.0 パーサに対してかなり複雑な処理を追加してやらないと、
   効率的な実装を行うことができません。このため、
   文法が変更されました。
   <example>
    <title>移行: 古い if..endif の文法</title>
    <programlisting role="php">
<![CDATA[
if ($foo);
    echo "はい\n";
elseif ($bar);
    echo "だいたい\n";
else;
    echo "いいえ\n";
endif;
]]>
    </programlisting>
   </example>
   <example>
    <title>移行: 新しい if..endif の文法</title>
    <programlisting role="php">
<![CDATA[
if ($foo):
    echo "はい\n";
elseif ($bar):
    echo "だいたい\n";
else:
    echo "いいえ\n";
endif;
]]>
    </programlisting>
   </example>

   評価式を終了させるもの(endif)を除き、
   すべてのステートメントにおいてセミコロンはコロンに変更されました。
  </para>
 </section>

 <section xml:id="migration-while">
  <title>while の文法</title>
  <para>
   if..endif と同様に、while..endwhile の文法も変更されました。
   <example>
    <title>移行: 古い while..endwhile の文法</title>
    <programlisting role="php">
<![CDATA[
while ($more_to_come);
    ...
endwhile;
]]>
    </programlisting>
   </example>
   <example>
    <title>移行: 新しい while..endwhile の文法</title>
    <programlisting role="php">
<![CDATA[
while ($more_to_come):
    ...
endwhile;
]]>
    </programlisting>
   </example>
  </para>
  <warning>
   <simpara>
    PHP 3.0 で古い形式の while..endwhile を使った場合は、
    無限ループになってしまいます。
   </simpara>
  </warning>
 </section>

 <section xml:id="migration.expr">
  <title>式の型</title>
  <simpara>
   PHP/FI 2.0 では、結果の型を決めるのに左辺式を使っていました。
   PHP 3.0 では、結果の型を決めるのに両辺を使うようになったので、
   3.0 環境の元で 2.0 のスクリプトを実行すると、
   予期しない結果になる場合があります。
  </simpara>
  <para>
   以下の例を考えてみましょう。
   <informalexample>
    <programlisting role="php">
<![CDATA[
$a[0]=5;
$a[1]=7;

$key = key($a);
while ("" != $key) {
    echo "$keyn";
    next($a);
}
]]>
    </programlisting>
   </informalexample>

   PHP/FI 2.0 では、この例は $a の 2 つのインデックス双方を表示します。
   一方、PHP 3.0 ではなにも表示されません。この理由は、PHP 2.0 では、
   左側の引数が文字列なので文字列の比較が行われますが、もちろん
   <literal>""</literal> は <literal>"0"</literal>
   とは等しくならないためです。
   一方 PHP 3.0 では、文字列が数字と比較されると、
   (文字列が数字に変換され、) 数字による比較が行われます。
   <literal>0</literal>は <literal>atoi("")</literal> で比較され、
   さらに<literal>変数リスト</literal> の方も <literal>0</literal>
   と評価され、<literal>0==0</literal> なので、
   その結果ループは 1 度も実行されないということになります。
  </para>
  <para>
   これを解決するのは簡単です。
   while ステートメントを以下のように変更します。
   <informalexample>
    <programlisting role="php">
<![CDATA[
while ((string)$key != "") {
]]>
    </programlisting>
   </informalexample>
  </para>
 </section>

 <section xml:id="migration.errors">
  <title>エラーメッセージの変更</title>
  <simpara>
   PHP 3.0 のエラーメッセージは、2.0 よりも通常の場合正確になりました。
   しかし、もはやソースコードのうちエラー原因となった部分は表示されません。
   そのかわり、エラーの原因となったファイル名と行番号が表示されるので、
   驚くかもしれません。
  </simpara>
 </section>

 <section xml:id="migration.booleval">
  <title>短絡的なブール評価</title>
  <simpara>
   PHP 3.0 におけるブール評価は短絡的です。というのは、
   <literal>(1 || test_me())</literal> のような評価式があるとすると、
   関数 <function>test_me</function> は実行されないということです。
   これは、<literal>1</literal> を評価した後は、
   最終的な評価結果を変えることはできないと分かっているからです。
  </simpara>

  <simpara>
   これは互換性の問題としては些細なことかもしれませんが、
   思わぬ副作用があるかもしれません。
  </simpara>
 </section>

 <section xml:id="migration.truefalse">
  <title>関数の &true;/&false; 返り値</title>
  <simpara>
   ほとんどの内部関数が書き直されたのに伴い、PHP/FI 2.0 では成功時に
   0、失敗時に -1 を返していたのが、それぞれ &true; と &false;
   を返すように変更されました。
   この新しい振る舞いにより、
   <literal>$fp = fopen("/your/file") or fail("darn!");</literal>
   のようなより論理的なコードを書く事ができるようになりました。
   PHP/FI 2.0 には、関数がその実行に失敗した時に、
   何を返すべきかという明瞭なルールがなかったので、
   そのようなスクリプトのほとんどは、2.0 から 3.0 のコンバータを使った後に、
   手作業でチェックしなければならないと思います。
  </simpara>
  <para>
   <example>
    <title>2.0 からの移行: 返り値、古いコード</title>
    <programlisting role="php">
<![CDATA[
$fp = fopen($file, "r");
if ($fp == -1);
    echo("$file を読み込み専用として開くことが出来ませんでした<br />\n");
endif;
]]>
    </programlisting>
   </example>
   <example>
    <title>2.0 からの移行: 返り値、新しいコード</title>
    <programlisting role="php">
<![CDATA[
$fp = @fopen($file, "r") or print("$file を読み込み用として開くことができませんでした<br />\n");
]]>
    </programlisting>
   </example>
  </para>
 </section>

 <section xml:id="migration-other">
  <title>その他の互換性</title>

  <itemizedlist>
   <listitem><simpara>
    PHP 3.0 の Apache モジュールは、もはや バージョン 1.2 以前の
    Apache をサポートしません。Apache 1.2 以降が必要となります。
   </simpara></listitem>

   <listitem><simpara>
    <function>echo</function> はもはやフォーマット文字列をサポート
    しません。<function>printf</function> 関数を使ってください。
   </simpara></listitem>

   <listitem><simpara>
    PHP/FI 2.0 では、実装面に起因する副作用として、
    <literal>$foo[0]</literal> が <literal>$foo</literal>
    と同じ値になるということがありました。
    これは PHP 3.0 では等しくなくなりました。
   </simpara></listitem>

   <listitem>
    <simpara>
     <literal>$array[]</literal> で配列を読み込む機能は、
     もはやサポートされません。
    </simpara>
    <simpara>
     すなわち、<literal>$data = $array[]</literal>
     といったループで配列の中身を取り出すことはできないということです。
     この代わりに <function>current</function> と <function>next</function>
     を使ってください。     
    </simpara>
    <simpara>
     また、<literal>$array1[] = $array2</literal> では
     <literal> $array2</literal> の値を <literal>$array1</literal>
     に追加することにはならず、
     <literal>$array1</literal> の最後のエントリに
     <literal>$array2</literal> を追加することになってしまいます。
     多次元配列のサポートを参照してください。
    </simpara>
   </listitem>

   <listitem>
    <simpara>
     <literal>"+"</literal> は、もはや文字列の連結演算子にはならず、
     その代わりにその引数を数値に変換して数値の加算を行ってしまいます。
     <literal>"."</literal> を使用してください。
    </simpara>
   </listitem>
  </itemizedlist>

  <example>
   <title>2.0 からの移行: 文字列の連結</title>
   <programlisting role="php">
<![CDATA[
echo "1" + "1";
]]>
   </programlisting>
   <para> 
    PHP 2.0 ではこれで 11 が表示されますが、PHP 3.0 ではこれは
    2 になります。代わりに次のようにしてください。
    <programlisting role="php">
<![CDATA[
echo "1"."1";
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
$a = 1;
$b = 1;
echo $a + $b;
]]>
    </programlisting>
   </para>
   <para>
    これは PHP 2.0 でも 3.0 でも 2 になります。
    <programlisting role="php">
<![CDATA[
$a = 1;
$b = 1;
echo $a.$b;
]]>
    </programlisting>
    これは PHP 3.0 では 11 になります。
   </para>
  </example>
 </section>

</appendix>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
