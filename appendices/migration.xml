
<appendix id="migration">
 <title>PHP/FI 2.0 から PHP 3.0 への移行</title>

 <sect1 id="migration-about">
  <title>3.0 における互換性</title>
  <simpara>
   PHP 3.0 は 1 から書き直されました。これには 2.0 のパーサに比べて
   より堅牢で一貫性のある適切なパーサが内蔵されています。3.0 はまた、
   劇的に速くなり、メモリ消費量も少なくなっています。しかしながら、
   これらの改善事項のうちのいくつかは、書式と機能の両面において
   互換性を欠いた変更になってしまっています。</simpara>

  <simpara>
   加えて、PHP の開発者は、PHP 3.0 における書式と意味の双方をきれいに
   し直そうとしましたが、これも互換性を欠く要因となっています。長い目
   で見れば、これらの変更はより良いものであると私たちは信じています。</simpara>

  <simpara>
   この章では、あなたが PHP/FI 2.0 から PHP 3.0 へ移行する際に遭遇
   するであろう非互換性と、それらへの解決策についてのガイドを提供
   しようと思います。必要でない限り、新しい機能については述べられて
   いません。</simpara>

  <simpara>
   あなたの古い PHP/FI 2.0 スクリプトを自動的に変換できる変換プログラム
   があります。これは PHP 3.0 ディストリビューションの <filename
    class="directory">convertor</filename> サブディレクトリにあります。
   このプログラムは文法的な変更を捕らえるだけですので、どちらにしても
   この章を注意深く読む必要があるでしょう。</simpara></sect1>

 <sect1 id="migration-startendtags">
  <title>開始／終了タグ</title>

  <para>
   PHP の開始と終了のタグが変わっていることに、おそらく最初に気付かれる
   でしょう。古い <literal>&lt;? &gt;</literal> 形式は、3 つの新しい
   形式に置き換えられました。
   <example>
    <title>移行：古い開始／終了タグ</title>
    <programlisting>
&lt;? echo "これは PHP/FI 2.0 のコードです。\n"; &gt;
</programlisting></example>

   バージョン 2.0 で、PHP/FI は次のバリエーションもサポートするように
   なりました。

   <example><title>移行：最初の新しい開始／終了タグ</title>
    <programlisting>
&lt;? echo "これは PHP 3.0 のコードです!\n"; ?&gt;
</programlisting></example>

   終了タグは、単なる '&gt;' に代わり '?&gt;' で構成されます。しかし
   ながら、サーバ上で XML を使いたい場合は、この最初の形式では不具合
   が生じるでしょう。なぜなら、PHP は XML ドキュメントの中の XML
   マークアップを PHP コードとして実行しようとするかもしれないからです。
   このため、以下のバリエーションが導入されました。

   <example><title>移行：2 番目の新しい開始／終了タグ</title>
    <programlisting>
&lt;?php echo "これは PHP 3.0 のコードです!\n"; ?&gt;
</programlisting></example>

   エディタ上で、処理している命令タグが全く認識されないという問題が
   発生した方がいました。Microsoft FrontPage はそんなエディタのうちの
   1 つです。これらを回避するため、さらに以下のバリエーションが導入
   されました。

   <example><title>移行：3 番目の新しい開始／終了タグ</title>
    <programlisting>
&lt;script language="php"&gt;

  echo "これは PHP 3.0 のコードです!\n";

&lt;/script&gt;
</programlisting></example></para></sect1>


 <sect1 id="migration-if-endif">
  <title>if..endif の文法</title>

  <para>
   if(); elseif(); else; endif; を使って if/elseif/else ステートメントを
   記述するための '選択肢' については、3.0 パーサに対してかなり複雑な処理
   を追加してやらないと、効率的な実装を行うことができません。このため、
   文法が変更されました。
   <example>
    <title>移行：古い if..endif の文法</title>
    <programlisting>
if ($foo);
    echo "はい\n";
elseif ($bar);
    echo "だいたい\n";
else;
    echo "いいえ\n";
endif;
</programlisting></example>
   <example>
    <title>移行：新しい if..endif の文法</title>
    <programlisting>
if ($foo):
    echo "はい\n";
elseif ($bar):
    echo "だいたい\n";
else:
    echo "いいえ\n";
endif;
</programlisting></example>

   評価式を終了させるもの(endif)を除き、すべてのステートメントにおいて
   セミコロンはコロンに変更されました。</para></sect1>

 <sect1 id="migration-while">
  <title>while の文法</title>
  <para>
   if..endif と同様に、while..endwhile の文法も変更されました。
   <example><title>移行：古い while..endwhile の文法</title>
   <programlisting>
while ($more_to_come);
    ...
endwhile;
</programlisting></example>
   <example><title>移行：新しい while..endwhile の文法</title>
   <programlisting>
while ($more_to_come):
    ...
endwhile;
</programlisting></example>
  </para>
  <warning>
   <simpara>
    PHP 3.0 で古い形式の while..endwhile を使った場合は、永久ループ
    になってしまいます。
   </simpara>
  </warning></sect1>

 <sect1 id="migration-expr">
  <title>式の型</title>
  <simpara>
   PHP/FI 2.0 では、結果の型を決めるのに左辺式を使っていました。
   PHP 3.0 では、結果の型を決めるのに両辺を使うようになったので、
   3.0 環境の元で 2.0 のスクリプトを実行すると、予期しない結果になる
   場合があります。</simpara>
  <simpara></simpara>

  <para>
   以下の例を考えてみましょう。
   <informalexample><programlisting>
$a[0]=5;
$a[1]=7;

$key = key($a);
while ("" != $key) {
    echo "$keyn";
    next($a);
}
</programlisting></informalexample>

   PHP/FI 2.0 では、この例は $a の 2 つのインデックス双方を表示します。
   一方、PHP 3.0 ではなにも表示されません。この理由は、PHP 2.0 では、
   左側の引数が文字列なので文字列の比較が行われますが、もちろん
   <literal>""</literal> は <literal>"0"</literal> とは等しくならない
   ためです。一方 PHP 3.0 では、文字列が数字と比較されると、（文字列
   が数字に変換され、）数字による比較が行われます。<literal>0</literal>
   は <literal>atoi("")</literal> で比較され、さらに<literal>変数リスト
   </literal> の方も <literal>0</literal> と評価され、<literal>0==0
   </literal> なので、その結果ループは 1 度も実行されないということに
   なります。

  </para>
  <para>
   これを解決するのは簡単です。while ステートメントを以下のように変更
   します。
   <informalexample><programlisting>
while ((string)$key != "") {
</programlisting></informalexample></para></sect1>


 <sect1 id="migration-errors">
  <title>エラーメッセージの変更</title>
  <simpara>
   PHP 3.0 のエラーメッセージは、2.0 よりも通常の場合正確になりました。
   しかし、もはやソースコードのうちエラー原因となった部分は表示されません。
   そのかわり、エラーの原因となったファイル名と行番号が表示されるので、
   驚くかもしれません。
  </simpara></sect1>


 <sect1 id="migration-booleval">
  <title>短絡的なブール評価</title>
  <simpara>
   PHP 3.0 におけるブール評価は短絡的です。というのは、<literal>
   (1 || test_me())</literal> のような評価式があるとすると、関数
   <function>test_me</function> は実行されないということです。これは、
   <literal>1</literal> を評価した後は、最終的な評価結果を変えることは
   できないと分かっているからです。</simpara>
    
  <simpara>
   これは互換性の問題としては些細なことかもしれませんが、思わぬ副作用
   があるかもしれません。</simpara></sect1>

 <sect1 id="migration-truefalse">
  <title>関数の true/false 返り値</title>
  <simpara>
   ほとんどの内部関数が書き直されたのに伴い、PHP/FI 2.0 では成功時に
   0 、失敗時に -1 を返していたのが、それぞれ TRUE と FALSE を返す
   ように変更されました。この新しい振る舞いにより、<literal>
   $fp = fopen("/your/file") だとか fail("darn!");</literal> のような
   より論理的なコードを書く事ができるようになりました。PHP/FI 2.0 
   には、関数がその実行に失敗した時に何を返すべきかという明瞭な
   ルールがなかったので、そのようなスクリプトのほとんどは、2.0 から
   3.0 のコンバータを使った後に、手作業でチェックしなければならないと
   思います。</simpara>
  <para>
   <example>
    <title>2.0 からの移行：返り値、古いコード</title>
    <programlisting>
$fp = fopen($file, "r");
if ($fp == -1);
    echo("$file を読み込み用として開くことができませんでした&lt;br&gt;\n");
endif;
</programlisting>
   </example>
   <example>
    <title>2.0 からの移行：返り値、新しいコード</title>
    <programlisting>
$fp = @fopen($file, "r") or 
  print("$file を読み込み用として開くことができませんでした&lt;br&gt;\n");
</programlisting>
   </example></para></sect1>

   
 <sect1 id="migration-other">
  <title>その他の互換性</title>

   <itemizedlist>
    <listitem><simpara>
    PHP 3.0 の Apache モジュールは、もはや バージョン 1.2 以前の
    Apache をサポートしません。Apache 1.2 以降が必要となります。</simpara></listitem>

    <listitem><simpara> 
    <function>echo</function> はもはやフォーマット文字列をサポート
    しません。<function>printf</function> 関数を使って下さい。</simpara></listitem>

    <listitem><simpara>
    PHP/FI 2.0 では、実装面に起因する副作用として、<literal>$foo[0]
    </literal> が <literal>$foo</literal> と同じ値になるということ
    がありました。これは PHP 3.0 では等しくなくなりました。</simpara></listitem>

    <listitem><simpara>
    <literal>$array[]</literal> で配列を読み込む機能は、もはや
    サポートされません。</simpara>

     <simpara>
     すなわち、<literal>$data = $array[]</literal> といったループで
     配列の中身を取り出すことはできないということです。この代わりに
     <function>current</function> と <function>next</function> を
     使って下さい。</simpara>
     <simpara>
     また、<literal>$array1[] = $array2</literal> では <literal>
     $array2</literal> の値を <literal>$array1</literal> に追加すること
     にはならず、<literal>$array1</literal> の最後のエントリに
     <literal>$array2</literal> を追加することになってしまいます。
     多次元配列のサポートを参照してください。</simpara></listitem>

    <listitem>
    <simpara>
    <literal>"+"</literal> は、もはや文字列の連結演算子にはならず、
    その代わりにその引数を数値に変換して数値の加算を行ってしまいます。
    <literal>"."</literal> を使用してください。</simpara></listitem>
   </itemizedlist>

        <example>
          <title>2.0 からの移行：文字列の連結</title>
          <programlisting>
echo "1" + "1";
</programlisting>

         <para> 
          PHP 2.0 ではこれで 11 が表示されますが、PHP 3.0 ではこれは
          2 になります。代わりに

          <programlisting>
echo "1"."1";
</programlisting>

          を使用してください。

          <programlisting>
$a = 1;
$b = 1;
echo $a + $b;
</programlisting></para>

         <para>  
          これは PHP 2.0 でも 3.0 でも 2 になります。

          <programlisting>
$a = 1;
$b = 1;
echo $a.$b;
</programlisting>
          これは PHP 3.0 では 11 になります。</para>
    </example></sect1>

 </appendix>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
