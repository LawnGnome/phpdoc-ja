<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.15 $ -->
<!-- sync: 1.24 -->
<appendix id="phpdevel">
 <title>PHP 3の拡張</title>

 <simpara>
  このセクションはPHP3の拡張方法に関するとても古臭いデモです。
  PHP4に関心があるのであれば、<link linkend="zend">Zend API</link>の
  セクションを読んでください。PHPソースの種々のファイルも
  読むとよいでしょう。
  <filename>README.SELF-CONTAINED-EXTENSIONS</filename>や
  <filename>README.EXT_SKEL</filename>です。
 </simpara>

 <sect1 id="phpdevel-addfunc">
  <title>PHP 3への関数の付加</title>
   <sect2 id="phpdevel-addfunc-prototype">
    <title>関数プロトタイプ</title>
    <para>
     全ての関数は次のような形式です。
     <programlisting role="c">
<![CDATA[
void php3_foo(INTERNAL_FUNCTION_PARAMETERS) {
      
}
]]>
     </programlisting>
     関数が引数を取らない場合でも、このような形式でコールされます。
    </para>
   </sect2>
   
   <sect2 id="phpdevel-addfunc-args">
    <title>関数の引数</title>
    <para>
     引数は常にpval型です。この型は、実際の引数の型をメンバーとする
     unionを有しています。
     関数が二つの引数を取る場合、関数の最初に次のような処理を
     行なうことになります。
    </para>
    <para>
     <example>
      <title>引数の取得</title>
      <programlisting role="c">
<![CDATA[
pval *arg1, *arg2;
if (ARG_COUNT(ht) != 2 || getParameters(ht,2,&arg1,&arg2)==FAILURE) {
   WRONG_PARAM_COUNT;
}
]]>
      </programlisting>
     </example>
     
     注意: 引数は値渡しでも参照渡しでもかまいません。どちらの場合でも
	 &amp;(pval *) を getParameters に渡す必要があります。
	 n 番目のパラメータが参照渡しであるかどうかを調べたい場合、
	 関数 ParameterPassedByReference(ht,n) を使用することができます。
	 この関数は、1 または 0 を返します。</para>
     
    <simpara>
     渡されたパラメータのどれかを変更する場合、
     参照渡しであるか、値渡しであるかにかかわらず、
     pval_destructor をコールすることにより初期化するか、
     ARRAYにパラメータを加えたい場合には、    
     返り値を ARRAYとして処理する internal_functions.h 
     の中の関数に類似の関数を使用することが可能です。
    </simpara>
    <simpara>
     また、パラメータを IS_STRING に変更する場合、
     estrdup() された文字列と文字列の長さを最初に割り付けた後で始めて
     型を IS_STRING に変更することが可能であることに注意して下さい。
     すでに IS_STRING または IS_ARRAY であるパラメータの文字列を
     変更する場合、最初に pval_destructor を実行する必要があります。
    </simpara>
   </sect2>
    
   <sect2 id="phpdevel-addfunc-varargs">
    <title>可変引数</title>
    <para>
     関数は、可変の数の引数をとることができます。
     ある関数が 2 つまたは 3 つの引数のどちらかをとる場合、
     次のようにしてください。
    </para>
     
    <para>
     <example>
      <title>可変引数</title>
      <programlisting role="c">
<![CDATA[
pval *arg1, *arg2, *arg3;
int arg_count = ARG_COUNT(ht);
 
if (arg_count &lt; 2 || arg_count &gt; 3 ||
    getParameters(ht,arg_count,&arg1,&arg2,&arg3)==FAILURE) {
    WRONG_PARAM_COUNT;
}
]]>
      </programlisting>
     </example>
    </para>
   </sect2>
      
   <sect2 id="phpdevel-addfunc-using-args">
    <title>引数の使用</title>
    <para>
     各引数の型は pval 型フィールドに保存されます。
     この型は、次のどれかとすることができます。
     
     <table>
      <title>PHP 内部の型</title>
      <tgroup cols="2">
       <tbody>
        <row>
         <entry>IS_STRING</entry>
         <entry>文字列</entry>
        </row>
        <row>
         <entry>IS_DOUBLE</entry>
         <entry>倍精度浮動小数点</entry>
        </row>
        <row>
         <entry>IS_LONG</entry>
         <entry>倍精度整数</entry>
        </row>
        <row>
         <entry>IS_ARRAY</entry>
         <entry>配列</entry>
        </row>
        <row>
         <entry>IS_EMPTY</entry>
         <entry>空</entry>
        </row>
        <row>
         <entry>IS_USER_FUNCTION</entry>
         <entry>??</entry>
        </row>
        <row>
         <entry>IS_INTERNAL_FUNCTION</entry>
         <entry>?? (このうちのいくつかは関数に渡すことができません。 - 削除)</entry>
        </row>
        <row>
         <entry>IS_CLASS</entry>
         <entry>??</entry>
        </row>
        <row>
         <entry>IS_OBJECT</entry>
         <entry>??</entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <para>
     ある型の引数を得たが、他の型で使用したい場合、または、
     その引数を強制的にある型で使用したい場合、
     次の変換関数のどれかを使用することができます。
     
     <programlisting role="c">
<![CDATA[
convert_to_long(arg1);
convert_to_double(arg1);
convert_to_string(arg1); 
convert_to_boolean_long(arg1); /* 文字列が "" または "0" の場合 0、その他の場合 1 になります */
convert_string_to_number(arg1);  /* 文字列に応じて値を LONG または DOUBLE に変更します  */
]]>
     </programlisting>
    </para>
    <simpara>
     これらの関数は、全てその場で変換されます。
     値は全く返されません。
    </simpara>
 
    <para>
     実引数は、結合体に保持されます。
     メンバーは、次のようになります。
     <itemizedlist>
      <listitem>
       <simpara>
	IS_STRING: arg1-&gt;value.str.val
       </simpara>
      </listitem>
      <listitem>
       <simpara>
	IS_LONG: arg1-&gt;value.lval
       </simpara>
      </listitem>
      <listitem>
       <simpara>
	IS_DOUBLE: arg1-&gt;value.dval
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
   </sect2>
     
   <sect2 id="phpdevel-addfunc-memmgmt">
    <title>関数におけるメモリー管理</title>
    <simpara>
     関数により必要とされる全てのメモリーは、
     emalloc() または estrdup() のどちらかにより
     確保される必要があります。これらの関数は、
     通常の malloc() および strdup() 関数に似た
     メモリー関連処理を行う抽象関数です。
     メモリーは、efree() により開放される必要があります。
    </simpara>
    <simpara>
     このプログラムには、2種類のメモリーがあります。
     つまり、パーサーに変数として返されるメモリーと
     内部関数での一次的な記憶領域用に必要なメモリーです。
     文字列をある変数に代入しパーサーに返したい場合、
     まず emalloc() または estrdup() のどちらかにより
     メモリーを確保する必要があります。
     このメモリーは、同じ関数において元の代入値を上書きしない限り
     開放することはできません。
     (この種のプログラミング法は、推奨されません。)
    </simpara>
    <simpara>
     自分の関数・ライブラリで必要な一時的・永続的メモリを確保するためには、
     emalloc()、estrdup()、efree() 関数を使用する必要があります。
     これらの関数は、それぞれが対応する関数 (malloc,strdup,free)
     と全く同じ動作をします。
     emalloc() または estrdup() を実行した場合、
     ただし、プログラム実行終了時まで確保しつづけるつもりである場合を除き、
     どこかで efree() を行う必要があります。
     さもなくば、メモリーリークを起こす可能性があります。
     関数が対応するそれぞれが関数と全く同じ動作をするという意味は
     次のようなものです。
     つまり、emalloc() も estrdup() もされていないメモリーについて efree() 
     を行った場合、セグメンテーションフォルトを発生する可能性があります。
     このため、消費したメモリーを解放する際には注意して下さい。
    </simpara>
    <simpara>
     "-DDEBUG" でコンパイルした場合、PHP 3は、指定したスクリプトの実行が
     終了した際に、emalloc() および estrdup() 
     で確保したが efree() でまだ開放されていない全メモリーのリストを
     表示します。
    </simpara>
   </sect2>
 
   <sect2 id="phpdevel-addfunc-symtab">
    <title>変数のシンボルテーブルへの設定</title>
    <para>
    シンボルテーブルに変数を設定することを容易にするために
    以下のようなマクロが用意されています。
     
     <itemizedlist>
      <listitem><simpara>SET_VAR_STRING(name,value)</simpara></listitem>
      <listitem><simpara>SET_VAR_DOUBLE(name,value)</simpara></listitem>
      <listitem><simpara>SET_VAR_LONG(name,value)</simpara></listitem>
     </itemizedlist>
    </para>
 
    <warning>
     <para>
      SET_VAR_STRINGを使用する場合は注意が必要です。
      value は、メモリ管理コードが後にこのポインタについて free を
      行おうとするため、手動で malloc を行う必要があります。
      静的に確保されたメモリーを SET_VAR_STRING に渡してはなりません。
     </para>
    </warning>

    <simpara>
     PHPのシンボルテーブルは、ハッシュテーブルとして実装されています。
     いつなんどきでも &amp;symbol_table は 'main' シンボルテーブルへの
     ポインターであり、active_symbol_table は現在アクティブな
     シンボルテーブルを指しています。(この二つは実行開始時には同じですが、
     関数の中にいる時には異なっています。)
    </simpara>
    <para>
     次の例は 'active_symbol_table' を使用します。
     'main' シンボルテーブルを使用したい場合には、
     これを &amp;symbol_table で置きかえる必要があります。
     また、以下に説明するように同じ関数を配列にも適用することができます。
    </para>
    <para>
     <example>
      <title>$foo がシンボルテーブルに存在するかどうかを調べる</title>
      <programlisting role="c">
<![CDATA[
if (hash_exists(active_symbol_table,"foo",sizeof("foo"))) { exists... }
else { doesn't exist }
]]>
      </programlisting>
     </example>
     <example>
      <title>シンボルテーブルにある変数のサイズの調べ方</title>
      <programlisting role="c">
<![CDATA[
hash_find(active_symbol_table,"foo",sizeof("foo"),&pvalue);
check(pvalue.type);
]]>
      </programlisting>
     </example>
     PHPにおける配列は、シンボルテーブルと同じくハッシュテーブル
     により実装されています。
     このため、上記の二つの関数は配列の内部で変数を確認するためにも
     使用可能です。
    </para>
    <simpara>
     シンボルテーブルに配列を新規に定義したい場合、
     次のようにする必要があります。
    </simpara>
    <simpara>
     まず、hash_exists() または hash_find() を用いて
     その配列の存在や、適切に開放されているかどうかを
     確認する方が良いでしょう。
    </simpara>
    <simpara>
     次に、その配列を次のように初期化します。
    </simpara>
    <para>
     <example>
      <title>新規の配列の初期化</title>
      <programlisting role="c">
<![CDATA[
pval arr;
   
if (array_init(&arr) == FAILURE) { failed... };
hash_update(active_symbol_table,"foo",sizeof("foo"),&arr,sizeof(pval),NULL);
]]>
      </programlisting>
     </example>
     このコードは、アクティブシンボルテーブルにおいて新規配列を宣言しています。
     この配列は空です。
    </para>
    <simpara>
     以下に新しいエントリをこの配列に加える例を示します。
    </simpara>
    <para>
     <example>
      <title>新規配列にエントリを加える</title>
      <programlisting role="c">
<![CDATA[
pval entry;
   
entry.type = IS_LONG;
entry.value.lval = 5;
   
/* $foo["bar"] = 5 を定義する */
hash_update(arr.value.ht,"bar",sizeof("bar"),&entry,sizeof(pval),NULL); 
 
/* $foo[7] = 5 を定義する */
hash_index_update(arr.value.ht,7,&entry,sizeof(pval),NULL); 
 
/* $foo[] における次の空きメモリー、つまり $foo[8] を 5 に定義する
 * (php2 と同様に動作します)
 */
hash_next_index_insert(arr.value.ht,&entry,sizeof(pval),NULL); 
]]>
      </programlisting>
     </example>
      
      ハッシュに挿入された値を修正したい場合、
      まずハッシュから値を取り出す必要があります。
      オーバーヘッドを避けるため、 pval ** を
      ハッシュ付加関数に与え、
      ハッシュの内部に挿入された要素のアドレスを示す
      pval * を用いて更新を行うことができます。
      (上記の全ての例のように)この値が、&null; の場合、このパラメータは
      無視されます。
    </para>
    <simpara>
     hash_next_index_insert() は、PHP 2.0 の "$foo[] = bar;" 
     とほぼ同じロジックを用いています。
    </simpara>
    <simpara>
     関数から配列を返す構成とする場合、
     以下のようにするだけで配列の初期化を行うことができます。
    </simpara>
    <programlisting role="c">
<![CDATA[
if (array_init(return_value) == FAILURE) { failed...; }
]]>
    </programlisting>
    <simpara>
     続いて、ヘルパー関数を用いて値を付加します。
    </simpara>
 
    <programlisting role="c">
<![CDATA[
add_next_index_long(return_value,long_value);
add_next_index_double(return_value,double_value);
add_next_index_string(return_value,estrdup(string_value));
]]>
    </programlisting>
    <para>
     もちろん、付加が配列の初期化直後に行われない場合には、
     配列をまず確認する必要があることでしょう。
     <programlisting role="c">
<![CDATA[
pval *arr;
   
if (hash_find(active_symbol_table,"foo",sizeof("foo"),(void **)&arr)==FAILURE) { can't find... }
else { use arr->value.ht... }
]]>
     </programlisting>
    </para>
    <simpara>
     hash_find は pval ポインタへのポインタを受け取り、
     pval ポインタではないことに注意して下さい。
    </simpara>
    <simpara>
     ほとんど全てのハッシュ関数は、SUCCESSまたはFAILUREを返します。
     (ただし、論理値を返す hash_exists() を除きます。)
    </simpara>
   </sect2>
   
   <sect2 id="phpdevel-addfunc-retsimple">
    <title>簡単な値を返す場合</title>
    <simpara>
     関数からの返り値を作成することを容易にするための
     複数のマクロが利用可能です。
    </simpara>
    <para>
     RETURN_* マクロは、全て返り値をセットし関数から戻ります。
     <itemizedlist>
      <listitem>
       <simpara>
	RETURN
       </simpara>
      </listitem>
      <listitem>
       <simpara>
	RETURN_FALSE
       </simpara>
      </listitem>
      <listitem>
       <simpara>
	RETURN_TRUE
       </simpara>
      </listitem>
      <listitem>
       <simpara>
	RETURN_LONG(l)
       </simpara>
      </listitem>
      <listitem>
       <simpara>
	RETURN_STRING(s,dup)   dupが&true;の場合、文字列をコピーします。
       </simpara>
      </listitem>
      <listitem>
       <simpara>
	RETURN_STRINGL(s,l,dup)   指定された長さ(l)の文字列(s)を返します。
       </simpara>
      </listitem>
      <listitem>
       <simpara>
	RETURN_DOUBLE(d)
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     RETVAL_* マクロは返り値をセットしますが、関数から戻りません。
     <itemizedlist>
      <listitem><simpara>RETVAL_FALSE</simpara></listitem>
      <listitem><simpara>RETVAL_TRUE</simpara></listitem>
      <listitem><simpara>RETVAL_LONG(l)</simpara></listitem>
      <listitem><simpara>RETVAL_STRING(s,dup)   dup が  &true; の場合、文字列をコピーします。</simpara></listitem>
      <listitem><simpara>RETVAL_STRINGL(s,l,dup)   指定された長さ (l) の文字列 (s) を返します。</simpara></listitem>
      <listitem><simpara>RETVAL_DOUBLE(d)</simpara></listitem>
     </itemizedlist></para>
 
    <simpara>
    上記の文字列マクロは、全て 's' 引数に estrdup() を行います。
     このため、マクロをコールした後、引数を安全に開放することができます。
     他の選択肢としては、静的に確保されたメモリを使用することもできます。</simpara>
 
    <simpara>
    関数が論理値として成功/エラーの応答を返す場合、
    それぞれ RETURN_TRUE および RETURN_FALSE を使用するようにして下さい。</simpara></sect2>
     
   <sect2 id="phpdevel-addfunc-retcomplex">
    <title>複雑な値を返す場合</title>
    <simpara>
    関数はオブジェクトや配列といった複雑なデータ型を返すことも可能です。</simpara>
 
    <para>
    オブジェクトを返すには、次のようにします。
 
     <orderedlist numeration="arabic">
      <listitem><simpara>object_init(return_value) をコールします。</simpara></listitem>
      <listitem><para>オブジェクトを値で埋めます。この際に用いる関数の一覧を
      以下に示します。</para></listitem>
      <listitem><para> 可能ならば、このオブジェクト用の関数を登録します。
      オブジェクトから値を得るために、関数は、active_symbol_table から
      "this" を取得する必要があります。 "this" の型は、IS_OBJECT である必要が
      あります。これは、基本的に通常のハッシュテーブルです。
      (すなわち、.value.ht に通常のハッシュ関数が使用可能です)
      実際の関数の登録は、次のようにして実行できます。
        <programlisting role="c">
<![CDATA[
add_method( return_value, function_name, function_ptr );
]]>
        </programlisting>
       </para>
      </listitem>
     </orderedlist>
    </para>
    <para>
    オブジェクトを操作するための関数を以下に示します。
     <itemizedlist>
      <listitem><simpara>add_property_long( return_value,
        property_name, l ) - long 型で '1' という値を有する 'property_name' という名前のプロパティを追加します</simpara></listitem>
      <listitem><simpara>add_property_double( return_value,
        property_name, d ) - 同じですが、倍精度実数を加えるところが違います。</simpara></listitem>
      <listitem><simpara>add_property_string( return_value,
        property_name, str ) - 同じですが、文字列を加えるところが違います。</simpara></listitem>
      <listitem><simpara>add_property_stringl( return_value,
        property_name, str, l ) - 同じですが、長さ 'l' の文字列を加えるところが違います。</simpara></listitem>
     </itemizedlist></para>
 
    <para>
    配列を返すには次のようにします。
     
     <orderedlist numeration="arabic">
      <listitem><simpara>array_init(return_value) をコールします。</simpara></listitem>
      <listitem><simpara>配列を値で埋めます。この用途に用いる関数の一覧を以下に示します。</simpara></listitem>
     </orderedlist></para>
 
    <para>
    配列を用いるための関数は次のようなものです。
     <itemizedlist>
      <listitem><simpara>add_assoc_long(return_value,key,l) - 
      キー が 'key' のエントリと long 値 'l' を加えます。</simpara></listitem>
      <listitem><simpara>add_assoc_double(return_value,key,d)</simpara></listitem>
      <listitem><simpara>add_assoc_string(return_value,key,str,duplicate)</simpara></listitem>
      <listitem><simpara>add_assoc_stringl(return_value,key,str,length,duplicate)
      文字列の長さを指定します。</simpara></listitem>
      <listitem><simpara>add_index_long(return_value,index,l) - 
      索引が 'index' となるエントリに long 値 'l' を加えます。</simpara></listitem>
      <listitem><simpara>add_index_double(return_value,index,d)</simpara></listitem>
      <listitem><simpara>add_index_string(return_value,index,str)</simpara></listitem>
      <listitem><simpara>add_index_stringl(return_value,index,str,length)
      - 文字列長さを指定します。</simpara></listitem>
      <listitem><simpara>add_next_index_long(return_value,l) - 
      次にアクセスされる配列エントリと long 値 'l' を加えます。</simpara></listitem>
      <listitem><simpara>add_next_index_double(return_value,d)</simpara></listitem>
      <listitem><simpara>add_next_index_string(return_value,str)</simpara></listitem>
      <listitem><simpara>add_next_index_stringl(return_value,str,length)
      - 文字列長さを指定します。</simpara></listitem>
     </itemizedlist></para></sect2>
 
   <sect2 id="phpdevel-addfunc-reslist">
    <title>リソースリストの使用法</title>
    <simpara>
     PHP は様々な型のリソースを処理する標準的な手段を有しています。
     この手段は、PHP 2.0 のリンク付リストを完全に置きかえるものです。
    </simpara>
    <para>
     利用可能な関数:
 
     <itemizedlist>
      <listitem>
       <simpara>
	php3_list_insert(ptr, type) - 新規に挿入されたリソースの
	'id' を返します。
       </simpara>
      </listitem>
      <listitem>
       <simpara>
	php3_list_delete(id) - id で指定されたリソースを削除します。
       </simpara>
      </listitem>
      <listitem>
       <simpara>
	php3_list_find(id,*type) - 指定した id が指すリソースへのポインタを
	返し、type にそのリソースの型を代入します。
       </simpara>
      </listitem>
     </itemizedlist>
 
     通常、これらの関数は SQL ドライバー用に使用されますが、
     ファイル記述子の管理等の他の目的に
     使用することも可能です。
    </para>
 
    <simpara>
     典型的なコードは、次のようになります。
    </simpara>
     
    <para>
     <example>
      <title>新規リソースの追加</title>
      <programlisting role="c">
<![CDATA[
RESOURCE *resource;
 
/* ...リソース用のメモリを確保し、リソースを獲得します... */
/* 新規のリソースをリストに追加します */
return_value->value.lval = php3_list_insert((void *) resource, LE_RESOURCE_TYPE);
return_value->type = IS_LONG;
]]>
      </programlisting>
     </example>
 
     <example>
      <title>既存のリソースの使用法</title>
      <programlisting role="c">
<![CDATA[
pval *resource_id;
RESOURCE *resource;
int type;
 
convert_to_long(resource_id);
resource = php3_list_find(resource_id->value.lval, &type);
if (type != LE_RESOURCE_TYPE) {
php3_error(E_WARNING,"resource index %d has the wrong type",resource_id->value.lval);
	RETURN_FALSE;
}
/* ...リソースを使用します... */
]]>
      </programlisting>
     </example>
 
     <example>
      <title>既存のリソースの削除</title>
      <programlisting role="c">
<![CDATA[
pval *resource_id;
RESOURCE *resource;
int type;
 
convert_to_long(resource_id);
php3_list_delete(resource_id->value.lval);
]]>
      </programlisting>
     </example>
     リソース型は php3_list.h の enum list_entry_type にて登録する必要が
     あります。加えて、全ての新規リソース型の定義の際、
     list.c の list_entry_destructor() の中に shutdown 用のコードを
     加える必要があります。(shutdown の中で何もする必要がない場合でも、
     空のコードを加える必要があります。)
    </para>
   </sect2>
 
   <sect2 id="phpdevel-addfunc-prestable">
    <title>持続的リソーステーブルの使用</title>
    <para>
     PHP は、持続的リソース(すなわち、アクセス間は保持されるリソース)
     を保存する標準的な手段を有しています。
     この機能を用いた最初のモジュールは、MySQL モジュールであり、
     mSQL が後に続きました。
     このため、mysql.c を読むことにより持続的リソースの必要性に関する
     一般的な感覚を得ることができます。    
     見る必要がある関数は次のようなものです。
      <simplelist>
      <member>php3_mysql_do_connect</member>
      <member>php3_mysql_connect()</member>
      <member>php3_mysql_pconnect()</member>
     </simplelist>
    </para>
     <para>
     持続的モジュールの一般的な考えは次のようなものです。
     <orderedlist numeration="arabic">
      <listitem>
       <simpara>
	セクション (9) に記載された標準リソースリストと共に
	動作するモジュール全体をコーディングします。
       </simpara>
      </listitem>
      <listitem>
       <simpara>
	そのリソースが持続的リソースリストに既に存在するかどうかを
	確認する特別な接続関数をコーディングします。
	この作業が完了している場合、標準のリソースリストに
	持続的リソースリストへのポインタとしてこの関数を登録します。
	(1.項により、残りのコードは直ちに動作するはずです。)
	完了していない場合、これを作成した後、持続的リソースリストに加え、
	標準リソースリストにこの関数を指すポインタを加えます。
	この場合、このポインタが標準リソースリストにあるため、
	コード全体が動作します。
	次回接続した際には、そのリソースが持続的リソースリスト
	にあるため、再度作成されることなく使用されます。
	これらのリソースは、別の型として登録する必要があります。
	(例えば、非持続的リンク用に LE_MYSQL_LINK、
	持続的リンク用に LE_MYSQL_PLINK)
       </simpara>
      </listitem>
     </orderedlist>
    </para>
    <simpara>
    mysql.c を読むと、より複雑な接続関数を除いてはモジュールの他の部分を
    変更する必要がないということが分かるでしょう。
    </simpara>
    <simpara>
     'list' が 'plist' に置きかえられるだけで、
     全く同じインターフェースが、標準リソースリストと
     持続的リソースリストに存在します。
    </simpara>
    <itemizedlist>
     <listitem>
      <simpara>
       php3_plist_insert(ptr, type) - 新規に挿入されたリソースの 'id'
       を返します。
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       php3_plist_delete(id) - 指定された id のリソースを削除します。
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       php3_plist_find(id,*type) - 指定された id のリソースへのポインタを返し、
       'type' をそのリソースの型で更新します。
      </simpara>
     </listitem>
    </itemizedlist>
    <simpara>
     しかし、持続的モジュールを実装しようとする際に
     これらの関数が役に立たないことがわかる場合もありえます。
     通常の場合、持続的リソースリストがハッシュテーブルそのものである
     という事実が利用されます。
     例えば、MySQL/mSQL モジュールにおいて、pconnect() コール(持続的接続)
     があった場合、その関数は、関数に渡されるホスト・ユーザー・パスワード
     から文字列を作成します。そして、この文字列をキーとして
     SQL リンクをハッシュに加えます。
     次に誰かが pconnect() を同じホスト・ユーザー・パスワードでコール
     した場合、同じキーが生成されます。
     この場合、この関数は持続的リンクのリストにある SQL リンクを見つけます。
    </simpara>
    <simpara>
     より詳細な記述が行われるようになるまで、
     plist のハッシュテーブル機能の使用法を知るためには、
     mysql.c または msql.c を見る必要があります。
    </simpara>
    <simpara>
     注意すべき重要な点:持続的リソースリストに加えられるリソースは、
     PHP のメモリーマネージャで確保されたものであってはなりません。
     すなわち、emalloc(),estrdup()等で生成されたものであってはなりません。
     むしろ、通常の malloc(),strdup() 等を使用するべきです。
     その理由は単純です。リクエストの終了時(ヒットの終了時)に
     PHP のメモリーマネージャを使用して確保された全てのメモリー領域は、
     削除されるからです。
     持続的リストは、リクエストの終了時に消去されるようにはなっていないので、
     このようなリソース確保するために
     PHPのメモリーマネージャを使用するべきではありません。
    </simpara>
    <simpara>
     持続的リストに加えようとするリソースを登録する際に、
     非持続的リストと持続的リストの両方にデストラクタを
     加える必要があります。
     非持続的リストのデストラクタは、何もする必要がありません。
     持続的リストのデストラクタは、この型により得られた全ての
    リソース(例えば、メモリー、SQLリンク、等)を開放する必要が
     あります。
     非持続的リソースと全く同様に、全てのリソースについてデストラクタ
     を備える必要があります。
     破棄を要する必要がない場合には、デストラクタは空とすることができます。
     emalloc() とその派生したものは、持続的リストに関連して
     使用するべきではなく、このような場合、efree() も使うべきではないという
     ことを覚えておいてください。
    </simpara>
   </sect2>
 
   <sect2 id="phpdevel-addfunc-addcfg">
    <title>実行時設定命令の追加</title>
    <para>
     PHPの機能の多くは、実行時に設定を行うことが可能です。
     これらの設定用命令は、php3.ini ファイルまたは、Apache モジュール版の
     場合、Apache .conf ファイルに書かれています。
     この Apache .conf ファイルの中にこれらを記載することの利点は、
     ディレクトリ毎に設定が可能なことです。
     これは、例えばあるディレクトリはある safemodeexecdir を
     有しているとき、他のディレクトリは、別のものを指定することが
     できることを意味します。
     この設定のきめの細かさは、サーバーが複数の仮想ホストを
     サポートする場合に特に便利です。
    </para>
    <para>
     新しい命令を加えるために必要な手順は次のようなものです。
 
     <orderedlist>
      <listitem>
       <simpara>
	mod_php3.h にある php3_ini_structureに命令を加えます。
       </simpara>
      </listitem> 
      <listitem>
       <simpara>
	main.c の php3_module_startup 関数を編集し、適当なcfg_get_string()
	またはcfg_get_long()コールを加えます。
       </simpara>
      </listitem> 
      <listitem>
       <simpara>
	mod_php3.c の php3_commands 構造体に命令、制約、コメントを
	加えます。制約の部分を記録しておいて下さい。
	RSRC_CONFは、Apache .conf ファイルにのみある命令です。
	OR_OPTIONS命令は、通常の .htaccessファイルを含むあらゆる
	場所に置くことができます。
       </simpara>
      </listitem> 
       <listitem>
       <simpara>
	php3take1handler()またはphp3flaghandler()はどちらも命令に
	関する適当なエントリを追加します。
       </simpara>
      </listitem> 
       <listitem>
       <simpara>
	functions/info.c 中の _php3_info() 関数の
	設定セクションに、新しい命令を追加する必要があります。
       </simpara>
      </listitem> 
       <listitem>
       <simpara>
	最後に、もちろん、新しい命令をどこかで使う必要があります。
	この命令は、php3_ini.命令 としてアクセスできます。
       </simpara>
      </listitem> 
     </orderedlist>
    </para>
   </sect2>
  </sect1>
  
  <sect1 id="calling-user-functions">
   <title>ユーザー関数のコール方法</title>
 
   <simpara>
   ユーザー関数を内部関数からコールするには、
    <function>call_user_function</function> 関数を
    使用する必要があります。
   </simpara>
 
   <simpara>
    <function>call_user_function</function> は成功時に SUCCESS、
    関数を見つけられなかった場合に FAILURE を返します。
    返り値を確認する必要があります!
    SUCCESS が返された場合、
    retval pval 自体(または関数からの返り値として
    それを返す)を破棄する責任があります。
    FAILURE が返された場合、retval の値は未定義であり、参照することは
    できません。
   </simpara>
 
   <simpara>
   ユーザー関数をコールする全ての内部関数は、再入可能(reentrant)
   である <emphasis>必要があります</emphasis>。
   特に、このことは、グローバルまたは静的変数を使用するべきでは
   ないということを意味します。
   </simpara>
 
   <simpara>
    <function>call_user_function</function> は次の 6個の引数をとります。
   </simpara>
   
   <sect2 id="calling-user-functions.function-table">
    <title>HashTable *function_table</title>
    <simpara>
     これは、関数を参照できるハッシュテーブルです。
    </simpara>
   </sect2>
   
   <sect2 id="calling-user-functions.object">
    <title>pval *object</title>
    <simpara>
     これは、関数がコールされるオブジェクトへのポインタです。
     グローバル関数がコールされた場合、このポインタは、&null; で
     ある必要があります。
     &null; でない (すなわち、オブジェクトを指している)場合、
     function_table 引数は無視され、かわりにオブジェクトのハッシュから
     とられます。
     オブジェクトは、コールした関数により修正可能な場合があります。
     (関数は、$this によりアクセスすることが可能です。)
     何らかの理由で、こうしたことを避けたい場合、
     オブジェクトのコピーを代わりに送付します。    
    </simpara>
   </sect2>
 
   <sect2 id="calling-user-functions.function-name">
    <title>pval *function_name</title>
    <simpara>
     コールする関数の名前。
     function_name.str.val および function_name.str.len に適当な
     値を設定した IS_STRING 型の pval である必要があります。
     function_name は、call_user_function() により修正されます。
     この時、function_name は、小文字に変換されます。
     大文字・小文字を保存する必要がある場合、関数名のコピーを代わりに
     送って送ってください。
    </simpara>
   </sect2>
 
   <sect2 id="calling-user-functions.retval">
    <title>pval *retval</title>
    <simpara>
    コールされた関数の返り値が保存された pval 構造体へのポインタ。
    構造体は、事前に確保されたものである必要があります。
     <function>call_user_function</function> はそれ自体では
     リソースの確保を行いません。
    </simpara></sect2>
 
   <sect2 id="calling-user-functions.param-count">
    <title>int param_count</title>
    <simpara>
    関数に渡されたパラメータの数
     </simpara></sect2>
 
   <sect2 id="calling-user-functions.params">
    <title>pval *params[]</title>
    <simpara>
     関数の引数として渡される値へのポインタの配列、最初の引数は
     オフセット 0 にあり、2番目はオフセット 1 にあります。
     配列は、pval へのポインタの配列です。
     ポインタは、関数にそのまま送られます。
     このことは、関数が引数を修正した場合、元の値が変更される(参照渡し)
     ことを意味します。
     この動作が好ましくない場合、コピーを代わりに渡してください。
    </simpara>
   </sect2>
  </sect1>
  
  <sect1 id="phpdevel-errors">
   <title>エラーの出力</title>
   
   <simpara>
    内部関数からエラーを出力するには、<function>php3_error</function> を
    コールする必要があります。この関数は、少なくとも 2 つの引数をとります。
    1 番目の引数はエラーのレベル、2 番目の引数はエラーメッセージの
    (通常の <function>printf</function> と同じ形式の)フォーマット文字列、
    以降の引数はフォーマット文字列で使用するパラメータです。
    エラーレベルは次のようになります。
   </simpara>
   
   <sect2 id="internal.e-notice">
    <title>E_NOTICE</title>
    <simpara>
     デフォルトで通知(NOTICE)は表示されません。
     これは、スクリプト実行時に何かエラーが発生したが、
     通常のスクリプト実行を継続できることを示します。
     例えば、値が設定されていない変数にアクセスしようとした場合や、
     存在しないファイルについて <function>stat</function> をコールした場合
     です。
    </simpara>
   </sect2>
   
   <sect2 id="internal.e-warning">
    <title>E_WARNING</title>
    <simpara>
     警告(WARNING) はデフォルトで出力されますがスクリプトの実行を
     中断しません。
     このエラーは、コール前にスクリプトにより取り除いておくべき
     問題があることを示します。
     例えば、無効な正規表現で<function>ereg</function>をコールした場合です。
    </simpara>
   </sect2>

   <sect2 id="internal.e-error">
    <title>E_ERROR</title>
    <simpara>
     エラーもデフォルトで出力されます。
     関数からリターンした後、スクリプトの実行は中止されます。
     このエラーは、メモリ確保に関する問題等の回復不可能なエラーが
     発生したことを示します。
    </simpara>
   </sect2>

   <sect2 id="internal.e-parse">
    <title>E_PARSE</title>
    <simpara>
     パーサエラーは、パーサにより生成されます。ここで表示されるコードは、
     あくまでも補完的なものです。
    </simpara>
  </sect2>
   
  <sect2 id="internal.e-core-error">
   <title>E_CORE_ERROR</title>
    <simpara>
     PHP のコアにより生成される点を除いて、E_ERROR と同じです。
     関数は、このタイプのエラーを生成しません。
    </simpara>
   </sect2>

   <sect2 id="internal.e-core-warning">
    <title>E_CORE_WARNING</title>
    <simpara>
     PHP のコアにより生成される点を除いて、E_WARNING と同じです。
     関数は、このタイプのエラーを生成しません。
    </simpara>
   </sect2>
   
   <sect2 id="internal.e-compile-error">
    <title>E_COMPILE_ERROR</title>
    <simpara>
     E_ERRORに似ていますが、Zendスクリプトエンジンにより生成されたもの
     であるというところが異なります。関数は、この型のエラーを生成しません。
    </simpara>
   </sect2>
   
   <sect2 id="internal.e-compile-warning">
    <title>E_COMPILE_WARNING</title>
    <simpara>
     E_WARNINGに似ていますが、Zendスクリプトエンジンにより生成されたもの
     であるというところが異なります。関数は、この型のエラーを生成しません。
    </simpara>
   </sect2>
   
   <sect2 id="internal.e-user-error">
    <title>E_USER_ERROR</title>
   <simpara>
     E_ERRORに似ていますが、PHP関数<function>trigger_error</function>
     を使用することによりPHPコード内で生成されたものであるというところが
     異なります。関数はこの型のエラーを生成しません。
    </simpara>
   </sect2>
   
   <sect2 id="internal.e-user-warning">
    <title>E_USER_WARNING</title>
    <simpara>
     E_WARNINGに似ていますが、PHP関数<function>trigger_error</function>
     を使用することによりPHPコード内で生成されたものであるというところが
     異なります。関数はこの型のエラーを生成しません。
    </simpara>
   </sect2>

   <sect2 id="internal.e-user-notice">
    <title>E_USER_NOTICE</title>
    <simpara>
     E_NOTICEに似ていますが、PHP関数<function>trigger_error</function>
     を使用することによりPHPコード内で生成されたものであるというところが
     異なります。関数はこの型のエラーを生成しません。
   </simpara>
   </sect2>

  <sect2 id="internal.e-all">
   <title>E_ALL</title>
   <simpara>
    上記の全て。このエラーレポートレベルを使うと
    全てのタイプのエラーが生成されます。
   </simpara>
  </sect2>

  </sect1>

</appendix>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
