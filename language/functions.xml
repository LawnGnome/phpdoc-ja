<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 297028 Maintainer: hirokawa Status: ready -->
<!-- CREDITS: takagi -->
 <chapter xml:id="language.functions" xmlns="http://docbook.org/ns/docbook">
  <title>関数</title>
  
  <sect1 xml:id="functions.user-defined">
   <title>ユーザー定義関数</title>
 
   <para>
    関数は次のような構文で定義されます。
   </para>
   <para>
    <example>
     <title>関数の使用法を説明するための擬似コード</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo($arg_1, $arg_2, /* ..., */ $arg_n)
{
    echo "関数の例\n";
    return $retval;
}
?>
]]>
     </programlisting>
    </example>
   </para>
     
   <simpara>
    関数の中では、他の関数や <link linkend="keyword.class">クラス</link> 定義
    を含む PHP のあらゆる有効なコードを使用することができます。
   </simpara>
   <para>
    関数名は、PHP の他のラベルと同じ規則に従います。関数名として有効な
    形式は、まず文字かアンダースコアで始まり、その後に任意の数の文字・
    数字・あるいはアンダースコアが続くものです。正規表現で表すと、
    <literal>[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*</literal>
    となります。
   </para>
   &tip.userlandnaming;
   <simpara>
    PHP では、関数は参照される前に定義されている必要はありません。
    ただし以下の二つの例のように、条件付きで関数が
    定義されるような場合を<emphasis>除きます</emphasis>。
   </simpara>
   <para>
    次の二つの例のように、ある条件下でのみ関数が定義される場合には、
    その関数定義は関数がコールされる<emphasis>前に</emphasis>
    行われていなければなりません。
   </para>
   <para>
    <example>
     <title>条件つきの関数</title>
     <programlisting role="php">
<![CDATA[
<?php

$makefoo = true;

/* ここでは関数foo()はまだ定義されていないので
   コールすることはできません。
   しかし関数 bar()はコールできます。 */

bar();

if ($makefoo) {
  function foo()
  {
    echo "I don't exist until program execution reaches me.\n";
  }
}

/* ここでは $makefooがtrueと評価されているため 
   安全にfoo()をコールすることができます。 */

if ($makefoo) foo();

function bar() 
{
  echo "I exist immediately upon program start.\n";
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>関数の中の関数</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo() 
{
  function bar() 
  {
    echo "I don't exist until foo() is called.\n";
  }
}

/* ここでは関数bar()はまだ定義されていないので
   コールすることはできません。 */

foo();

/* foo()の実行によって bar()が
   定義されるためここではbar()を
   コールすることができます。*/

bar();

?>  
]]>
     </programlisting>
    </example>
   </para>
   <para>
    PHP では、関数やクラスはすべてグローバルスコープにあります -
    関数の内部で定義したものであっても関数の外部からコールできますし、
    その逆も可能です。
   </para>
   <simpara>
    PHP は関数のオーバーロードをサポートしていません。
    また、宣言された関数の定義を取り消したり再定義することも
    できません。
   </simpara>
   <note>
    <simpara>
     関数名は大文字小文字を区別しませんが、通常は
     関数宣言時と同じ名前で関数をコールする方が好ましいです。
    </simpara>
   </note>   
   <simpara>
    <link linkend="functions.variable-arg-list">可変引数</link>
    および <link linkend="functions.arguments.default">デフォルト引数</link>
    の機能をサポートしています。
    <function>func_num_args</function>,
    <function>func_get_arg</function>, 
    <function>func_get_args</function> に関する関数リファレンスを
    参照ください。
   </simpara>
   
   <para>
    PHP では、関数を再帰的にコールすることが可能です。ただし、100 から 200
    を超えるような再帰呼び出しは避けてください。そんなことをすると、
    スタックが破壊され、スクリプトが異常終了してしまいます。
    <example>
     <title>再帰的な関数</title>
     <programlisting role="php">
<![CDATA[
<?php
function recursion($a)
{
    if ($a < 20) {
        echo "$a\n";
        recursion($a + 1);
    }
}
?>
]]>
     </programlisting>
    </example>
   </para>

  </sect1>
 
  <sect1 xml:id="functions.arguments">
   <title>関数の引数</title>
 
   <simpara>
    引数のリストにより関数へ情報を渡すことができます。
    このリストは、カンマで区切られた式のリストです。
   </simpara>
   <para>
    PHP は、値渡し(デフォルト)、
    <link linkend="functions.arguments.by-reference">参照渡し</link>、
    <link linkend="functions.arguments.default">デフォルト引数値</link>
    をサポートしています。また、
    <link linkend="functions.variable-arg-list">可変長引数リスト</link>
    もサポートしてます。
    <function>func_num_args</function>,
    <function>func_get_arg</function>, 
    <function>func_get_args</function> に関する関数リファレンスを
    参照ください。
   </para>
   <para>
    <example>
     <title>Passing arrays to functions</title>
     <programlisting role="php">
<![CDATA[
<?php
function takes_array($input)
{
    echo "$input[0] + $input[1] = ", $input[0]+$input[1];
}
?>
]]>
     </programlisting>
    </example>
   </para>
   
   <sect2 xml:id="functions.arguments.by-reference">
    <title>参照渡しで引数を作成する</title>
 
    <simpara>
     デフォルトで、関数の引数は値で渡されます。(このため、関数の内部で
     引数の値を変更しても関数の外側では値は変化しません。)関数がその引
     数を修正できるようにするには、その引数を参照渡しとする必要があり
     ます。
    </simpara>
    <para>
     関数の引数を常に参照渡しとしたい場合には、関数定義において
     アンパサンド(&amp;) を引数名の前に付加することができます。    
    </para>
    <para>
     <example>
      <title>Passing function parameters by reference</title>
      <programlisting role="php">
<![CDATA[
<?php
function add_some_extra(&$string)
{
    $string .= 'and something extra.';
}
$str = 'This is a string, ';
add_some_extra($str);
echo $str;    // outputs 'This is a string, and something extra.'
?>
]]>
      </programlisting>
     </example>
    </para>
 
   </sect2>
 
   <sect2 xml:id="functions.arguments.default">
    <title>デフォルト引数値</title>
    
    <para>
     関数は、スカラー引数に関して次のように C++ スタイルのデフォルト値を
     定義することができます。
    </para>
    <para>
     <example>
      <title>関数におけるデフォルトパラメータの使用法</title>
      <programlisting role="php">
<![CDATA[
<?php
function makecoffee($type = "cappuccino")
{
    return "Making a cup of $type.\n";
}
echo makecoffee();
echo makecoffee(null);
echo makecoffee("espresso");
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Making a cup of cappuccino.
Making a cup of .
Making a cup of espresso.
]]>
      </screen>
     </example>
    </para>
    <para>
     PHPでは、配列および特殊な型 &null; をデフォルト値とすることも可能です。
     例えば、
    </para>
    <para>
     <example>
      <title>スカラー型以外をデフォルト値として使用する</title>
      <programlisting role="php">
<![CDATA[
<?php
function makecoffee($types = array("cappuccino"), $coffeeMaker = NULL)
{
    $device = is_null($coffeeMaker) ? "hands" : $coffeeMaker;
    return "Making a cup of ".join(", ", $types)." with $device.\n";
}
echo makecoffee();
echo makecoffee(array("cappuccino", "lavazza"), "teapot");
?>
]]>
      </programlisting>
     </example>
    
    </para>
    <simpara>
     デフォルト値は、定数式である必要があり、
     (例えば) 変数やクラスのメンバーであってはなりません。
    </simpara>
    <para>
     引数のデフォルト値を使用する際には、デフォルト値を有する引数はデ
     フォルト値がない引数の右側に全てある必要があることに注意して下さ
     い。そうでない場合、意図したような動作が行われません。次の簡単な
     コードを見てみましょう。
    </para>
    <para>
     <example>
      <title>関数の引数のデフォルト値の 間違った使用法</title>
      <programlisting role="php">
<![CDATA[
<?php
function makeyogurt($type = "acidophilus", $flavour)
{
    return "Making a bowl of $type $flavour.\n";
}
 
echo makeyogurt("raspberry");   // 期待通りには動作しません。
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Warning: Missing argument 2 in call to makeyogurt() in 
/usr/local/etc/httpd/htdocs/phptest/functest.html on line 41
Making a bowl of raspberry .
]]>
      </screen>
     </example>
    </para>
    <para>
     ここで、上の例を次のコードと比べてみましょう。
    </para>
    <para>
     <example>
      <title>関数の引数のデフォルト値の 正しい使用法</title>
      <programlisting role="php">
<![CDATA[
<?php
function makeyogurt($flavour, $type = "acidophilus")
{
    return "Making a bowl of $type $flavour.\n";
}
 
echo makeyogurt("raspberry");   // 期待通り動作します
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Making a bowl of acidophilus raspberry.
]]>
      </screen>
     </example>
    </para>
    <note>
     <simpara>
      PHP 5以降、デフォルトで値はリファレンス渡しとなります。
     </simpara>
    </note>
   </sect2>

   <sect2 xml:id="functions.variable-arg-list">
    <title>可変長引数リスト</title>
    
    <simpara>
     PHP 4 以降は、可変長引数をユーザー定義関数でサポートしています。
     可変長引数の使用法は非常に簡単で、
     <function>func_num_args</function>,
     <function>func_get_arg</function>, 
     <function>func_get_args</function> 関数を使用します。
    </simpara>
    
    <simpara>
     可変長引数に関して特別な構文は必要としません。
     引数リストは従来と同様に関数定義で明示的に指定することができ、
     動作も従来と変わりません。
    </simpara>
    
   </sect2>
   
  </sect1>
 
  <sect1 xml:id="functions.returning-values">
   <title>返り値</title>
 
   <para>
    オプションの return 文により値を返すことができます。
    配列やオブジェクトを含むあらゆる型を返すことができます。
    これにより、関数の実行を任意の箇所で終了し、その関数を呼び出した
    箇所に制御を戻すことが出来ます。詳細に関しては
    <function>return</function>を参照してください。
   </para>
   <note>
    <para>
     <function>return</function> を省略した場合は &null; を返します。
    </para>
   </note>
   <para>
    <example>
     <title><function>return</function>の使用法</title>
     <programlisting role="php">
<![CDATA[
<?php
function square($num)
{
    return $num * $num;
}
echo square(4);   //  '16'を出力
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    複数の値を返すことはできませんが、リストを返すことにより
    同じ効果を得ることができます。
   </para>
   <para>
    <example>
     <title>複数の値を得るために配列を返す</title>
     <programlisting role="php">
<![CDATA[
<?php
function small_numbers()
{
    return array (0, 1, 2);
}
list ($zero, $one, $two) = small_numbers();
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    関数からリファレンスを返すには、リファレンス演算子 &amp; を関数宣
    言部および変数への返り値を代入する際の両方で使用する必要があります。
   </para>
   <para>
    <example>
     <title>関数からリファレンスを返す</title>
     <programlisting role="php">
<![CDATA[
<?php
function &returns_reference()
{
    return $someref;
}

$newref =& returns_reference();
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    リファレンスに関するさらに詳しい情報が<link 
    linkend="language.references">リファレンスの説明</link>にあります。
   </simpara>
  </sect1>

  <sect1 xml:id="functions.variable-functions">
   <title>可変関数</title>
 
   <para>
    PHP は可変関数(variable functions)の概念をサポートします。
    これにより、変数名の後に括弧が付いている場合、その値が何であろうと
    PHPは、同名の関数を探し実行を試みます。
    この機能は、コールバック、関数テーブル等を実装するために使用可能です。
   </para>
   <para>
    可変関数は、<function>echo</function>, <function>unset</function>,
    <function>isset</function>, <function>empty</function>, 
    <function>include</function>, <function>print</function>
    のような言語構造と組み合わせて使用する
    ことはできません。これらの言語構造を可変変数として使うには
    独自のラッパ関数を使う必要があります。
   </para> 
   <para>
    <example>
     <title>可変関数の例</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo()
{
    echo "In foo()<br />\n";
}

function bar($arg = '')
{
    echo "In bar(); argument was '$arg'.<br />\n";
}

// This is a wrapper function around echo
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // This calls foo()

$func = 'bar';
$func('test');  // This calls bar()

$func = 'echoit';
$func('test');  // This calls echoit()
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    オブジェクトのメソッドを可変関数を使ってコールすることもできます。
    <example>
     <title>可変メソッドの例</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Variable()
    {
        $name = 'Bar';
        $this->$name(); // Bar() メソッドのコール
    }
    
    function Bar()
    {
        echo "This is Bar";
    }
}

$foo = new Foo();
$funcname = "Variable";
$foo->$funcname();  // $foo->Variable() をコールする

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <link linkend="language.variables.variable">可変変数</link>や
    <function>function_exists</function>も参照してください。
   </para>
   
  </sect1>

  <sect1 xml:id="functions.internal">
   <title>内部（ビルトイン）関数</title>
   
   <para>
    PHPは標準で多くの関数と言語構造を持っています。また他にも
    コンパイル済みの特定のPHPエクステンションを必要とする関数があります。
    それらはもしコンパイルされていなければ"undefined function（未定義の関数）"
    として致命的エラーを発するでしょう。例えば、
    <function>imagecreatetruecolor</function>のような
    <link linkend="ref.image">画像</link>関数を使用するには、
    <productname>GD</productname>サポートを有効にしてPHPをコンパイルしておく必要があります。
    また、<function>mysql_connect</function>を使う場合もやはり
    <link linkend="ref.mysql">MySQL</link>サポートを有効にしてPHPが
    コンパイルされている必要があります。
    <link linkend="ref.strings">string</link>や
    <link linkend="ref.var">variable</link>関数のように
    どのバージョンのPHPでも含まれているコアの関数もたくさんあります。
    <function>phpinfo</function>や<function>get_loaded_extensions</function>を
    コールすることで使用しているPHPにロードされているエクステンションを
    見ることができます。また、多くのエクステンションはデフォルトで有効に
    なっており、PHPのマニュアルはエクステンション毎に分けられていることにも
    注意してください。PHPのセットアップについては
    <link linkend="configuration">設定</link>,  
    <link linkend="install">インストール</link>,そして個々のエクステンション
    の項をご覧ください。
   </para>
   <para>
    関数のプロトタイプに関する解説はマニュアルの
    <link linkend="about.prototypes">関数の定義を読むには</link>を
    参照してください。関数の戻り値や引数が直接与えられた場合に
    どのように動くかを認識することは重要です。
    例えば、<function>str_replace</function>は変更された文字列を
    返すのに対し、<function>usort</function>は与えられた引数そのものを
    変更します。マニュアルの各項にはそれぞれの関数に関する情報があります。
    関数の引数、振る舞いの変更、成功した場合失敗した場合の
    それぞれの戻り値、可用性に関する情報などです。
    これらの重要な（時には微妙な）違いを知ることは、
    正しいPHPコードを書くうえで極めて重要なことです。
   </para>
   <note>
    <simpara>
     関数へのパラメータとして関数が想定しているのとは異なるものを渡した場合、
     例えば文字列を想定しているところに配列を渡した場合などの場合は
     関数の返り値は未定義となります。たいていの場合は
     &null; を返すでしょう。しかしこれはあくまでも規約にすぎず、
     これに依存することはできません。
    </simpara>
   </note>
   <para>
    <function>function_exists</function>, 
    <link linkend="funcref">the function reference</link>,
    <function>get_extension_funcs</function>, 
    <function>dl</function>も参照してください。
   </para>
  </sect1>
  
  <sect1 xml:id="functions.anonymous">
   <title>無名関数</title>

   <simpara>
    無名関数は<literal>クロージャ</literal>とも呼ばれ、
    関数名を指定せずに関数を作成できるようにするものです。
    <link linkend="language.types.callback">コールバック</link>
    パラメータとして使う際に便利ですが、用途はそれにとどまりません。
   </simpara>

   <example>
    <title>無名関数の例</title>
    <programlisting role="php">
<![CDATA[
<?php
echo preg_replace_callback('~-([a-z])~', function ($match) {
    return strtoupper($match[1]);
}, 'hello-world');
// helloWorld と出力します
?>
]]>
    </programlisting>
   </example>

   <simpara>
    クロージャは、変数の値として使用することもできます。
    PHP は、そのような記述があると自動的に内部クラス
    <classname>Closure</classname> のインスタンスに変換します。
    変数へのクロージャの代入は、他の代入と同じように記述し、
    同じく最後にセミコロンをつけます。
   </simpara>

   <example>
    <title>変数への無名関数の代入</title>
    <programlisting role="php">
<![CDATA[
<?php
$greet = function($name)
{
    printf("Hello %s\r\n", $name);
};

$greet('World');
$greet('PHP');
?>
]]>
    </programlisting>
   </example>
   
   <simpara>
    クロージャは、変数を親のスコープから引き継ぐことができます。
    引き継ぐ変数は、関数のヘッダで宣言しなければなりません。
    親のスコープからの変数の引き継ぎは、グローバル変数を使うのとは
    <emphasis>異なります</emphasis>。グローバル変数は、
    関数が実行されるかどうかにかかわらずグローバルスコープに存在します。
    クロージャの親スコープは、クロージャが宣言されている関数です
    (関数の呼び出し元のスコープである必要はありません)。
    次の例を参照ください。
   </simpara>

   <example>
    <title>クロージャのスコープ</title>
    <programlisting role="php">
<![CDATA[
<?php
// 基本的なショッピングカートで、追加した商品の一覧や各商品の
// 数量を表示します。カート内の商品の合計金額を計算するメソッド
// では、クロージャをコールバックとして使用します。
class Cart
{
    const PRICE_BUTTER  = 1.00;
    const PRICE_MILK    = 3.00;
    const PRICE_EGGS    = 6.95;

    protected   $products = array();
    
    public function add($product, $quantity)
    {
        $this->products[$product] = $quantity;
    }
    
    public function getQuantity($product)
    {
        return isset($this->products[$product]) ? $this->products[$product] :
               FALSE;
    }
    
    public function getTotal($tax)
    {
        $total = 0.00;
        
        $callback =
            function ($quantity, $product) use ($tax, &$total)
            {
                $pricePerItem = constant(__CLASS__ . "::PRICE_" .
                    strtoupper($product));
                $total += ($pricePerItem * $quantity) * ($tax + 1.0);
            };
        
        array_walk($this->products, $callback);
        return round($total, 2);
    }
}

$my_cart = new Cart;

// カートに商品を追加します
$my_cart->add('バター', 1);
$my_cart->add('牛乳', 3);
$my_cart->add('卵', 6);

// 合計に消費税 5% を付加した金額を表示します
print $my_cart->getTotal(0.05) . "\n";
// 結果は 54.29 です
?>
]]>
    </programlisting>
   </example>
   
   <simpara>
    無名関数は、現在は
    <link linkend="reserved.classes.closure">
    <classname>Closure</classname></link> クラスで実装されています。
    これはあくまでも内部実装の問題であり、この事実に依存したコードを書いてはいけません。
   </simpara>
   
   <note>
    <simpara>
     無名関数は PHP 5.3.0 以降で使用可能です。
    </simpara>
   </note>

   <note>
    <simpara>
     クロージャ内から <function>func_num_args</function>、
     <function>func_get_arg</function> および <function>func_get_args</function>
     を使用することができます。
    </simpara>
   </note>

  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
