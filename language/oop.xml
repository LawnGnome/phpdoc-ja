 <chapter id="language.oop">
  <title>クラスとオブジェクト</title>

  <sect1 id="keyword.class">
   <title><literal>クラス</literal></title>
   <para>
    クラスは、変数およびこれらの変数で動作する関数の集まりです。
    クラスは次のような構文により定義されます。
 
     <informalexample>
      <programlisting role="php">
&lt;?php
class Cart {
    var $items;  // 買い物篭の中のアイテム
   
    // $num 個の $artnr を買い物篭に加えます
 
    function add_item ($artnr, $num) {
        $this->items[$artnr] += $num;
    }
   
    // $num 個の $artnr を買い物籠から出します
 
    function remove_item ($artnr, $num) {
        if ($this->items[$artnr] > $num) {
            $this->items[$artnr] -= $num;
            return true;
        } else {
            return false;
        }   
    }
}
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <para>
    この例は、籠の中の物と籠にアイテムを加えたり除いたりする二つの関数への
    連想配列からなる Cart という名前のクラスを定義します。
   </para>

   <caution>
    <simpara>
     以下の注意書きはPHP 4に関するものです。
    </simpara>
    
    <simpara>
     名前<literal>stdClass</literal>は、Zendにより内部的に使用され、保
     存されています。PHPで<literal>stdClass</literal>という名前のクラ
     スを使用することはできません。
    </simpara>
    
    <simpara>
     The function names <literal>__sleep</literal> and
     <literal>__wakeup</literal> are magical in PHP classes. You
     cannot have functions with these names in any of your
     classes unless you want the magic functionality associated
     with them. See below for more information.
    </simpara>
    
    <simpara>
     PHP reserves all function names starting with __ as magical.
     It is recommended that you do not use function names with
     __ in PHP unless you want some documented magic functionality.
    </simpara>
   </caution>
   
   <note>
    <simpara>
     PHP 4では、変数<literal>var</literal>については定数による初期化の
     みが可能です。定数以外で初期化を行う場合には初期化関数が必要です。
     この初期化関数は、オブジェクトがクラスから構築される際に自動的に
     コールされます。このような関数はコンストラクタと呼ばれます。(以下
     参照)
    </simpara>
    <informalexample>
     <programlisting role="php">
/* 以下のコードはPHP 4では動作しません。 */
class Cart {
    var $todays_date = date("Y-m-d");
    var $name = $firstname;
    var $owner = 'Fred ' . 'Jones';
}

/* 以下に正しい方法を示します。 */
class Cart {
    var $todays_date;
    var $name;
    var $owner;

    function Cart() {
        $this->todays_date = date("Y-m-d");
        $this->name = $GLOBALS['firstname'];
        /* 等など. . . */
    }
}
     </programlisting>
    </informalexample>
   </note>
   <para>
    クラスは型、つまり、実際の変数の雛型です。<literal>new</literal>演
    算子により所望の型の変数を作成する必要があります。
   </para>
 
   <informalexample>
    <programlisting role="php">
  $cart = new Cart;
  $cart->add_item("10", 1);

  $another_cart = new Cart;
  $another_cart->add_item("0815", 3);
    </programlisting>
   </informalexample>
 
   <para>
    この例は、クラスCartのオブジェクト $cartおよび$another_cartを作成
    します。$cartオブジェクトの関数 add_item()が商品番号10の商品一つが
    カートに追加されています。商品番号0815の商品3つが$another_cartに追
    加されています。
   </para>

   <para>
    Both, $cart and $another_cart, have functions add_item(),
    remove_item() and a variable items. These are distinct
    functions and variables. You can think of the objects as
    something similar to directories in a filesystem. In a
    filesystem you can have two different files README.TXT, as
    long as they are in different directories.  Just like with
    directories where you'll have to type the full pathname in
    order to reach each file from the toplevel directory, you
    have to specify the complete name of the function you want
    to call: In PHP terms, the toplevel directory would be the
    global namespace, and the pathname separator would be -&gt;. 
    Thus, the names $cart-&gt;items and $another_cart-&gt;items
    name two different variables. Note that the variable is
    named $cart-&gt;items, not $cart-&gt;$items, that is, a
    variable name in PHP has only a single dollar sign.
   </para>

   <informalexample>
    <programlisting role="php">
// correct, single $
$cart->items  = array("10" => 1); 

// invalid, because $cart->$items becomes $cart->""
$cart->$items = array("10" => 1);

// correct, but may or may not be what was intended:
// $cart->$myvar becomes $ncart->items
$myvar = 'items';
$cart->$myvar = array("10" => 1);  
    </programlisting>
   </informalexample>

   <para>
    Within a class definition, you do not know under which name the object will
    be accessible in your program: At the time the Cart class was 
    written, it was unknown that the object will be named $cart or
    $another_cart later. Thus, you cannot write $cart-&gt;items within
    the Cart class itself. Instead, in order to be able to access it's own
    functions and variables from within a class, one can use the
    pseudo-variable $this which can be read as 'my own' or
    'current object'. Thus, '$this->items[$artnr] += $num' can
    be read as 'add $num to the $artnr counter of my own items
    array' or 'add $num to the $artnr counter of the items array
    within the current object'.
   </para>
  </sect1>
  
  <sect1 id="keyword.extends">
   <title><literal>extends</literal></title>

   <para>
    Often you need classes with similar variables and functions
    to another existing class. In fact, it is good practice to
    define a generic class which can be used in all your
    projects and adapt this class for the needs of each of your
    specific projects. To facilitate this, Classes can be
    extensions of other classes.  The extended or derived class
    has all variables and functions of the base class (this is
    called 'inheritance' despite the fact that nobody died) and what
    you add in the extended definition. It is not possible to
    substract from a class, that is, to undefine any existing 
    functions or variables. An extended class is always dependent
    on a single base class, that is, multiple inheritance is
    not supported. Classes are extended using the keyword 'extends'.
   </para>

   <informalexample>
    <programlisting role="php">
class Named_Cart extends Cart {
    var $owner;
  
    function set_owner ($name) {
        $this->owner = $name;
    }
}
    </programlisting>
   </informalexample>
 
   <para>
    この例は、Cart の全ての変数及び関数に加えて変数 $owner と
    関数 set_owner() を保持するクラス Named_Cart を定義しています。
    この定義により、名前付きの籠を通常の手段で作成し、籠の保有者を
    設定したり得たりすることができます。
    名前付きの籠で元の籠クラスの関数を使うことも可能です。
   </para>
 
   <informalexample>
    <programlisting role="php">
$ncart = new Named_Cart;    // 名前付きの籠を作成
$ncart->set_owner ("kris"); // 籠の所有者の名前を設定
print $ncart->owner;        // 籠の所有者を出力
$ncart->add_item ("10", 1); // (籠から継承された機能)
    </programlisting>
   </informalexample>
  
  </sect1>

  <sect1 id="language.oop.constructor">
   <title><literal>コンストラクタ</literal></title>

   <caution>
    <simpara>
     In PHP 3 and PHP 4 constructors behave differently. The PHP 4
     semantics are strongly preferred.
    </simpara>
   </caution>

   <para>
    コンストラクタは、<literal>new</literal>によりクラスの新しいインス
    タンスを作成する際に自動的にコールされるクラス関数です。
    PHP 3では、ある関数が、クラス名と同じ名前を有している場合にコンス
    トラクタになりました。PHP 4では、ある関数が、そのコンストラクタが
    定義されているクラスと同じ名前を有している場合にコンストラクタにな
    ります。これらの違いは僅かですが、重要な違いがあります。(以下、参
    照)
   </para>
   
   <informalexample>
    <programlisting role="php">
// Works in PHP 3 and PHP 4.
class Auto_Cart extends Cart {
    function Auto_Cart () {
        $this->add_item ("10", 1);
    }
}
    </programlisting>
   </informalexample>
 
   <para>
    この例は、Cart にコンストラクタを加えたクラス Auto_Cart を定義しています。
    このコンストラクタは、"new" により新しい Auto_Cart が作成される度に
    籠に10番の物を一つ保持するように初期化します。コンストラクタは、オ
    プションとして引数をとります。これにより、コンストラクタは非常に便
    利なものとなります。To be able to still use the class
    without parameters, all parameters to constructors should be
    made optional by providing default values.
   </para>
 
   <informalexample>
    <programlisting role="php">
// Works in PHP 3 and PHP 4.
class Constructor_Cart extends Cart {
    function Constructor_Cart ($item = "10", $num = 1) {
        $this->add_item ($item, $num);
    }
}
 
// しつこいが、前の例と同じものを買う
 
$default_cart   = new Constructor_Cart;
 
// 実際に買うもの篭に入れる...
 
$different_cart = new Constructor_Cart ("20", 17);
    </programlisting>
   </informalexample>

   <caution>
    <simpara>
     In PHP 3, derived classes and constructors have a number of
     limitations. The following examples should be read carefully
     to understand these limitations.
    </simpara> 
   </caution>
   
   <informalexample>
    <programlisting role="php">
class A {
  function A() {
    echo "I am the constructor of A.&lt;br>\n";
  }
}

class B extends A {
  function C() {
    "I am a regular function.&lt;br>\n";
  }
}

// no constructor is being called in PHP 3.
$b = new B;
    </programlisting>
   </informalexample>

   <para>
    In PHP 3, no constructor is being called in the above example.
    The rule in PHP 3 is: 'A constructor is a function of the same
    name as the class.'. The name of the class is B, and there is
    no function called B() in class B. Nothing happens.
   </para>
   
   <para>
    This is fixed in PHP 4 by introducing another rule: If a class
    has no constructor, the constructor of the base class is being
    called, if it exists. The above example would have printed
    'I am the constructor of A.&lt;br>' in PHP 4.
   </para>

   <informalexample>
    <programlisting role="php">
class A {
  function A() {
    echo "I am the constructor of A.&lt;br>\n";
  }
  
  function B() {
    echo "I am a regular function named B in class A.&lt;br>\n";
    echo "I am not a constructor in A.&lt;br>\n";
  }
}

class B extends A {
  function C() {
    echo "I am a regular function.&lt;br>\n";
  }
}

// This will call B() as a constructor.
$b = new B;
    </programlisting>
   </informalexample>
   
   <para>
    In PHP 3, the function B() in class A will suddenly become a
    constructor in class B, although it was never intended to be.
    The rule in PHP 3 is: 'A constructor is a function of the same
    name as the class.'. PHP 3 does not care if the function is
    being defined in class B, or if it has been inherited.
   </para>
   
   <para>
    This is fixed in PHP 4 by modifying the rule to: 'A constructor
    is a function of the same name as the class it is being defined
    in.'. Thus in PHP 4, the class B would have no constructor function
    of its own and the constructor of the base class would have been
    called, printing 'I am the constructor of A.&lt;br>'.
   </para>
   
   <caution>
    <simpara>
     Neither PHP 3 nor PHP 4 call constructors of the base class 
     automatically from a constructor of a derived class. It is
     your responsibility to propagate the call to constructors
     upstream where appropriate.
    </simpara>
   </caution>
   
   <note>
    <simpara>
     There are no destructors in PHP 3 or PHP 4. You may use
     <function>register_shutdown_function</function> instead
     to simulate most effects of destructors.
    </simpara>
   </note>
   
   <para>
    Destructors are functions that are called automatically
    when a variable is destroyed, either with <function>unset</function>
    or by simply going out of scope. There are no destructors
    in PHP.
   </para>
  </sect1>

 <sect1 id="keyword.paamayim_nekudotayim"><!-- :-) -->
   <title><literal>::</literal></title>

   <caution>
    <simpara>
     The following is valid for PHP 4 only.
    </simpara>
   </caution>

   <para>
    Sometimes it is useful to refer to functions and variables
    in base classes or to refer to functions in classes that
    have not yet any instances. The :: operator is being used
    for this.
   </para>
   
   <informalexample>
    <programlisting role="php">
class A {
  function example() {
    echo "I am the original function A::example().&lt;br>\n";
  }
}

class B extends A {
  function example() {
    echo "I am the redefined function B::example().&lt;br>\n";
    A::example();
  }
}

// there is no object of class A.
// this will print
//   I am the original function A::example().&lt;br>
A::example();

// create an object of class B.
$b = new B;

// this will print 
//   I am the redefined function B::example().&lt;br>
//   I am the original function A::example().&lt;br>
$b->example();
    </programlisting>
   </informalexample>

   <para>
    The above example calls the function example() in
    class A, but there is no object of class A, so that
    we cannot write $a->example() or similar. Instead we
    call example() as a 'class function', that is, as a
    function of the class itself, not any object of that
    class.
   </para>
   
   <para>
    There are class functions, but there are no class variables.
    In fact, there is no object at all at the time of the call.
    Thus, a class function may not use any object variables (but
    it can use local and global variables), and it may no use
    $this at all.
   </para>

   <para>
    In the above example, class B redefines the function example(). 
    The original definition in class A is shadowed
    and no longer available, unless you are refering specifically
    to the implementation of example() in class A using the 
    ::-operator. Write A::example() to do this (in fact, you
    should be writing parent::example(), as shown in the next
    section).
   </para>
   
   <para>
    In this context, there is a current object and it may
    have object variables. Thus, when used from WITHIN an
    object function, you may use $this and object variables.
   </para>

 </sect1>

 <sect1 id="keyword.parent">
   <title><literal>親クラス</literal></title>

  <para>
   You may find yourself writing code that refers to
   variables and functions in base classes. This is
   particularly true if your derived class is a refinement
   or specialisation of code in your base class. 
  </para>
  
  <para>
   Instead of using the literal name of the base class in your
   code, you should be using the special name
   <literal>parent</literal>, which refers to the name of your
   base class as given in the <literal>extends</literal>
   declation of your class. By doing this, you avoid using the
   name of your base class in more than one place. Should
   your inheritance tree change during implementation, the
   change is easily made by simply changing the 
   <literal>extends</literal> declaration of your class.
  </para>

  <informalexample>
   <programlisting role="php">
class A {
  function example() {
    echo "I am A::example() and provide basic functionality.&lt;br>\n";
  }
}

class B extends A {
  function example() {
    echo "I am B::example and provide additional functionality().&lt;br>\n";
    parent::example();
  }
}

$b = new B;

// This will call B::example(), which will in turn call A::example().
$b->example();
   </programlisting>
  </informalexample>
 </sect1>

 <sect1 id="language.oop.serialization">
  <title>Serializing objects - objects in sessions</title>

  <note>
   <simpara>
    In PHP 3, objects will lose their class association
    throughout the process of serialization and unserialization. 
    The resulting variable is of type object, but has no class
    and no methods, thus it is pretty useless (it has become
    just like an array with a funny syntax).
   </simpara>
  </note>

  <caution>
   <simpara>
    The following information is valid for PHP 4 only. 
   </simpara>
  </caution>

  <para>
   <function>serialize</function> returns a string containing a
   byte-stream representation of any value that can be stored in
   PHP. <function>unserialize</function> can use this string to
   recreate the original variable values. Using serialize to
   save an object will save all variables in an object.  The
   functions in an object will not be saved, only the name of
   the class.
  </para>
  
  <para>
   In order to be able to <function>unserialize</function> an
   object, the class of that object needs to be defined. That
   is, if you have an object $a of class A on page1.php and
   serialize this, you'll get a string that refers to class A
   and contains all values of variabled contained in $a. If
   you want to be able to unserialize this on page2.php,
   recreating $a of class A, the definition of class A must
   be present in page2.php. This can be done for example
   by storing the class defintion of class A in an include
   file and including this file in both page1.php and page2.php.
  </para>
  
  <informalexample>
   <programlisting role="php">
classa.inc:
  class A {
    var $one = 1;
    
    function show_one() {
      echo $this->one;
    }
  }
  
page1.php:
  include("classa.inc");
  
  $a = new A;
  $s = serialize($a);
  // store $s somewhere where page2.php can find it.
  $fp = fopen("store", "w");
  echo $s;
  fclose($fp);

page2.php:
  // this is needed for the unserialize to work properly.
  include("classa.inc");

  $s = implode("", @file("store"));
  unserialize($s);

  // now use the function show_one of the $a object.  
  $a->show_one();
   </programlisting>
  </informalexample>
  
  <para>
   If you are using sessions and use <function>session_register</function>
   to register objects, these objects are serialized automatically
   at the end of each PHP page, and are unserialized automatically on
   each of the following pages. This basically means that these objects
   can show up on any of your pages once they become part of your
   session.
  </para>
  
  <para>
   It is strongly recommended that you include the class
   definitions of all such registered objects on all of your
   pages, even if you do not actually use these classes on all
   of your pages. If you don't and an object is being
   unserialized without its class definition being present, it
   will lose its class association and become an object of class
   <literal>stdClass</literal> without any functions available
   at all, that is, it will become quite useless.
  </para>
  
  <para>
   So if the in the example above $a became part of a session by
   running <literal>session_register("a")</literal>, you should
   include the file <literal>classa.inc</literal> on all of your
   pages, not only page1.php and page2.php.
  </para>
 </sect1>

 <sect1 id="language.oop.magic-functions">
  <title>The magic functions <literal>__sleep</literal> and <literal>__wakeup</literal></title>

  <para>
   <function>serialize</function> checks if your class has a function with
   the magic name <literal>__sleep</literal>. If so, that function is
   being run prior to any serialization. It can clean up the object
   and is supposed to return an array with the names of all variables
   of that object that should be serialized.
  </para>
  
  <para>
   The intended use of <literal>__sleep</literal> is to close any
   database connections that object may have, committing pending
   data or perform similar cleanup tasks. Also, the function is
   useful if you have very large objects which need not be
   saved completely.
  </para>
  
  <para>
   Conversely, <function>unserialize</function> checks for the
   presence of a function with the magic name 
   <literal>__wakeup</literal>. If present, this function can
   reconstruct any ressources that object may have.
  </para>
  
  <para>
    The intended use of <literal>__wakeup</literal> is to
    reestablish any database connections that may have been lost
    during serialization and perform other reinitialization
    tasks.
  </para>
 </sect1>
  
 <sect1 id="language.oop.newref">
   <title>コンストラクタの内部での参照</title>
   <para>
    コンストラクタの中で参照を作成すると結果が混乱する可能性があります。
    本節ではチュートリアル形式で説明しますが、この問題を避けるために役
    立つはずです。
 
    <informalexample>
     <programlisting role="php">

class foo {
    function foo($name) {
        // 内部への参照グローバル配列 $globalref を作成
        global $globalref;
	$globalref[] = &amp;$this;
        // name を指定した値に設定
        $this->setName($name);
	// それを出力
        $this->echoName();
    }

    function echoName() {
        echo "&lt;br&gt;",$this->Name;
    }
	
    function setName($name)	{
	$this->Name = $name;
    }
}
    </programlisting>
   </informalexample>
  </para>
    
   <para>
    コピー演算子 <literal>=</literal> により作成された
    <varname>$bar1</varname> と 参照演算子 <literal>=&amp;</literal>
    により作成された <varname>$bar2</varname> の間の差異があるかどうか
    を確認してみましょう。

    <informalexample>
     <programlisting role="php">
   
    $bar1 = new foo('set in constructor');
    $bar1->echoName();
    $globalref[0]->echoName();
    
    /* 出力:
    set in constructor
    set in constructor
    set in constructor */
    
    $bar2 =&amp; new foo('set in constructor');
    $bar2->echoName();
    $globalref[1]->echoName();

    /* 出力:
    set in constructor
    set in constructor
    set in constructor */
    
     </programlisting>
    </informalexample>
   </para>
   <para>
    明らかに違いはありませんが、実際には動作は非常に異なっています。つ
    まり、<varname>$bar1</varname> と <varname>$globalref[0]</varname>
    は、 参照されておらず、同じ変数でもありません。
    これは、"new" がデフォルトで参照を返さず、代わりにコピーを返すため
    です。
    <note>
     <simpara>
      (PHP 4以降ではリファレンスカウンティングを使用しているため、)参
      照ではなくコピーを返すことで性能が低下することはありません。逆に
      多くの場合、参照を使うよりも単純にコピーを使った方が良い結果とな
      ります。これは、参照の作成には時間がかかりますが、コピーの作成に
      は理想的には時間が全くかからないからです。(ただし、大きな配列ま
      たはオブジェクトでその一つが変更されると、次々に参照先の他の要素
      に参照先に波及するといった場合を除きます)
     </simpara>
    </note>
    上記の記述が正しいことを示すために以下のコードを見てみましょう。

   <informalexample>
     <programlisting role="php">
// ここで、name を変更してみます。どうなるでしょうか?
// $bar と $globalref[0] の両方共名前が変わると予想するかもしれません...
$bar1->setName('set from outside');

// 前記のようにこの場合は違います。
$bar1->echoName();
$globalref[0]->echoName();

/* 出力:
set on object creation set from outside */

// $bar2 と $globalref[1] の差を見てみましょう
$bar2->setName('set from outside');

// うまく行けば、値が等しいだけでなく、同じ変数となります。
// つまり、$bar2->Name と $globalref[1]->Name も同じになります。
$bar2->echoName();
$globalref[1]->echoName();

/* 出力: 
   set from outside 
   set from outside */
        
      </programlisting>
    </informalexample>   
   </para>   
   <para>
    最後に別の例について考えてみて下さい。
    
    <informalexample>
     <programlisting role="php">
      
class a {
    function a($i) {
       $this->value = $i;
       // ここで参照を使う必要がない理由を考えてみて下さい
       $this->b = new b($this);
    }

    function createRef() {
        $this->c = new b($this);
    }

    function echoValue() {
        echo "&lt;br&gt;","class ",get_class($this),': ',$this->value;
        }
}


class b  {

    function b(&amp;$a) {
        $this->a = &amp;$a;
    }

   function echoValue() {
        echo "&lt;br&gt;","class ",get_class($this),': ',$this->a->value;
        }

}

// 以下の単純なコピーが、* 印を付けた行で望ましくない結果を生む理由を
// 考えてみて下さい。
$a =&amp; new a(10);
$a->createRef();

$a->echoValue();
$a->b->echoValue();
$a->c->echoValue();

$a->value = 11;

$a->echoValue();
$a->b->echoValue(); // *
$a->c->echoValue();

/*
出力:
class a: 10
class b: 10
class b: 10
class a: 11
class b: 11
class b: 11
*/
     </programlisting>
    </informalexample>
   </para>
  </sect1>
 
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
