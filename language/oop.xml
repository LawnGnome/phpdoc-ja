<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.15 $ -->
 <chapter id="language.oop">
  <title>クラスとオブジェクト</title>

  <sect1 id="keyword.class">
   <title><literal>クラス</literal></title>
   <para>
    クラスは、変数およびこれらの変数で動作する関数の集まりです。
    クラスは次のような構文により定義されます。
 
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class Cart
{
    var $items;  // 買い物篭の中のアイテム
   
    // $num 個の $artnr を買い物篭に加えます
 
    function add_item ($artnr, $num)
    {
        $this->items[$artnr] += $num;
    }
   
    // $num 個の $artnr を買い物籠から出します
 
    function remove_item ($artnr, $num)
    {
        if ($this->items[$artnr] > $num) {
            $this->items[$artnr] -= $num;
            return true;
        } else {
            return false;
        }   
    }
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    この例は、籠の中の物と籠にアイテムを加えたり除いたりする二つの関数への
    連想配列からなる Cart という名前のクラスを定義します。
   </para>

   <caution>
    <simpara>
     以下の注意書きはPHP 4に関するものです。
    </simpara>
    
    <simpara>
     名前<literal>stdClass</literal>は、Zendにより内部的に使用され、保
     存されています。PHPで<literal>stdClass</literal>という名前のクラ
     スを使用することはできません。
    </simpara>
    
    <simpara>
     関数<literal>__sleep</literal>および<literal>__wakeup</literal>は、
     PHPクラス内で使用される特殊な関数です。これらの関数に付随する特殊
     な機能を使用する場合以外は、クラス内でこれらの名前を付けた関数を
     使用することはできません。詳細な情報については、以下を参照下さい。
    </simpara>
    
    <simpara>
     PHP は、__で始まる全ての関数名を特殊な関数として予約しています。
     ドキュメントに記載された特殊関数の機能を使用する場合以外は、__を
     有する関数名を使用しないことを推奨します。
    </simpara>
   </caution>
   
   <note>
    <simpara>
     PHP 4では、変数<literal>var</literal>については定数による初期化の
     みが可能です。定数以外で初期化を行う場合には初期化関数が必要です。
     この初期化関数は、オブジェクトがクラスから構築される際に自動的に
     コールされます。このような関数はコンストラクタと呼ばれます。(以下
     参照)
    </simpara>
    <informalexample>
     <programlisting role="php">
<![CDATA[
/* 以下のコードはPHP 4では動作しません。 */
class Cart
{
    var $todays_date = date("Y-m-d");
    var $name = $firstname;
    var $owner = 'Fred ' . 'Jones';
    var $items = array("VCR", "TV");
}

/* 以下に正しい方法を示します。 */
class Cart
{
    var $todays_date;
    var $name;
    var $owner;
    var $items;

    function Cart()
    {
        $this->todays_date = date("Y-m-d");
        $this->name = $GLOBALS['firstname'];
        /* 等など. . . */
    }
}
]]>
     </programlisting>
    </informalexample>
   </note>
   <para>
    クラスは型、つまり、実際の変数の雛型です。<literal>new</literal>演
    算子により所望の型の変数を作成する必要があります。
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
  $cart = new Cart;
  $cart->add_item("10", 1);

  $another_cart = new Cart;
  $another_cart->add_item("0815", 3);
?>
]]>
    </programlisting>
   </informalexample>
 
   <para>
    この例は、クラスCartのオブジェクト $cartおよび$another_cartを作成
    します。$cartオブジェクトの関数 add_item()が商品番号10の商品一つが
    カートに追加されています。商品番号0815の商品3つが$another_cartに追
    加されています。
   </para>

   <para>
    $cart と $another_cartは共に関数 add_item()、
    remove_item() と変数items を有しています。これらは、異なる関数およ
    び変数です。オブジェクトは、ファイルシステムのディレクトリに似たよ
    うなものであると考えられます。ファイルシステムでは、別のディレクト
    リに置く限り、二つの異なるREADME.TXTを保持することが可能です。ディ
    レクトリではトップディレクトリから各ファイルにアクセスするには、フ
    ルパス名を入力する必要がありますが、これと全く同様にコールしたい関
    数の完全な名前を指定する必要があります。PHPの用語では、最上位のディ
    レクトリはグローバル名前空間であり、パス名のセパレータは、-&gt;と
    なります。つまり、$cart-&gt;items と $another_cart-&gt;items は、
    二つの異なる変数です。$cart-&gt;items という名前の変数は、
    $cart-&gt;$items ではない、つまり、PHPの変数名はドル記号を一つだけ
    有することに注意して下さい。
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
// 正しい、$は一つ
$cart->items  = array("10" => 1); 

// $cart->$items は、$cart->"" になるため、正しくない。
$cart->$items = array("10" => 1);

// 正しいが、意図しているかどうかによらず、
// $cart->$myvar は、 $cart->items となる
$myvar = 'items';
$cart->$myvar = array("10" => 1); 
]]>
    </programlisting>
   </informalexample>

   <para>
    クラス定義の内部では、プログラムでアクセス可能なオブジェクト名を知
    ることはできません。Cartクラスが書かれている時点では、そのオブジェ
    クトが後で $cart という名前となるか $another_cart となるかはわかり
    ません。つまり、Cartクラスの中では $cart-&gt;items と書くことはで
    きないのです。代わりに、クラスの中からそのクラス内の関数や変数にア
    クセスするために、疑似変数 $this を使用することが可能です。$this
    は、「自分自身の」または「カレントのオブジェクト」と読み変えること
    ができます。つまり、'$this-&gt;items[$artnr] += $num' は、「同じクラ
    ス内の配列 items の $artnr カウンタに $num を追加する」または「カ
    レントオブジェクト内の配列 items の $artnr カウンタに $num を追加
    する」と読み変えることが可能です。
   </para>
  </sect1>
  
  <sect1 id="keyword.extends">
   <title><literal>extends</literal></title>

   <para>
    他の既存のクラスに似た変数や関数を有するクラスが必要になることがよ
    くあります。実際、全てのプロジェクトで使用可能な一般的なクラスを定
    義し、このクラスを特定のプロジェクトの各々の要求に合わせて調整する
    というのは、良いやり方です。これを簡単に行うにために、他のクラスを
    拡張してクラス作成することが可能です。拡張あるいは派生クラスは、基
    底クラスの全ての変数と関数を有します。(これは、実際には誰も亡くなっ
    ていませんが、'継承'と呼ばれます) この派生クラスには、派生クラスの
    定義で追加したものも含まれます。クラスから定義を取り除く、つまり、
    既存の関数や変数を未定義とすることはできません。派生クラスは、常に
    単一の基底クラスに依存します。つまり、多重継承は、サポートされてい
    ません。クラスは、キーワード'extends'を用いて拡張されます。
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
class Named_Cart extends Cart
{
    var $owner;
  
    function set_owner ($name)
    {
        $this->owner = $name;
    }
}
]]>
    </programlisting>
   </informalexample>
 
   <para>
    この例は、Cart の全ての変数及び関数に加えて変数 $owner と
    関数 set_owner() を保持するクラス Named_Cart を定義しています。
    この定義により、名前付きの籠を通常の手段で作成し、籠の保有者を
    設定したり得たりすることができます。
    名前付きの籠で元の籠クラスの関数を使うことも可能です。
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
$ncart = new Named_Cart;    // 名前付きの籠を作成
$ncart->set_owner("kris");  // 籠の所有者の名前を設定
print $ncart->owner;        // 籠の所有者を出力
$ncart->add_item("10", 1);  // (籠から継承された機能)
]]>
    </programlisting>
   </informalexample>
  
  </sect1>

  <sect1 id="language.oop.constructor">
   <title><literal>コンストラクタ</literal></title>

   <caution>
    <simpara>
     PHP 3 と PHP 4 では、コンストラクタの動作は異なります。PHP 4の定
     義の方が明らかに好ましいと言えます。
    </simpara>
   </caution>

   <para>
    コンストラクタは、<literal>new</literal>によりクラスの新しいインス
    タンスを作成する際に自動的にコールされるクラス関数です。
    PHP 3では、ある関数が、クラス名と同じ名前を有している場合にコンス
    トラクタになりました。PHP 4では、ある関数が、そのコンストラクタが
    定義されているクラスと同じ名前を有している場合にコンストラクタにな
    ります。これらの違いは僅かですが、重要な違いがあります。(以下、参
    照)
   </para>
   
   <informalexample>
    <programlisting role="php">
<![CDATA[
// PHP 3 および PHP 4で動作します
class Auto_Cart extends Cart
{
    function Auto_Cart ()
    {
        $this->add_item("10", 1);
    }
}
]]>
    </programlisting>
   </informalexample>
 
   <para>
    この例は、Cart にコンストラクタを加えたクラス Auto_Cart を定義しています。
    このコンストラクタは、"new" により新しい Auto_Cart が作成される度に
    籠に10番の物を一つ保持するように初期化します。コンストラクタは、オ
    プションとして引数をとります。これにより、コンストラクタは非常に便
    利なものとなります。このクラスをパラメータが指定されない場合でも使
    用できるようにするには、コンストラクタに指定する全てのパラメータに
    デフォルト値を指定して下さい。
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
// PHP 3 と PHP 4の両方で動作
class Constructor_Cart extends Cart
{
    function Constructor_Cart ($item = "10", $num = 1)
    {
        $this->add_item($item, $num);
    }
}
 
// しつこいが、前の例と同じものを買う
 
$default_cart = new Constructor_Cart;
 
// 実際に買うもの篭に入れる...
 
$different_cart = new Constructor_Cart("20", 17);
]]>
    </programlisting>
   </informalexample>

   <caution>
    <simpara>
     PHP 3では、派生クラスとコンストラクタには複数の制約があります。こ
     れらの制限を理解するために以下の例を注意して御覧下さい。
    </simpara> 
   </caution>
   
   <informalexample>
    <programlisting role="php">
<![CDATA[
class A
{
    function A()
    {
        echo "Aのコンストラクタです&lt;br>\n";
    }
}

class B extends A
{
    function C()
    {
        "通常の関数<br>\n";
    }
}

// PHP 3ではコンストラクタはコールされません
$b = new B;
]]>
    </programlisting>
   </informalexample>

   <para>
    PHP 3では、上の例でコンストラクタはコールされません。PHP 3の規則で
    は、「コンストラクタはクラスと同じ名前を有する関数です。」となりま
    す。クラス名はBであり、クラスBの中にはB()という関数がないため、何
    もおきません。
   </para>
   
   <para>
    これは、PHP 4では、次のような別の規則が導入された修正されました。
    あるクラスにコンストラクタがない場合、基底クラスのコンストラクタが
    ある場合にはコールされます。上の例は、PHP 4では、
    'Aのコンストラクタです&lt;br>'と出力されます。
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
class A
{
    function A()
    {
        echo "Aのコンストラクタです&lt;br>\n";
    }

    function B()
    {
        echo "クラスAのBという名前の通常の関数&lt;br>\n";
        echo "Aのコンストラクタではありません&lt;br>\n";
    }
}

class B extends A
{
    function C()
    {
        echo "通常の関数です&lt;br>\n";
    }
}

// これにより、B() がコンストラクタとしてコールされます。
$b = new B;
]]>
    </programlisting>
   </informalexample>
   
   <para>
    PHP 3では、クラスAの関数 B() は意図されていない場合でも、クラスB
    のコンストラクタに突然なってしまいました。PHP 3の規則は次のように
    なります。「コンストラクタはクラス名と同じ名前の関数である。」PHP
    3は、この関数がクラスBで定義されているかとかその関数が継承されてい
    るかどうかは考慮しません。
   </para>
   
   <para>
    これは、PHP 4では次のように規則が修正されました。「コンストラクタ
    は、それが定義されているクラスと同じ名前の関数である」つまり、PHP
    4では、クラスBが独自のコンストラクタ関数を持たない場合には、基底ク
    ラスのコンストラクタがコールされ、「Aのコンストラクタです&lt;br>」
    と出力されます。
   </para>
   
   <caution>
    <simpara>
     PHP 3 および PHP 4のどちらでも派生クラスのコンストラクタから基底
     クラスのコンストラクタを自動的にコールすることはできません。
    </simpara>
   </caution>
   
   <note>
    <simpara>
     PHP 3およびPHP 4には、デストラクタはありません。デストラクタの機
     能の多くをシミュレーションするには、代わりに
     <function>register_shutdown_function</function> を使用します。
    </simpara>
   </note>
   
   <para>
    デストラクタは、<function>unset</function>またはスコープから
    でることにより、オブジェクトが破棄される度に自動的にコールされる関数です。
    PHPにはデストラクタはありません。
   </para>
  </sect1>

 <sect1 id="keyword.paamayim-nekudotayim"><!-- :-) -->
   <title><literal>::</literal></title>

   <caution>
    <simpara>
     以下の記述は、PHP 4でのみ有効です。
    </simpara>
   </caution>

   <para>
    基底クラスの関数や変数を参照したり、まだ特定のインスタンスを持たな
    いクラスの関数を参照したりできると便利であるような場合があります。
    演算子 :: はこのような場合に使用されます。
   </para>
   
   <informalexample>
    <programlisting role="php">
<![CDATA[
class A
{
    function example()
    {
       echo "オリジナルの関数A::example().<br>\n";
    }
}

class B extends A
{
    function example()
    {
        echo "再定義された関数B::example().<br>\n";
        A::example();
    }
}

// クラスAのオブジェクトはありません
// この例は、「オリジナルの関数A::example().<br>」を出力しま
// す
A::example();

// クラスBのオブジェクトを作成
$b = new B;

// この例の出力は次のようになります。
//   再定義された関数B::example().<br>
//   オリジナルの関数A::example().<br>
$b->example();
]]>
    </programlisting>
   </informalexample>

   <para>
    上の例では、関数example()がクラスAでコールされていますが、クラスA
    のオブジェクトはありません。このため、$->example()のように書くこと
    はできません。代わりに、example()を「クラス関数」、つまり、そのク
    ラスのオブジェクトではなく、クラス自体の関数としてとしてコールしま
    す。
   </para>
   
   <para>
    クラス関数はありますが、クラス変数はありません。実際、コールをする
    時点ではオブジェクトは存在しません。つまり、クラス関数はどのオブジェ
    クト変数も使用することはできません。(しかし、ローカル変数やグロー
    バル変数は使用可能です。)また、$this を使用することはできません。
   </para>

   <para>
    上の例では、クラスBは関数example()を再定義しています。クラスAの元
    の定義は隠され、::演算子を使用してクラスAのexample()の実装を明示的
    に参照しない限り利用できなくなっています。これを行うには、
    A::example()と書いて下さい。(実際には、次節で示すように
    parent::example()と書く必要があります。)
   </para>
   
   <para>
    この状況では、カレントのオブジェクトがあり、オブジェクト変数を保持
    することが可能です。つまり、オブジェクト関数の内部で使用された場合、
    $this およびオブジェクト変数を使用することが可能です。
   </para>

  </sect1>

  <sect1 id="keyword.parent">
   <title><literal>親クラス</literal></title>
   
   <para>
    基底クラスの変数と関数を参照するコードを書くことが可能です。これは、
    派生クラスが基底クラスのコードを特定の用途向けに改造したりする場合
    には、特に有用です。
  </para>
  
   <para>
    コードの基底クラスのリテラル名を使用する代わりに、特別な名前
    <literal>parent</literal>を使用する必要があります。この名前は、
    クラスの<literal>extends</literal>宣言で指定された基底クラスの名前
    を指しています。これにより、基底クラスの名前を複数の場所で使用する
    ことを避けることが可能です。実装の際に継承ツリーを変更した場合でも、
    変更は簡単で、クラスの<literal>extends</literal>宣言を変更するだけ
    ですみます。
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
class A
{
    function example()
    {
        echo "A::example()です。基本関数を提供します。&lt;br>\n";
    }
}

class B extends A
{
    function example()
    {
        echo "B::example()です。付加的な機能を提供します。<br>\n";
        parent::example();
    } 
}

$b = new B;
     
// B::example()をコールし、この関数の中からA::example()がコールされます。
$b->example();
]]>
    </programlisting>
   </informalexample>
  </sect1>
  
  <sect1 id="language.oop.serialization">
   <title>オブジェクトのシリアル化 - セッションでのオブジェクト</title>
   
   <note>
    <simpara>
     PHP 3では、オブジェクトはシリアル化、非シリアル化の課程でクラスの
     相関を失ってしまいました。復元される変数は、オブジェクト型ですが、
     クラスもメソッドもありません。このため、全く実用的ではありません
     でした。(変わった構文の配列のようになっていました。)
    </simpara>
   </note>
   
   <caution>
    <simpara>
     以下の情報は、PHP 4でのみ有効です。
    </simpara>
   </caution>
   
   <para>
    <function>serialize</function> は、PHPで保存可能な全ての値のバイト
    ストリーム表現を有する文字列を返します。
    <function>unserialize</function> は、この文字列を使用して元の変数
    値を再生することが可能です。オブジェクトを保存するためにシリアル化
    を行うと、オブジェクトの全ての変数が保存されます。オブジェクトの関
    数は保存されません。クラス名だけが保存されます。
   </para>
   
   <para>
    オブジェクトの <function>unserialize</function> を可能とするために、
    そのオブジェクトのクラスが定義される必要があります。つまり、クラス
    Aのオブジェクト$aを page1.phpで定義し、これをシリアル化した場合、
    クラスAを指す文字列が得られ、そこには、$aに含まれる変数の全ての値
    が含まれます。page2.phpでこの文字列を非シリアル化したい場合、クラ
    スAの$aを再生します。クラスAの定義が、page2.phpに現れます。これは、
    例えば、クラスAのクラス定義をインクルードファイルの中に保存し、
    page1.php および page2.php の中で共にこのファイルを読み込むことに
    より実行可能です。
   </para>
   
   <informalexample>
    <programlisting role="php">
<![CDATA[
classa.inc:
  class A
  {
      var $one = 1;
      
      function show_one()
      {
          echo $this->one;
      }
  }
  
page1.php:
  include("classa.inc");
  
  $a = new A;
  $s = serialize($a);
  // page2.phpが見付られる場所に$sを保存
  $fp = fopen("store", "w");
  fputs($fp, $s);
  fclose($fp);

page2.php:
  // これは非シリアル化が正しく動作するために必要
  include("classa.inc");

  $s = implode("", @file("store"));
  $a = unserialize($s);

  // オブジェクト$aの関数show_one()を使用する
  $a->show_one();
]]>
    </programlisting>
   </informalexample>
  
   <para>
    セッションを使用している場合に、オブジェクトを登録するために
    <function>session_register</function>を使用すると、これらのオブジェ
    クトは各PHPページの最後で自動的にシリアル化され、次のページで自動
    的に非シリアル化されます。これは、基本的に、これらのオブジェクトが
    一旦セッション変数となると、全てのページに現れることを意味します。
   </para>
   
   <para>
    全てのページでこれらのクラスを実際には使用しない場合でも、全てのペー
    ジでこのような登録された全てのオブジェクトのクラス定義を読み込むこ
    とが強く推奨されます。これを行わずに、クラス定義が存在しない状態で
    オブジェクトが非シリアル化された場合、クラスの相関は失われ、全ての
    関数が利用できなくなるため、クラスのオブジェクト
    <literal>stdClass</literal>は利用価値がかなり低くなります。
   </para>
   
   <para>
    このため、上の例で、<literal>session_register("a")</literal>を実行
    することにより $a がセッションの一部となった場合、page1.php および
    page2.phpだけでなく、全てのページでファイル
    <literal>classa.inc</literal>を読み込むべきです。
   </para>
  </sect1>
  
  <sect1 id="language.oop.magic-functions">
   <title>
    特殊関数<literal>__sleep</literal> および
    <literal>__wakeup</literal>
   </title>
   <para>
    <function>serialize</function> は、クラスに特殊な名前
    <literal>__sleep</literal>を有する関数があるかどうかを調べます。こ
    れがある場合、この関数はシリアル化の前に実行されます。この関数によ
    りオブジェクトをクリアし、シリアル化するオブジェクトの全ての変数の
    名前を有する配列を返すことが前提とされます。
   </para>
   
   <para>
    典型的な <literal>__sleep</literal> の使用法は、オブジェクトが有す
    る全てのデータベース接続を閉じたり、途中のデータをコミットしたり、
    似たようなタスクのクリアを行うといったものです。また、オブジェクト
    が非常に大きく、かつ、完全に保存する必要がない場合、この関数が有用
    です。
   </para>
   
   <para>
    逆に、 <function>unserialize</function> は、特殊な名前
    <literal>__wakeup</literal> を有する関数が存在するかどうかを確認し
    ます。これが存在する場合、この関数は、そのオブジェクトが有する全て
    のリソースを再構築することが可能です。
   </para>
   
   <para>
    典型的な<literal>__wakeup</literal>の使用法は、シリアル化により失っ
    たデータベース接続を全て再度復旧したり、その他の再初期化作業を実行
    したりといったものです。
   </para>
  </sect1>
  
  <sect1 id="language.oop.newref">
   <title>コンストラクタの内部での参照</title>
   <para>
    コンストラクタの中で参照を作成すると結果が混乱する可能性があります。
    本節ではチュートリアル形式で説明しますが、この問題を避けるために役
    立つはずです。
    
    <informalexample>
     <programlisting role="php">
<![CDATA[
class foo
{
    function foo($name)
    {
        // 内部への参照グローバル配列 $globalref を作成
        global $globalref;
        $globalref[] = &$this;
        // name を指定した値に設定
        $this->setName($name);
        // それを出力
        $this->echoName();
    }

    function echoName()
    {
        echo "<br>",$this->Name;
    }

    function setName($name)
    {
        $this->Name = $name;
    }
}
]]>
    </programlisting>
   </informalexample>
  </para>
    
   <para>
    コピー演算子 <literal>=</literal> により作成された
    <varname>$bar1</varname> と 参照演算子 <literal>=&amp;</literal>
    により作成された <varname>$bar2</varname> の間の差異があるかどうか
    を確認してみましょう。

    <informalexample>
     <programlisting role="php">
<![CDATA[
$bar1 = new foo('set in constructor');
$bar1->echoName();
$globalref[0]->echoName();

/* 出力:
set in constructor
set in constructor
set in constructor */

$bar2 =& new foo('set in constructor');
$bar2->echoName();
$globalref[1]->echoName();

/* 出力:
set in constructor
set in constructor
set in constructor */
]]>    
     </programlisting>
    </informalexample>
   </para>
   <para>
    明らかに違いはありませんが、実際には動作は非常に異なっています。つ
    まり、<varname>$bar1</varname> と <varname>$globalref[0]</varname>
    は、 参照されておらず、同じ変数でもありません。
    これは、"new" がデフォルトで参照を返さず、代わりにコピーを返すため
    です。
    <note>
     <simpara>
      (PHP 4以降ではリファレンスカウンティングを使用しているため、)参
      照ではなくコピーを返すことで性能が低下することはありません。逆に
      多くの場合、参照を使うよりも単純にコピーを使った方が良い結果とな
      ります。これは、参照の作成には時間がかかりますが、コピーの作成に
      は理想的には時間が全くかからないからです。(ただし、大きな配列ま
      たはオブジェクトでその一つが変更されると、次々に参照先の他の要素
      に参照先に波及するといった場合を除きます)
     </simpara>
    </note>
    上記の記述が正しいことを示すために以下のコードを見てみましょう。

    <informalexample>
     <programlisting role="php">
<![CDATA[
// ここで、name を変更してみます。どうなるでしょうか?
// $bar と $globalref[0] の両方共名前が変わると予想するかもしれません...
$bar1->setName('set from outside');

// 前記のようにこの場合は違います。
$bar1->echoName();
$globalref[0]->echoName();

/* 出力:
set on object creation set from outside */

// $bar2 と $globalref[1] の差を見てみましょう
$bar2->setName('set from outside');

// うまく行けば、値が等しいだけでなく、同じ変数となります。
// つまり、$bar2->Name と $globalref[1]->Name も同じになります。
$bar2->echoName();
$globalref[1]->echoName();

/* 出力: 
   set from outside 
   set from outside */
]]>        
     </programlisting>
    </informalexample>   
   </para>   
   <para>
    最後に別の例について考えてみて下さい。
    
    <informalexample>
     <programlisting role="php">
<![CDATA[      
class A
{
    function A($i)
    {
        $this->value = $i;
        // ここで参照を使う必要がない理由を考えてみて下さい
        $this->b = new B($this);
    }

    function createRef()
    {
        $this->c = new B($this);
    }

    function echoValue()
    {
        echo "<br>","class ",get_class($this),': ',$this->value;
    }
}

class B
{
    function B(&$a)
    {
        $this->a = &$a;
    }

    function echoValue()
    {
        echo "<br>","class ",get_class($this),': ',$this->a->value;
    }
}

// 以下の単純なコピーが、* 印を付けた行で望ましくない結果を生む理由を
// 考えてみて下さい。
$a =& new A(10);
$a->createRef();

$a->echoValue();
$a->b->echoValue();
$a->c->echoValue();

$a->value = 11;

$a->echoValue();
$a->b->echoValue(); // *
$a->c->echoValue();

/*
出力:
class A: 10
class B: 10
class B: 10
class A: 11
class B: 11
class B: 11
*/
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>
 
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
