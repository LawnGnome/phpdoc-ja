<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 283798 Maintainer: hirokawa Status: ready -->
<!-- CREDITS: takagi -->

 <chapter xml:id="language.oop" xmlns="http://docbook.org/ns/docbook">
  <title>クラスとオブジェクト (PHP 4)</title>

  <sect1 xml:id="keyword.class">
   <title><literal>クラス</literal></title>
   <para>
    クラスは、変数およびこれらの変数で動作する関数の集まりです。
    変数は <literal>var</literal> で、そして関数は
    <literal>function</literal> で定義します。
    クラスは次のような構文により定義されます。
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class Cart
{
    var $items;  // 買い物カゴの中のアイテム

    // $num 個の $artnr を買い物カゴに加えます

    function add_item ($artnr, $num)
    {
        $this->items[$artnr] += $num;
    }

    // $num 個の $artnr を買い物カゴから出します

    function remove_item ($artnr, $num)
    {
        if ($this->items[$artnr] > $num) {
            $this->items[$artnr] -= $num;
            return true;
        } elseif ($this->items[$artnr] == $num) {
            unset($this->items[$artnr]);
            return true;
        } else {
            return false;
        }
    }
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
 
   <para>
    この例は、買い物カゴの中の物の連想配列と、買い物カゴにアイテムを加えたり
    除いたりする二つの関数からなる Cart という名前のクラスを
    定義します。
   </para>

   <warning>
    <simpara>
     複数のファイルで分割してクラスを定義することは
     <emphasis>できません</emphasis>。また、関数定義の内部分割されている
     場合を除き、複数の PHP ブロックで分割してクラスを定義することも
     <emphasis>できません</emphasis>。次の例は正しく動作しません:
    </simpara>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class test {
?>
<?php
    function test() {
        print 'OK';
    }
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     しかし、次の例は許されます:
    </simpara>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class test {
    function test() {
        ?>
        <?php
        print 'OK';
    }
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </warning>

   <simpara>
    以下の注意書きはPHP 4に関するものです。
   </simpara>
    
   <caution>
    <simpara>
     名前<literal>stdClass</literal>は、Zendにより内部的に使用され、保
     存されています。PHPで<literal>stdClass</literal>という名前のクラ
     スを使用することはできません。
    </simpara>
   </caution>
    
   <caution>
    <simpara>
     関数<literal>__sleep</literal>および<literal>__wakeup</literal>は、
     PHPクラス内で使用される特殊な関数です。これらの関数に付随する特殊
     な機能を使用する場合以外は、クラス内でこれらの名前を付けた関数を
     使用することはできません。詳細な情報については、以下を参照ください。
    </simpara>
   </caution>
    
   <caution>
    <simpara>
     PHP は、<literal>__</literal> で始まる全ての関数名を特殊な関数として予約しています。
     ドキュメントに記載された特殊関数の機能を使用する場合以外は、<literal>__</literal>
     を含む関数名を使用しないことを推奨します。
    </simpara>
   </caution>

   <simpara>
     PHP 4では、変数<literal>var</literal>については定数による初期化の
     みが可能です。定数以外で初期化を行う場合には初期化関数が必要です。
     この初期化関数は、オブジェクトがクラスから構築される際に自動的に
     コールされます。このような関数はコンストラクタと呼ばれます。(以下
     参照)
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class Cart
{
    /* 以下のコードはPHP 4では動作しません。 */
    var $todays_date = date("Y-m-d");
    var $name = $firstname;
    var $owner = 'Fred ' . 'Jones';
    /* Arrays containing constant values will, though. */
    var $items = array("VCR", "TV");
}

/* 以下に正しい方法を示します。 */
class Cart
{
    var $todays_date;
    var $name;
    var $owner;
    var $items = array("VCR", "TV");

    function Cart()
    {
        $this->todays_date = date("Y-m-d");
        $this->name = $GLOBALS['firstname'];
        /* 等など. . . */
    }
}
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    クラスは型、つまり、実際の変数の雛型です。<literal>new</literal>演
    算子により所望の型の変数を作成する必要があります。
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$cart = new Cart;
$cart->add_item("10", 1);

$another_cart = new Cart;
$another_cart->add_item("0815", 3);
?>
]]>
    </programlisting>
   </informalexample>
 
   <para>
    この例は、クラスCartのオブジェクト<varname>$cart</varname>および
    <varname>$another_cart</varname>を作成します。
    <varname>$cart</varname>オブジェクトの関数 <literal>add_idem()</literal>
    で、商品番号10の商品一つをカートに追加しています。
    商品番号0815の商品3つが<varname>$another_cart</varname>
    に追加されています。
   </para>
   
   <para>
    <varname>$cart</varname>と<varname>$another_cart</varname>は共に関数
    <literal>add_item()</literal>、<literal>remove_item()</literal>
    と変数 <varname>items</varname> を有しています。これらは、異なる関数および変数です。
    オブジェクトは、ファイルシステムのディレクトリに似たようなものであると
    考えられます。ファイルシステムでは、別のディレクトリに置く限り、
    二つの異なる<filename>README.TXT</filename>を保持することが可能です。
    ディレクトリではトップディレクトリから各ファイルにアクセスするには、
    フルパス名を入力する必要がありますが、これと全く同様にコールしたい
    関数の完全な名前を指定する必要があります。PHPの用語では、最上位の
    ディレクトリはグローバル名前空間であり、パス名のセパレータは、
    <literal>-&gt;</literal> となります。つまり、<varname>$cart-&gt;items</varname>
    と <varname>$another_cart-&gt;items</varname> は、二つの異なる変数です。
    <varname>$cart-&gt;items</varname>という名前の変数は、
    <varname>$cart-&gt;$items</varname>ではない、つまり、PHP の変数名は
    ドル記号 (<literal>$</literal>) を一つだけ有することに注意してください。
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
// 正しい、$は一つ
$cart->items  = array("10" => 1); 

// $cart->$items は、$cart->"" になるため、正しくない。
$cart->$items = array("10" => 1);

// 正しいが、意図しているかどうかによらず、
// $cart->$myvar は、 $cart->items となる
$myvar = 'items';
$cart->$myvar = array("10" => 1); 
]]>
    </programlisting>
   </informalexample>

   <para>
    クラス定義の内部では、プログラムでアクセス可能なオブジェクト名を知ることはできません。
    Cart クラスが書かれている時点では、そのオブジェクトの名前が後で
    <varname>$cart</varname> になるのか
    <varname>$another_cart</varname> になるのか、
    それとも別のものになるのかはわかりません。
    つまり、Cart クラスの中では <varname>$cart-&gt;items</varname>
    と書くことはできないのです。代わりに、
    クラスの中からそのクラス内の関数や変数にアクセスするために、
    疑似変数 <varname>$this</varname> を使用することが可能です。
    <varname>$this</varname> は、「自分自身の」または「カレントのオブジェクト」
    と読み変えることができます。つまり、
    '<varname>$this-&gt;items[$artnr]</varname> += <varname>$num</varname>' は、
    「同じクラス内の配列 items の <varname>$artnr</varname> カウンタに
    <varname>$num</varname> を追加する」または「カレントオブジェクト内の配列
    items の <varname>$artnr</varname> カウンタに <varname>$num</varname>
    を追加する」と読み変えることが可能です。
   </para>

   <note>
    <para>
     擬似変数 <varname>$this</varname> は、メソッドが静的にコールされた場合に
     常に定義されるわけではありません。しかし、はっきりしていることは: 
     もしメソッドが別のオブジェクトから静的にコールされている場合は
     <varname>$this</varname> が定義されるということです。
     この場合、<varname>$this</varname> は呼び出し元のオブジェクトとなります。
     これを説明したのが次の例です:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class A
{
    function foo()
    {
        if (isset($this)) {
            echo '$this is defined (';
            echo get_class($this);
            echo ")\n";
        } else {
            echo "\$this is not defined.\n";
        }
    }
}

class B
{
    function bar()
    {
        A::foo();
    }
}

$a = new A();
$a->foo();
A::foo();
$b = new B();
$b->bar();
B::bar();
?>
]]>     
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
$this is defined (a)
$this is not defined.
$this is defined (b)
$this is not defined.
]]>
      </screen>
     </informalexample>
    </para>
   </note>

   <note>
    <para>
     クラスとオブジェクトを処理する優れた関数がいくつかあります。
    <link linkend="ref.classobj">クラス/オブジェクト関数</link>
    をざっとみてみると良いでしょう。
    </para>
   </note>
  </sect1>
  
  <sect1 xml:id="keyword.extends">
   <title><literal>extends</literal></title>

   <para>
    他の既存のクラスに似た変数や関数を有するクラスが必要になることがよ
    くあります。実際、全てのプロジェクトで使用可能な一般的なクラスを定
    義し、このクラスを特定のプロジェクトの各々の要求に合わせて調整する
    というのは、良いやり方です。これを簡単に行うにために、他のクラスを
    拡張してクラス作成することが可能です。拡張あるいは派生クラスは、基
    底クラスの全ての変数と関数を有します。(これは、実際には誰も亡くなっ
    ていませんが、'継承'と呼ばれます) この派生クラスには、派生クラスの
    定義で追加したものも含まれます。クラスから定義を取り除く、つまり、
    既存の関数や変数を未定義とすることはできません。派生クラスは、常に
    単一の基底クラスに依存します。つまり、多重継承は、サポートされてい
    ません。クラスは、キーワード '<literal>extends</literal>' を用いて拡張されます。
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class Named_Cart extends Cart
{
    var $owner;
  
    function set_owner ($name)
    {
        $this->owner = $name;
    }
}
?>
]]>
    </programlisting>
   </informalexample>
 
   <para>
    この例は、Cart の全ての変数及び関数に加えて変数<varname>$owner</varname>と
    関数 <literal>set_owner()</literal> を保持するクラス Named_Cart を定義しています。
    この定義により、名前付きのカゴを通常の手段で作成し、カゴの保有者を
    設定したり得たりすることができます。
    名前付きのカゴで元のカゴクラスの関数を使うことも可能です。
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
$ncart = new Named_Cart;    // 名前付きの籠を作成
$ncart->set_owner("kris");  // 籠の所有者の名前を設定
print $ncart->owner;        // 籠の所有者を出力
$ncart->add_item("10", 1);  // (籠から継承された機能)
]]>
    </programlisting>
   </informalexample>

   <para>
    "親と子"と呼ばれる関係もあります。ある親クラスを作成し、
    この親クラスに<emphasis>基づく</emphasis>新しいクラス、つまり、子クラスを
    <literal>extends</literal>により作成します。
    この新しい子クラスを使用することやこの子クラスに基づき他の
    クラスを作成することが可能です。
   </para>
   <note>
    <para>
     クラスは、使用される前に定義されている必要があります!
     <literal>Cart</literal>を拡張した
     クラス <literal>Named_Cart</literal>を作成したい場合、
     まず、<literal>Cart</literal>を定義する必要があります。
     クラス<literal>Named_Cart</literal>に基づき
     <literal>Yellow_named_cart</literal>という名前の他のクラスを
     作成する場合、まず<literal>Named_Cart</literal>を定義する
     必要があります。要するに、クラスの定義の順序は、重要です。
    </para>
   </note>
  </sect1>

  <sect1 xml:id="language.oop.constructor">
   <title>コンストラクタ</title>

   <para>
    コンストラクタは、<literal>new</literal>
    によりクラスの新しいインスタンスを作成する際に自動的にコールされるクラス関数です。
    ある関数が、クラス名と同じ名前を有している場合にコンストラクタになります。
    コンストラクタが存在しない場合、
    もし基底クラスのコンストラクタが存在すれば、それがコールされます。
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
// PHP 3 および PHP 4で動作します
class Auto_Cart extends Cart
{
    function Auto_Cart()
    {
        $this->add_item ("10", 1);
    }
}
?>
]]>
    </programlisting>
   </informalexample>
 
   <para>
    この例は、Cart にコンストラクタを加えたクラス Auto_Cart を定義しています。
    このコンストラクタは、"<literal>new</literal>" により新しい Auto_Cart が作成される度に
    籠に10番の物を一つ保持するように初期化します。コンストラクタは、オ
    プションとして引数をとります。これにより、コンストラクタは非常に便
    利なものとなります。このクラスをパラメータが指定されない場合でも使
    用できるようにするには、コンストラクタに指定する全てのパラメータに
    デフォルト値を指定してください。
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class Constructor_Cart extends Cart
{
    function Constructor_Cart($item = "10", $num = 1)
    {
        $this->add_item ($item, $num);
    }
}
 
// しつこいが、前の例と同じものを買う
$default_cart = new Constructor_Cart;
 
// 実際に買うものをカゴに入れる...
$different_cart = new Constructor_Cart("20", 17);
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    <literal>@new</literal>のようにコンストラクタで発生するエラーの
    出力を抑制するために<literal>@</literal>演算子を使用することが
    可能です。例：<literal>@new</literal>
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class A
{
    function A()
    {
        echo "Aのコンストラクタです<br>\n";
    }

    function B()
    {
        echo "クラスAのBという名前の通常の関数<br>\n";
        echo "Aのコンストラクタではありません<br>\n";
    }
}

class B extends A
{
}

// これにより、B() がコンストラクタとしてコールされます。
$b = new B;
?>
]]>
    </programlisting>
   </informalexample>
   
   <para>
    クラスAの関数 B() は、意図されていない場合でも突然クラスB の
    コンストラクタになってしまいました。PHP 4 は、この関数が
    クラスBで定義されているかとかその関数が継承されているかどうかは
    考慮しません。
   </para>
   
   <caution>
    <simpara>
     PHP では派生クラスのコンストラクタから基底クラスの
     コンストラクタを自動的にコールすることはできません。
     上流のコンストラクタを適切にコールするように伝播させることは
     あなたの責任でやるべきことです。
    </simpara>
   </caution>
   
   <para>
    デストラクタは、<function>unset</function>またはスコープから
    でることにより、オブジェクトが破棄される度に自動的にコールされる関数です。
    PHPにはデストラクタはありません。デストラクタの機能の多くを
    シミュレーションするには、代わりに
     <function>register_shutdown_function</function> を使用します。
   </para>
  </sect1>

 <sect1 xml:id="keyword.paamayim-nekudotayim"><!-- :-) -->
   <title><literal>::</literal></title>

   <caution>
    <simpara>
     以下の記述は、PHP 4 以降でのみ有効です。
    </simpara>
   </caution>

   <para>
    基底クラスの関数や変数を参照したり、まだ特定のインスタンスを持たない
    クラスの関数を参照したりできると便利であるような場合があります。
    演算子 <literal>::</literal> はこのような場合に使用されます。
   </para>
   
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class A
{
    function example()
    {
       echo "オリジナルの関数A::example().<br>\n";
    }
}

class B extends A
{
    function example()
    {
        echo "再定義された関数B::example().<br>\n";
        A::example();
    }
}

// クラスAのオブジェクトはありません
// この例は、「オリジナルの関数A::example().<br>」を出力しま
// す
A::example();

// クラスBのオブジェクトを作成
$b = new B;

// この例の出力は次のようになります。
//   再定義された関数B::example().<br>
//   オリジナルの関数A::example().<br>
$b->example();
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    上の例では、関数 <literal>example()</literal> がクラスAでコールされていますが、クラスA
    のオブジェクトはありません。このため、<literal>$a->example()</literal> のように書くこと
    はできません。代わりに、<literal>example()</literal> を「クラス関数」、つまり、そのク
    ラスのオブジェクトではなく、クラス自体の関数としてとしてコールしま
    す。
   </para>
   
   <para>
    クラス関数はありますが、クラス変数はありません。実際、コールをする
    時点ではオブジェクトは存在しません。つまり、クラス関数はどのオブジェ
    クト変数も使用することはできません。(しかし、ローカル変数やグロー
    バル変数は使用可能です。)また、<varname>$this</varname>を
    使用することはできません。
   </para>

   <para>
    上の例では、クラスBは関数 <literal>example()</literal> を再定義しています。クラスAの元
    の定義は隠され、::演算子を使用してクラスAの <literal>example()</literal> の実装を明示的
    に参照しない限り利用できなくなっています。これを行うには、
    <literal>A::example()</literal> と書いてください (実際には、次節で示すように
    <literal>parent::example()</literal> と書く必要があります)。
   </para>
   
   <para>
    この状況では、カレントのオブジェクトがあり、オブジェクト変数を保持
    することが可能です。つまり、オブジェクト関数の内部で使用された場合、
    <varname>$this</varname>およびオブジェクト変数を使用することが可能です。
   </para>

 </sect1>

 <sect1 xml:id="keyword.parent">
  <title><literal>親クラス</literal></title>

  <para>
    基底クラスの変数と関数を参照するコードを書くことが可能です。これは、
    派生クラスが基底クラスのコードを特定の用途向けに改造したりする場合
    には、特に有用です。
  </para>
  
  <para>
    コードの基底クラスのリテラル名を使用する代わりに、特別な名前
    <literal>parent</literal>を使用する必要があります。この名前は、
    クラスの<literal>extends</literal>宣言で指定された基底クラスの名前
    を指しています。これにより、基底クラスの名前を複数の場所で使用する
    ことを避けることが可能です。実装の際に継承ツリーを変更した場合でも、
    変更は簡単で、クラスの <literal>extends</literal>
    宣言を変更するだけですみます。
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class A
{
    function example()
    {
        echo "A::example()です。基本関数を提供します。<br>\n";
    }
}

class B extends A
{
    function example()
    {
        echo "B::example()です。付加的な機能を提供します。<br>\n";
        parent::example();
    } 
}

$b = new B;
     
// B::example()をコールし、この関数の中からA::example()がコールされます。
$b->example();
?>
]]>
   </programlisting>
  </informalexample>
 </sect1>

 <sect1 xml:id="language.oop.serialization">
  <title>オブジェクトのシリアル化 - セッションでのオブジェクト</title>

  <para>
    <function>serialize</function> は、PHPで保存可能な全ての値のバイト
    ストリーム表現を有する文字列を返します。
    <function>unserialize</function> は、この文字列を使用して元の変数
    値を再生することが可能です。オブジェクトを保存するためにシリアル化
    を行うと、オブジェクトの全ての変数が保存されます。オブジェクトの関
    数は保存されません。クラス名だけが保存されます。
  </para>
  
  <para>
   オブジェクトの <function>unserialize</function> を可能とするために、
   そのオブジェクトのクラスが定義される必要があります。つまり、クラス
   Aのオブジェクト<varname>$a</varname>を <filename>page1.php</filename> で定義し、
   これをシリアル化した場合、
   クラスAを指す文字列が得られ、そこには、$aに含まれる変数の全ての値
   が含まれます。<filename>page2.php</filename> でこの文字列を非シリアル化したい場合、クラ
   スAの<varname>$a</varname>を再生します。クラスAの定義が、<filename>page2.php</filename> に
   現れます。これは、
   例えば、クラスAのクラス定義をインクルードファイルの中に保存し、
   <filename>page1.php</filename> および <filename>page2.php</filename> の中で共にこのファイルを読み込むことに
   より実行可能です。
  </para>
  
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
// classa.inc:
  
  class A 
  {
      var $one = 1;
    
      function show_one()
      {
          echo $this->one;
      }
  }
  
// page1.php:

  include("classa.inc");
  
  $a = new A;
  $s = serialize($a);
  // page2.phpが見付られる場所に$sを保存
  $fp = fopen("store", "w");
  fwrite($fp, $s);
  fclose($fp);

// page2.php:
  
  // これは非シリアル化が正しく動作するために必要
  include("classa.inc");

  $s = implode("", @file("store"));
  $a = unserialize($s);

  // オブジェクト$aの関数show_one()を使用する
  $a->show_one();
?>
]]>
   </programlisting>
  </informalexample>
  
  <para>
   セッションを使用している場合に、オブジェクトを登録するために
   <function>session_register</function>を使用すると、これらのオブジェ
   クトは各PHPページの最後で自動的にシリアル化され、次のページで自動
   的に非シリアル化されます。これは、基本的に、これらのオブジェクトが
   一旦セッション変数となると、全てのページに現れることを意味します。
  </para>
  
  <para>
   全てのページでこれらのクラスを実際には使用しない場合でも、
   全てのページでこのような登録された全てのオブジェクトのクラス定義を読み込むことを強く推奨します。
   これを行わずに、クラス定義が存在しない状態でオブジェクトが非シリアル化された場合、
   クラスの相関が失われてすべての関数が利用できなくなるため、
   <classname>__PHP_Incomplete_Class_Name</classname>
   クラスのオブジェクトは利用価値がかなり低くなります。
  </para>
  
  <para>
    このため、上の例で、<literal>session_register("a")</literal>を実行
    することにより $a がセッションの一部となった場合、<filename>page1.php</filename> および
    <filename>page2.php</filename> だけでなく、全てのページでファイル
    <literal>classa.inc</literal> を読み込むべきです。
  </para>
 </sect1>

 <sect1 xml:id="language.oop.magic-functions">
   <title>
    特殊関数<literal>__sleep</literal> および
    <literal>__wakeup</literal>
   </title>
   <para>
    <function>serialize</function> は、クラスに特殊な名前
    <literal>__sleep</literal> の関数があるかどうかを調べます。
    もしあれば、シリアル化の前にその関数を実行します。
    この関数で、オブジェクトをクリアすることができます。
    またこの関数は、シリアル化するオブジェクトについて、
    すべての変数の名前を配列で返すことが前提となっています。
    このメソッドが何も返さなかった場合は、&null;
    がシリアル化され、E_NOTICE が発生します。
   </para>
   
   <para>
    典型的な <literal>__sleep</literal> の使用法は、
    途中のデータをコミットしたり、
    似たようなタスクのクリアを行うといったものです。
    また、オブジェクトが非常に大きく、かつ、完全に保存する必要がない場合、
    この関数が有用です。
   </para>
   
   <para>
    逆に、 <function>unserialize</function> は、特殊な名前
    <literal>__wakeup</literal> を有する関数が存在するかどうかを確認し
    ます。これが存在する場合、この関数は、そのオブジェクトが有する全て
    のリソースを再構築することが可能です。
   </para>
   
   <para>
    典型的な<literal>__wakeup</literal>の使用法は、シリアル化により失っ
    たデータベース接続を全て再度復旧したり、その他の再初期化作業を実行
    したりといったものです。
   </para>
 </sect1>
  
 <sect1 xml:id="language.oop.newref">
   <title>コンストラクタの内部での参照</title>
   <para>
    コンストラクタの中で参照を作成すると結果が混乱する可能性があります。
    本節ではチュートリアル形式で説明しますが、
    この問題を避けるために役立つはずです。
 
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Foo($name)
    {
        // 内部への参照グローバル配列 $globalref を作成
        global $globalref;
        $globalref[] = &$this;
        // name を指定した値に設定
        $this->setName($name);
        // それを出力
        $this->echoName();
    }

    function echoName()
    {
        echo "<br>",$this->Name;
    }

    function setName($name)
    {
        $this->Name = $name;
    }
}
?>
]]>
    </programlisting>
   </informalexample>
  </para>
    
   <para>
    コピー演算子 <literal>=</literal> により作成された
    <varname>$bar1</varname> と 参照演算子 <literal>=&amp;</literal>
    により作成された <varname>$bar2</varname> の間の差異があるかどうかを
    確認してみましょう。

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$bar1 = new foo('set in constructor');
$bar1->echoName();
$globalref[0]->echoName();

/* 出力:
set in constructor
set in constructor
set in constructor */

$bar2 =& new foo('set in constructor');
$bar2->echoName();
$globalref[1]->echoName();

/* 出力:
set in constructor
set in constructor
set in constructor */
?>
]]>    
     </programlisting>
    </informalexample>
   </para>
   <para>
    明らかに違いはありませんが、実際には動作は非常に異なっています。つまり、
    <varname>$bar1</varname> と <varname>$globalref[0]</varname>
    は参照されておらず、同じ変数でもありません。
    これは、"<literal>new</literal>" がデフォルトで参照を返さず、代わりにコピーを返すためです。
    <note>
     <simpara>
      (PHP 4 以降ではリファレンスカウンティングを使用しているため)、
      参照ではなくコピーを返すことで性能が低下することはありません。逆に
      多くの場合、参照を使うよりも単純にコピーを使った方が良い結果となります。
      これは、参照の作成には時間がかかりますが、コピーの作成には
      理想的には時間が全くかからないからです (ただし、大きな配列
      またはオブジェクトでその一つが変更されると、次々に参照先の他の要素に
      参照先に波及するといった場合を除きます)。
     </simpara>
    </note>
    上記の記述が正しいことを示すために以下のコードを見てみましょう。

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// ここで、name を変更してみます。どうなるでしょうか?
// $bar と $globalref[0] の両方共名前が変わると予想するかもしれません...
$bar1->setName('set from outside');

// 前記のようにこの場合は違います。
$bar1->echoName();
$globalref[0]->echoName();

/* 出力: 
set from outside
set in constructor */

// $bar2 と $globalref[1] の差を見てみましょう
$bar2->setName('set from outside');

// うまく行けば、値が等しいだけでなく、同じ変数となります。
// つまり、$bar2->Name と $globalref[1]->Name も同じになります。
$bar2->echoName();
$globalref[1]->echoName();

/* 出力: 
set from outside 
set from outside */
?>
]]>        
     </programlisting>
    </informalexample>   
   </para>   
   <para>
    最後に別の例について考えてみてください。
    
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php      
class A {
    function A($i) {
        $this->value = $i;
        // ここで参照を使う必要がない理由を考えてみてください
        $this->b = new B($this);
    }

    function createRef() {
        $this->c = new B($this);
    }

    function echoValue() {
        echo "<br>","class ",get_class($this),': ',$this->value;
    }
}

class B {
    function B(&$a) {
        $this->a = &$a;
    }

    function echoValue() {
        echo "<br>","class ",get_class($this),': ',$this->a->value;
    }
}

// 以下の単純なコピーが、* 印を付けた行で望ましくない結果を生む理由を
// 考えてみてください。
$a =& new A(10);
$a->createRef();

$a->echoValue();
$a->b->echoValue();
$a->c->echoValue();

$a->value = 11;

$a->echoValue();
$a->b->echoValue(); // *
$a->c->echoValue();

?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
class A: 10
class B: 10
class B: 10
class A: 11
class B: 11
class B: 11
]]>
     </screen>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="language.oop.object-comparison">
   <title>におけるオブジェクトの比較</title>
  <para>
   PHP4では、とてもシンプルな作法でオブジェクトを比較できます。すなわち、
   二つのオブジェクトは同じ属性と同じ値を持ち、同じクラスのインスタンス
   である場合には等しいのです。二つのオブジェクトを比較演算子
   (<literal>===</literal>)で比較した場合でも同様のルールとなります。
  </para>
  <para>
   以下の例のようなコードを実行するとしましょう:
   <example>
    <title>PHP 4におけるオブジェクトの比較の例</title>
    <programlisting role='php'>
<![CDATA[
<?php
function bool2str($bool) {
    if ($bool === false) {
            return 'FALSE';
    } else {
            return 'TRUE';
    }
}

function compareObjects(&$o1, &$o2) {
    echo 'o1 == o2 : '.bool2str($o1 == $o2)."\n";
    echo 'o1 != o2 : '.bool2str($o1 != $o2)."\n";
    echo 'o1 === o2 : '.bool2str($o1 === $o2)."\n";
    echo 'o1 !== o2 : '.bool2str($o1 !== $o2)."\n";
}

class Flag {
    var $flag;

    function Flag($flag=true) {
            $this->flag = $flag;
    }
}

class SwitchableFlag extends Flag {

    function turnOn() {
        $this->flag = true;
    }

    function turnOff() {
        $this->flag = false;
    }
}

$o = new Flag();
$p = new Flag(false);
$q = new Flag();

$r = new SwitchableFlag();

echo "同じ引数で生成されたインスタンスの比較\n";
compareObjects($o, $q);

echo "\n違う引数で生成されたインスタンスの比較\n";
compareObjects($o, $p);

echo "\n親クラスとそのサブクラスのインスタンスの比較\n";

compareObjects($o, $r);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[    
同じ引数で生成されたインスタンスの比較
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : TRUE
o1 !== o2 : FALSE

違う引数で生成されたインスタンスの比較
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE

親クラスとそのサブクラスのインスタンスの比較
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE
]]>
    </screen>
   </example>   
   比較のルールに基づいた結果が得られたと思います。
   その属性に同じ値を持ち、かつ同じクラスから生成されたインスタンスだけが
   等しいとみなされます。
  </para>
  <para>
   複合的なオブジェクトの場合であっても、同じ比較ルールが適用されます。
   以下の例では、<classname>Flag</classname>オブジェクトの連想配列
   が格納されてるコンテナが生成されています。
   <example>
    <title>PHP4における複合的なオブジェクトの比較</title>
    <programlisting role='php'>
<![CDATA[
<?php
class FlagSet {
    var $set;

    function FlagSet($flagArr = array()) {
        $this->set = $flagArr;
    }

    function addFlag($name, $flag) {
        $this->set[$name] = $flag;
    }

    function removeFlag($name) {
        if (array_key_exists($name, $this->set)) {
            unset($this->set[$name]);
        }
    }
}


$u = new FlagSet();
$u->addFlag('flag1', $o);
$u->addFlag('flag2', $p);
$v = new FlagSet(array('flag1'=>$q, 'flag2'=>$p));
$w = new FlagSet(array('flag1'=>$q));

echo "\nComposite objects u(o,p) and v(q,p)\n";
compareObjects($u, $v);

echo "\nu(o,p) and w(q)\n";
compareObjects($u, $w);
?>     
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Composite objects u(o,p) and v(q,p)
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : TRUE
o1 !== o2 : FALSE

u(o,p) and w(q)
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE
]]>
    </screen>
   </example>
  </para>
 </sect1>

  <sect1 xml:id="language.oop.object-comparison-php5">
   <title>PHP 5におけるオブジェクトの比較</title>
   &warn.experimental;
   <para>
    PHP 5では、オブジェクトの比較はPHP 4よりも複雑になり、
    オブジェクト指向言語で期待される動作により近くなります。
    (PHP 5はオブジェクト指向言語ではありません)
   </para>
   <para>
    比較演算子(<literal>==</literal>)を用いた場合、
    オブジェクト変数は単純に比較されます。つまり、
    同じ属性と値を有し、同じクラスのインスタンスである場合に
    二つのオブジェクトのインスタンスが等しくなります。
   </para>
   <para>
    一方、identity演算子(<literal>===</literal>)の場合、
    オブジェクト変数は、同じクラスの同じインスタンスを参照する場合のみ
    等しくなります。
   </para>
   <para>
    これらの規則を明確にするための例を示します。
    <example>
     <title>PHP 5のオブジェクト比較の例</title>
     <programlisting role='php'>
<![CDATA[
<?php
function bool2str($bool) {
    if ($bool === false) {
            return 'FALSE';
    } else {
            return 'TRUE';
    }
}

function compareObjects(&$o1, &$o2) {
    echo 'o1 == o2 : '.bool2str($o1 == $o2)."\n";
    echo 'o1 != o2 : '.bool2str($o1 != $o2)."\n";
    echo 'o1 === o2 : '.bool2str($o1 === $o2)."\n";
    echo 'o1 !== o2 : '.bool2str($o1 !== $o2)."\n";
}

class Flag {
    var $flag;

    function Flag($flag=true) {
            $this->flag = $flag;
    }
}

class OtherFlag {
    var $flag;

    function OtherFlag($flag=true) {
            $this->flag = $flag;
    }
}

$o = new Flag();
$p = new Flag();
$q = $o;
$r = new OtherFlag();

echo "Two instances of the same class\n";
compareObjects($o, $p);

echo "\nTwo references to the same instance\n";
compareObjects($o, $q);

echo "\nInstances of two different classes\n";
compareObjects($o, $r);
?>
]]>
     </programlisting>
    </example>
    この例の出力は以下のようになります。
    <screen>
Two instances of the same class
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : FALSE
o1 !== o2 : TRUE

Two references to the same instance
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : TRUE
o1 !== o2 : FALSE

Instances of similarly named classes in different namespaces
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE
    </screen>
   </para>
  </sect1>
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
