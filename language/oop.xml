 <chapter id="language.oop">
  <title>クラスとオブジェクト</title>

  <sect1 id="keyword.class">
   <title><literal>クラス</literal></title>
   <para>
    クラスは、変数およびこれらの変数で動作する関数の集まりです。
    クラスは次のような構文により定義されます。
 
     <informalexample>
      <programlisting role="php">
&lt;?php
class Cart {
    var $items;  // 買い物篭の中のアイテム
   
    // $num 個の $artnr を買い物篭に加えます
 
    function add_item ($artnr, $num) {
        $this->items[$artnr] += $num;
    }
   
    // $num 個の $artnr を買い物籠から出します
 
    function remove_item ($artnr, $num) {
        if ($this->items[$artnr] > $num) {
            $this->items[$artnr] -= $num;
            return true;
        } else {
            return false;
        }   
    }
}
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <para>
    この例は、籠の中の物と籠にアイテムを加えたり除いたりする二つの関数への
    連想配列からなる Cart という名前のクラスを定義します。
   </para>
   <note>
    <simpara>
     PHP 4では、変数<literal>var</literal>については定数による初期化の
     みが可能です。定数以外で初期化を行う場合にはコンストラクタを使用
     して下さい。
    </simpara>
    <informalexample>
     <programlisting role="php">
/* 以下のコードはPHP 4では動作しません。 */
class Cart {
    var $todays_date = date("Y-m-d");
    var $name = $firstname;
    var $owner = 'Fred ' . 'Jones';
}

/* 以下に正しい方法を示します。 */
class Cart {
    var $todays_date;
    var $name;
    var $owner;

    function Cart() {
        $this->todays_date = date("Y-m-d");
        $this->name = $GLOBALS['firstname'];
        /* 等など. . . */
    }
}
     </programlisting>
    </informalexample>
   </note>
   <para>
    クラスは型、つまり、実際の変数の雛型です。
    new 演算子により所望の型の変数を作成する必要があります。
   </para>
 
   <informalexample>
    <programlisting role="php">
$cart = new Cart;
$cart->add_item("10", 1);
    </programlisting>
   </informalexample>
 
   <para>
    この例は、クラス Cart のオブジェクト $cart を作成します。
    オブジェクトの関数 add_item() が番号10 の物を籠に加えるためにコールされ
    ています。
   </para>
   <para>
    クラスは、他のクラスを拡張することにより作成することができます。
    拡張または派生クラスは、基底クラスの全ての変数と関数、そして、
    拡張する際の定義により加えられたものを保持しています。
    この定義は、extends キーワードにより行なうことができます。
    多重継承はサポートされていません。
   </para>
 
   <informalexample>
    <programlisting role="php">
class Named_Cart extends Cart {
    var $owner;
  
    function set_owner ($name) {
        $this->owner = $name;
    }
}
    </programlisting>
   </informalexample>
 
   <para>
    この例は、Cart の全ての変数及び関数に加えて変数 $owner と
    関数 $set_owner を保持するクラス Named_Cart を定義しています。
    この定義により、名前付きの籠を通常の手段で作成し、籠の保有者を
    設定したり得たりすることができます。
    名前付きの籠で元の籠クラスの関数を使うことも可能です。
   </para>
 
   <informalexample>
    <programlisting role="php">
$ncart = new Named_Cart;    // 名前付きの籠を作成
$ncart->set_owner ("kris"); // 籠の所有者の名前を設定
print $ncart->owner;        // 籠の所有者を出力
$ncart->add_item ("10", 1); // (籠から継承された機能)
    </programlisting>
   </informalexample>
  
   <para>
    クラスにおける関数の中では、変数 $this はそのオブジェクト自身を意
    味します。オブジェクトの中では、何らかのクラス変数や関数にアクセス
    したい場合に $this->something を使う必要があります。オブジェクトの
    内部または外部の場合、そのオブジェクトのプロパティにアクセスする際
    に $ は不要です。
   </para>
   
   <informalexample>
    <programlisting role="php">
$ncart->owner  = "chris"; //  $ は不要

$ncart->$owner = "chris";
// $ncart->$owner = $ncart->"" なのでこれは誤り

$myvar = 'owner';
$ncart->$myvar = "chris";  
// $ncart->$myvar = $ncart->ownerなのでこれは有効
    </programlisting>
   </informalexample>

   <para>
    コンストラクタは、クラスの新しいインスタンスを作成する際に
    自動的にコールされるクラス関数です。
    関数は、クラスと同じ名前を有する際にコンストラクタとなります。
   </para>
 
   <informalexample>
    <programlisting role="php">
class Auto_Cart extends Cart {
    function Auto_Cart () {
        $this->add_item ("10", 1);
    }
}
    </programlisting>
   </informalexample>
 
   <para>
    この例は、Cart にコンストラクタを加えたクラス Auto_Cart を定義しています。
    このコンストラクタは、"new" により新しい Auto_Cart が作成される度に
    籠に 10 番の物を一つ保持するように初期化します。
    コンストラクタは、オプションとして引数をとります。
    これにより、コンストラクタは非常に便利なものとなります。
   </para>
 
   <informalexample>
    <programlisting role="php">
class Constructor_Cart extends Cart {
    function Constructor_Cart ($item = "10", $num = 1) {
        $this->add_item ($item, $num);
    }
}
 
// しつこいが、前の例と同じものを買う
 
$default_cart   = new Constructor_Cart;
 
// 実際に買うもの篭に入れる...
 
$different_cart = new Constructor_Cart ("20", 17);
    </programlisting>
   </informalexample>
 
   <caution>
    <simpara>
     派生クラスの場合、派生クラスのコンストラクタがコールされた時にも
     親クラスのコンストラクタが自動的にコールされるということはありま
     せん。
    </simpara>
   </caution>
  </sect1>
 
  <sect1 id="language.oop.newref">
   <title>コンストラクタの中での参照</title>
   <para>
    コンストラクタの中で参照を作成すると結果が混乱する可能性があります。
    本節ではチュートリアル形式で説明しますが、この問題を避けるために役
    立つはずです。
 
    <informalexample>
     <programlisting role="php">

class foo {
    function foo($name) {
        // 内部への参照グローバル配列 $globalref を作成
        global $globalref;
	$globalref[] = &amp;$this;
        // name を指定した値に設定
        $this->setName($name);
	// それを出力
        $this->echoName();
    }

    function echoName() {
        echo "&lt;br&gt;",$this->Name;
    }
	
	function setName($name)	{
		$this->Name = $name;
    }
}
     </programlisting>
    </informalexample>
   </para>
   
   <para>
    コピー演算子 <literal>=</literal> により作成された
    <varname>$bar1</varname> と 参照演算子 <literal>=&amp;</literal>
    により作成された <varname>$bar2</varname> の間の差異があるかどうか
    を確認してみましょう。

    <informalexample>
     <programlisting role="php">
   
    $bar1 = new foo('set in constructor');
    $bar1->echoName();
    $globalref[0]->echoName();
    
    /* 出力:
    set in constructor
    set in constructor
    set in constructor */
    
    $bar2 =&amp; new foo('set in constructor');
    $bar2->echoName();
    $globalref[1]->echoName();

    /* 出力:
    set in constructor
    set in constructor
    set in constructor */
    
     </programlisting>
    </informalexample>
   </para>
   <para>
    明らかに違いはありませんが、実際には動作は非常に異なっています。つ
    まり、<varname>$bar1</varname> と <varname>$globalref[0]</varname>
    は、 参照されておらず、同じ変数でもありません。
    これは、"new" がデフォルトで参照を返さず、代わりにコピーを返すため
    です。
    <note>
     <simpara>
      (PHP 4以降ではリファレンスカウンティングを使用しているため、)参
      照ではなくコピーを返すことで性能が低下することはありません。逆に
      多くの場合、参照を使うよりも単純にコピーを使った方が良い結果とな
      ります。これは、参照の作成には時間がかかりますが、コピーの作成に
      は理想的には時間が全くかからないからです。(ただし、大きな配列ま
      たはオブジェクトでその一つが変更されると、次々に参照先の他の要素
      に参照先に波及するといった場合を除きます)
     </simpara>
    </note>
    上記の記述が正しいことを示すために以下のコードを見てみましょう。

    <informalexample>
     <programlisting role="php">
// ここで、name を変更してみます。どうなるでしょうか?
// $bar と $globalref[0] の両方共名前が変わると予想するかもしれません...
$bar1->setName('set from outside');

// 前記のようにこの場合は違います。
$bar1->echoName();
$globalref[0]->echoName();

/* 出力:
set on object creation set from outside */

// $bar2 と $globalref[1] の差を見てみましょう
$bar2->setName('set from outside');

// うまく行けば、値が等しいだけでなく、同じ変数となります。
// つまり、$bar2->Name と $globalref[1]->Name も同じになります。
$bar2->echoName();
$globalref[1]->echoName();

/* 出力: 
set from outside set from outside */
        
     </programlisting>
    </informalexample>   
   </para>   
   <para>
    別の最後の例について考えてみて下さい。
   
    <informalexample>
     <programlisting role="php">

class a {
    function a($i) {
        $this->value = $i;
        // ここで参照を使う必要がない理由を考えてみて下さい
        $this->b = new b($this);
    }

    function createRef() {
        $this->c = new b($this);
    }

    function echoValue() {
        echo "&lt;br&gt;","class ",get_class($this),': ',$this->value;
        }
}


class b  {

    function b(&amp;$a) {
        $this->a = &amp;$a;
    }

   function echoValue() {
        echo "&lt;br&gt;","class ",get_class($this),': ',$this->a->value;
        }

}

// 以下の単純なコピーが、* 印を付けた行で望ましくない結果を生む理由を
// 考えてみて下さい。
$a =&amp; new a(10);
$a->createRef();

$a->echoValue();
$a->b->echoValue();
$a->c->echoValue();

$a->value = 11;

$a->echoValue();
$a->b->echoValue(); // *
$a->c->echoValue();

/*
出力:
class a: 10
class b: 10
class b: 10
class a: 11
class b: 11
class b: 11
*/
     </programlisting>
    </informalexample>
   </para>
  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
