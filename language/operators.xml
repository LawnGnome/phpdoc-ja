<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.38 $ -->
<!-- EN-Revision: 1.112 Maintainer: hirokawa Status: ready -->
<!-- CREDITS: takagi -->
 <chapter id="language.operators">
  <title>演算子</title>
  <simpara>
   演算子とは、ひとつ以上の値 (あるいはプログラミング用語における「式」)
   から別の値 (制御構造が式になるように) を生み出すものです。
   つまり、値を返す関数や制御構造 (たとえば print) は演算子と考えられますし、
   何も値を返さないもの (たとえば echo) はそれ以外のものとなります。
  </simpara>
  <para>
   演算子には 3 種類あります。ひとつめは単項演算子で、これはひとつの値に
   対してのみ作用します。例えば ! (否定演算子) や ++ (加算子) などです。
   ふたつめは二項演算子と呼ばれるものです。PHP がサポートしている演算子の
   ほとんどはここに含まれ、その一覧は
   <link linkend="language.operators.precedence">演算子の優先順位</link>
   にあります。
  </para>
  <para>
   最後のグループは、三項演算子 ?: です。これは、2 つの文や実行経路から選択すると
   いうよりも、3 番目の式に応じて 2 つの式から選択するために使用されるべきです。
   この演算子を使用する式は、括弧で囲んでおくことをお勧めします。
  </para>

  <sect1 id="language.operators.precedence">
   <title>演算子の優先順位</title>
   <para>
    演算子の優先順位は、二つの式が"緊密に"結合している度合いを指定します。
    例えば、式 <literal>1 + 5 * 3</literal> の答えは
    <literal>16</literal> になり、<literal>18</literal> とはなりません。
    これは乗算演算子("*")は、加算演算子("+")より高い優先順位を有するか
    らです。必要に応じて強制的に優先順位を設定するために括弧を使用する
    ことが可能です。例えば、<literal>18</literal>と評価するためには、
    <literal>(1 + 5) * 3</literal> とします。
    演算子の優先順位が等しい場合は、左から右へ順に評価されます。
   </para>
   <para>
    以下の表では、優先順位が高い順に演算子を挙げています。
    同じ行にある演算子は優先順位が等しくなります。そのような場合は、
    結合時の評価にしたがって評価順が決まります。
    <table>
     <title>演算子の優先順位</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>結合時の評価</entry>
        <entry>演算子</entry>
        <entry>追加情報</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>結合しない</entry>
        <entry>new</entry>
        <entry><link linkend="language.oop5.basic.new">new</link></entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>[</entry>
        <entry><function>array</function></entry>
       </row>
       <row>
        <entry>結合しない</entry>
        <entry>++ --</entry>
        <entry>
         <link linkend="language.operators.increment">加算子/減算子</link>
        </entry>
       </row>
       <row>
        <entry>結合しない</entry>
        <entry>~ - (int) (float) (string) (array) (object) @</entry>
        <entry>
         <link linkend="language.types">型</link>
        </entry>
       </row>
       <row>
        <entry>結合しない</entry>
        <entry>instanceof</entry>
        <entry>
         <link linkend="language.types">型</link>
        </entry>
       </row>
       <row>
        <entry>right</entry>
        <entry>!</entry>
        <entry>
         <link linkend="language.operators.logical">論理演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>* / %</entry>
        <entry>
         <link linkend="language.operators.arithmetic">代数演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>+ - .</entry>
        <entry>
         <link linkend="language.operators.arithmetic">代数演算子</link>&listendand; 
         <link linkend="language.operators.string">文字列演算子</link></entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>&lt;&lt; &gt;&gt;</entry>
        <entry>
         <link linkend="language.operators.bitwise">ビット演算子</link>
        </entry>
       </row>
       <row>
        <entry>結合しない</entry>
        <entry>&lt; &lt;= &gt; &gt;=</entry>
        <entry>
         <link linkend="language.operators.comparison">比較演算子</link>
        </entry>
       </row>
       <row>
        <entry>結合しない</entry>
        <entry>== != === !==</entry>
        <entry>
         <link linkend="language.operators.comparison">比較演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>&amp;</entry>
        <entry>
         <link linkend="language.operators.bitwise">ビット演算子</link>&listendand; 
         <link linkend="language.references">リファレンス</link></entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>^</entry>
        <entry>
         <link linkend="language.operators.bitwise">ビット演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>|</entry>
        <entry>
         <link linkend="language.operators.bitwise">ビット演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>&amp;&amp;</entry>
        <entry>
         <link linkend="language.operators.logical">論理演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>||</entry>
        <entry>
         <link linkend="language.operators.logical">論理演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>? :</entry>
        <entry>
         <link linkend="language.operators.comparison.ternary">三項演算子</link>
        </entry>
       </row>
       <row>
        <entry>right</entry>
        <entry>
         = += -= *= /= .= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;=
        </entry>
        <entry>
         <link linkend="language.operators.assignment">代入演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>and</entry>
        <entry>
         <link linkend="language.operators.logical">論理演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>xor</entry>
        <entry>
         <link linkend="language.operators.logical">論理演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>or</entry>
        <entry>
         <link linkend="language.operators.logical">論理演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>,</entry>
        <entry>さまざまな利用法</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <para>
    結合時の評価が left の場合は式が左から右に評価され、一方 right の場合は
    その逆となります。
    <example>
     <title>結合時の評価</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 3 * 3 % 5; // (3 * 3) % 5 = 4
$a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2

$a = 1;
$b = 2;
$a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5
?>
]]>
     </programlisting>
    </example>
    コードの可読性を高めるためには括弧を使用します。
   </para>
   <note>
    <para>
     <literal>=</literal> は他のほとんどの演算子よりも優先順位が低いはずなのにもかかわらず、
     PHP は依然として <literal>if (!$a = foo())</literal>
     のような式も許します。この場合は <literal>foo()</literal> の返り値が
     <varname>$a</varname> に代入されます。
    </para>
   </note>
  </sect1>
  
  <sect1 id="language.operators.arithmetic">
   <title>代数演算子</title>
   <simpara>
    学校で習った基礎代数を憶えていますか?
    この演算子はそれらと同様に動作します。
   </simpara>
   <table>
    <title>代数演算子</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例</entry>
       <entry>名前</entry>
       <entry>結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>-$a</entry>
       <entry>負にする</entry>
       <entry>$a の逆</entry>
      </row>
      <row>
       <entry>$a + $b</entry>
       <entry>加算</entry>
       <entry>$a および $b の合計</entry>
      </row>
      <row>
       <entry>$a - $b</entry>
       <entry>減算</entry>
       <entry>$a と $b の差</entry>
      </row>
      <row>
       <entry>$a * $b</entry>
       <entry>乗算</entry>
        <entry>$a および $b の積</entry>
      </row>
      <row>
       <entry>$a / $b</entry>
       <entry>割算</entry>
        <entry>$a および $b の商</entry>
      </row>
      <row>
       <entry>$a % $b</entry>
       <entry>剰余</entry>
       <entry>$a を $b で割った余り</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  
   <simpara>
    2 つのオペランドが整数の場合(または整数に変換された文字列の場合)
    であっても、割算演算子 ("/") は常に float 値を返します。
   </simpara>
   <note>
    <simpara>
     <literal>$a</literal> が負の場合、<literal>$a % $b</literal>
     は負の値となることを覚えておきましょう。
    </simpara>
   </note>
   <simpara>
    マニュアルの
    <link linkend="ref.math">数学関数</link>の項も参照してください。
   </simpara>

   <!--
   <simpara>
    The division operator ("/") returns an integer value (the result
    of an integer division) if the two operands are integers (or
    strings that get converted to integers) and the quotient is an
    integer. If either operand is a floating-point value, or the
    operation results in a non-integer value, a floating-point value
    is returned.
   </simpara>
   -->
  </sect1>

  <sect1 id="language.operators.assignment">
   <title>代入演算子</title>
   <simpara>
    代入演算子の基本となるものは "=" です。この演算子に関して最初に
    思い付く意味は"等しい"であるかもしれません。しかし、そうではありません。
    本当は、左オペランドに右オペランドの式の値を設定する("得て代入する")
    ことを意味します。
   </simpara>
   <para>
    代入式の値は、代入される値です。つまり、"$a = 3" の値は、3 です。
    これにより、以下のようなトリッキーなことができるようになります。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = ($b = 4) + 5; // $a は 9 に等しく、$b は 4 にセットされます。

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    基本代入演算子に加えて、全ての<link linkend="language.operators">
    バイナリ演算子</link>、配列結合および文字列演算子に関して
    「複合演算子」があります。
    これにより、式の中の値を使用し、その値をその式の結果とすることができます。
    例えば、
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = 3;
$a += 5; // $a を 8 にセットします。$a = $a + 5; と同じです。
$b = "Hello ";
$b .= "There!"; // $bを"Hello There!"にセットします。$b = $b . "There!";と同じです。

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    代入は、元の変数を新しい変数にコピーする(値による代入)ため、
    片方の変数に対する変更はもう片方に影響を与えないということに
    注意してください。この動作により、密なループの内側で大きな配列のようなものを
    コピーする必要がある場合には問題を生じる可能性があります。
    PHP 4 以降では、<computeroutput>$var = &amp;$othervar;</computeroutput>
    構文により参照による代入をサポートしていますが、PHP 3 ではサポート
    しません。'参照による代入'は、両方の変数が同じデータを指し、コピーを
    行わないことを意味します。参照に関する詳細については、
    <link linkend="language.references">リファレンスの説明</link>も
    参照ください。
    PHP 5 では、新しいキーワード
    <link linkend="language.oop5.cloning">clone</link>
    を使用して明示的に指定しない限り、オブジェクトは自動的に参照による代入になります。
   </para>
   </sect1>

  <sect1 id="language.operators.bitwise">
   <title>ビット演算子</title>
   <simpara>
    ビット演算子は、整数における特定のビットをオンまたはオフにすることを
    可能にします。もし左辺値と右辺値共に文字列であった場合にはビット演算子は
    文字の ASCII 値に対して作用します。
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo 12 ^ 9; // '5'を出力します

echo "12" ^ "9"; // バックスペース文字を出力します(ascii 8)
                 // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8

echo "hallo" ^ "hello"; // ascii値の #0 #4 #0 #0 #0 を出力します
                        // 'a' ^ 'e' = #4
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <table>
    <title>ビット演算子</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例</entry>
       <entry>名前</entry>
       <entry>結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a &amp; $b</entry>
       <entry>ビット積</entry>
       <entry>
    $a および $b の両方にセットされているビット
       </entry>
      </row>
      <row>
       <entry>$a | $b</entry>
        <entry>ビット和</entry>
       <entry>
    $a または $b のどちらかにセットされているビット
       </entry>
      </row>
      <row>
       <entry>$a ^ $b</entry>
       <entry>排他的論理和</entry>
       <entry>
    $a または $b にセットされており、両方にセットされていないビット
       </entry>
      </row>
      <row>
       <entry>~ $a</entry>
       <entry>否定</entry>
       <entry>
    $a にセットされているビットはセットせず、そうでないものは逆にする
       </entry>
      </row>
      <row>
       <entry>$a &lt;&lt; $b</entry>
       <entry>左シフト</entry>
       <entry>
    $a のビットを左に $b ビットシフトする(各シフトは "2をかける"
    ことを意味します)
       </entry>
      </row>
      <row>
       <entry>$a &gt;&gt; $b</entry>
       <entry>右シフト</entry>
       <entry>
    $a のビットを右に $b ビットシフトします (各シフトは "2で割る"
    ことを意味します)
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <warning>
    <para>
     32 ビットシステムでは 32 ビット以上の右シフトは行わないでください。
     また、結果が 32 ビットを超えてしまうような左シフトも行わないでください。
    </para>
   </warning>
  </sect1>
  
  <sect1 id="language.operators.comparison">
   <title>比較演算子</title>
   <simpara>
    比較演算子は、その名前が示すように、二つの値を比較します。
   </simpara>
   <table>
    <title>比較演算子</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例</entry>
       <entry>名前</entry>
       <entry>結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a == $b</entry>
       <entry>等しい</entry>
       <entry>$a が $b に等しい時に &true;。</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>等しい</entry>
       <entry>$a が $b に等しく同じ型でである場合に &true; (PHP 4 で導入)。
       </entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>等しくない</entry>
       <entry>$a が $b に等しくない場合に &true;。</entry>
      </row>
      <row>
       <entry>$a &lt;> $b</entry>
       <entry>等しくない</entry>
       <entry>$a が $b に等しくない場合に &true;</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>等しくない</entry>
       <entry>
        $a が $b と等しくないか、同じ型でない場合に &true; (PHP 4 で導入)。
       </entry>
      </row>
      <row>
       <entry>$a &lt; $b</entry>
       <entry>より少ない</entry>
       <entry>$a が $b より少ない時に &true;。</entry>
      </row>
      <row>
       <entry>$a &gt; $b</entry>
       <entry>より多い</entry>
       <entry>$a が $b より多い時に &true;。</entry>
      </row>
      <row>
       <entry>$a &lt;= $b</entry>
       <entry>より少ないか等しい</entry>
       <entry>$a が $b より少ないか等しい時に &true;。</entry>
      </row>
      <row>
       <entry>$a &gt;= $b</entry>
       <entry>より多いか等しい</entry>
       <entry>$a が $b より多いか等しい時に &true;。</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    整数値を文字列と比較する際、文字列が
    <link linkend="language.types.string.conversion">数値に変換されます</link>。
    数値形式の文字列を比較する場合、それは整数として比較されます。これらの
    ルールは、
    <link linkend="control-structures.switch">switch</link> 文にも適用されます。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
var_dump(0 == "a"); // 0 == 0 -> true
var_dump("1" == "01"); // 1 == 1 -> true

switch ("a") {
case 0:
    echo "0";
    break;
case "a": // "a" は 0 にマッチするので、決してここにはたどりつきません
    echo "a";
    break;
}
?>
]]>
     </programlisting>
    </informalexample> 
   </para>

   <para>
    多くの型では、以下の表に（上から順に）したがって比較が行われます。
   </para>
   <table id="language.operators.comparison.types">
    <title>さまざまな型の比較</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>第 1 オペランドの型</entry>
       <entry>第 2 オペランドの型</entry>
       <entry>結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>null</type> または <type>string</type></entry>
       <entry><type>string</type></entry>
       <entry>&null; を "" に変換し、数値または文字として比較します</entry>
      </row>
      <row>
       <entry><type>bool</type> または <type>null</type></entry>
       <entry>あらゆる型</entry>
       <entry><type>bool</type> に変換し、&false; &lt; &true; と判断します</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry><type>object</type></entry>
       <entry>組み込みクラスには独自の比較基準が定義されています。それ以外の
        クラスは比較できません。同じクラスであるかどうかは - プロパティが
        同じ値であるかどうかを配列形式で比較（PHP 4）、PHP 5 では <link
        linkend="language.oop5.object-comparison">ここで説明されています</link>。
       </entry>
      </row>
      <row>
       <entry><type>string</type>, <type>resource</type> または <type>number</type></entry>
       <entry><type>string</type>, <type>resource</type> または <type>number</type></entry>
       <entry>文字列やリソースを数値に変換し、算術演算を行います</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry><type>array</type></entry>
       <entry>要素数の少ない配列のほうが小さくなります。オペランド 1 のキーが
        オペランド 2 に存在しない場合、配列は比較できません。そうでない場合は
        個々の要素の値を比較します（以下の例を参照ください）</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry>あらゆる型</entry>
       <entry><type>array</type> のほうが常に大きくなります</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry>あらゆる型</entry>
       <entry><type>object</type> のほうが常に大きくなります</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    <example>
     <title>一般的な配列の比較</title>
     <programlisting role="php">
<![CDATA[
<?php
// 標準の比較演算子を用いて、配列はこのように比較されます
function standard_array_compare($op1, $op2)
{
    if (count($op1) < count($op2)) {
        return -1; // $op1 < $op2
    } elseif (count($op1) > count($op2)) {
        return 1; // $op1 > $op2
    }
    foreach ($op1 as $key => $val) {
        if (!array_key_exists($key, $op2)) {
            return null; // uncomparable
        } elseif ($val < $op2[$key]) {
            return -1;
        } elseif ($val > $op2[$key]) {
            return 1;
        }
    }
    return 0; // $op1 == $op2
}
?>
]]>
     </programlisting>
    </example> 
   </para>

   <para>
    <function>strcasecmp</function>,
    <function>strcmp</function>、
    <link linkend="language.operators.array">配列演算子</link>,
    マニュアルの
    <link linkend="language.types">型</link> のセクションも参照してください。
   </para>

   <sect2 id="language.operators.comparison.ternary">
    <title>三項演算子</title>
    <para>
     もうひとつの条件演算子として "?:"（あるいは三項）演算子があります。
     <example>
      <title>デフォルト値を設定する</title>
      <programlisting role="php">
<![CDATA[
<?php
// 三項演算子の使用例
$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];

// 上記は以下の if/else 式と同じです。
if (empty($_POST['action'])) {
    $action = 'default';
} else {
    $action = $_POST['action'];
}

?>
]]>
      </programlisting>
     </example> 
     <literal>(expr1) ? (expr2) : (expr3)</literal>
     という式は、<replaceable>式1</replaceable> が &true; の場合に
     <replaceable>式2</replaceable> を、
     <replaceable>式1</replaceable> が &false; の場合に
     <replaceable>式3</replaceable> を値とします。
    </para>
    <note>
     <simpara>
      三項演算子は式であり、値としては評価されずに式の結果として評価される
      ことに注意してください。演算結果をリファレンスとして返したい場合に、
      これを知っておくことが大切です。結果をリファレンスとして返す関数で
      <literal>return $var == 42 ? $a : $b;</literal> とすることはできず、
      新しいバージョンの PHP では警告を発生します。
     </simpara>
    </note>
    <note>
     <para>
      三項演算子を "積み重ねて" 使用することは避けましょう。
      ひとつの文の中で複数の三項演算子を使用した際の PHP の振る舞いは、
      少々わかりにくいものです。
      <example>
       <title>三項演算子のわかりにくい挙動</title>
       <programlisting role="php">
<![CDATA[
<?php
// ぱっと見た感じでは、これは 'true' と表示されると思うでしょう。
echo (true?'true':false?'t':'f');

// しかし、実際には上の出力結果は 't' です。
// なぜなら、三項演算子は左から右へ順に評価されるからです。

// 上のコードをもう少しわかりやすく書くと、このようになります。
echo ((true ? 'true' : 'false') ? 't' : 'f');

// まず、最初の式が 'true' と評価されます。この 'true' は
// (bool)true と評価されるので、それをもとに二番目の三項
// 演算子が評価されます。
?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
   </sect2>

  </sect1>
 
  <sect1 id="language.operators.errorcontrol">
   <title>エラー制御演算子</title>
   <simpara>
    PHP はエラー制御演算子(@)をサポートしています。PHP の式の前に付けた場合、
    その式により生成されたエラーメッセージは無視されます。
   </simpara>
   <simpara>
    <link linkend="ini.track-errors"><option>track_errors</option></link> 機能が
    有効な場合、式により生成されたエラーメッセージはグローバル変数
    <link linkend="reserved.variables.phperrormsg">$php_errormsg</link>
    に保存されます。この変数はエラーが発生するたびに上書きされます。
    そのため、この変数を使用したい場合には速やかに確認する必要があります。
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* 意図的なエラー */
$my_file = @file ('non_existent_file') or
    die ("Failed opening file: error was '$php_errormsg'");

// この演算子は関数だけでなく、全ての式で動作します。
$value = @$cache[$key]; 
// インデックス $key が存在しない場合でも、警告を発生しません。

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <simpara>
     @演算子は、<link linkend="language.expressions">式</link>
     でのみ動作します。基本的なルールは次のようになります。
     値を得ることができるものの場合、@ 演算子を前に付けることが可能です。
     例えば、変数、関数、<function>include</function>コール、定数等の
     前にこの演算子をつけることが可能です。関数またはクラスの定義や
     <literal>if</literal>や<literal>foreach</literal> 等のような
     条件構造の前にこの演算子を付けることはできません。
    </simpara>
   </note>
   <simpara>
    <function>error_reporting</function> と、
    <link linkend="ref.errorfunc">エラー処理とログ出力関数</link>
    も参照してください。
   </simpara>
   <warning>
    <para>
     現在、誤差制御演算子プレフィックス"@"は、スクリプトの実行を
     終了するような致命的なエラーの出力さえ抑圧します。このため、ある関数の
     エラー出力を抑制するために "@" を使用した場合、その関数が
     利用できなかったり、ミスタイプがあった場合でも、原因を示すことなく
     その場所でスクリプトは終了してしまいます。
    </para>
   </warning>
  </sect1>
  
  <sect1 id="language.operators.execution">
   <title>実行演算子</title>
   <para>
    PHP は 1 種類の実行演算子、バッククォート (``) をサポートします。
    シングルクォートではないことに注意してください! PHP は、バッククォートの
    中身をシェルコマンドとして実行しようとします。出力が返されます
    (すなわち、出力を単にダンプするのではなく、変数に代入することが
    できます) 。
    バッククォート演算子の使用は <function>shell_exec</function> と等価です。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$output = `ls -al`;
echo "<pre>$output</pre>";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     バッククオート演算子は、&safemode; が有効な場合
     もしくは <function>shell_exec</function> が無効な場合は無効となります。
    </para>
   </note>
   <para>
    <function>escapeshellcmd</function>, <function>exec</function>,
    <function>passthru</function>, <function>popen</function>,
    <function>shell_exec</function>, <function>system</function>
    <link linkend="features.commandline">PHPをコマンドラインから使用する</link>
    も参照してください。
   </para>
  </sect1>
   
  <sect1 id="language.operators.increment">
   <title>加算子/減算子</title>
   <para>
    PHP は C 言語形式の加算子/減算子（前置・後置ともに）をサポートします。
   </para>
   <note>
    <simpara>
     加算子/減算子は bool 型の値には何も変更を加えません。
     同じく &null; に減算子を適用しても何も起こりませんが、&null; に加算子を
     適用すると <literal>1</literal> となります。
    </simpara>
   </note>
   <table>
    <title>加算子/減算子</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例</entry>
       <entry>名前</entry>
       <entry>効果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>++$a</entry>
       <entry>前置加算子</entry>
       <entry>$a に 1 を加え、$a を返します。</entry>
      </row>
      <row>
       <entry>$a++</entry>
       <entry>後置加算子</entry>
       <entry>$a を返し、$a に1を加えます。</entry>
      </row>
      <row>
       <entry>--$a</entry>
       <entry>前置減算子</entry>
       <entry>$a から 1 を引き、$a を返します。</entry>
      </row>
      <row>
       <entry>$a--</entry>
       <entry>後置減算子</entry>
       <entry>$aを返し、$a から 1 を引きます。</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    以下に簡単なスクリプトの例を示します。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo "<h3>後置加算</h3>";
$a = 5;
echo "5 となります: " . $a++ . "<br>\n";
echo "6 となります: " . $a . "<br>\n";
 
echo "<h3>前置加算</h3>";
$a = 5;
echo "6 となります: " . ++$a . "<br>\n";
echo "6 となります: " . $a . "<br>\n";

echo "<h3>後置減算</h3>";
$a = 5;
echo "5 となります: " . $a-- . "<br>\n";
echo "4 となります: " . $a . "<br>\n";

echo "<h3>前置減算</h3>";
$a = 5;
echo "4 となります: " . --$a . "<br>\n";
echo "4 となります: " . $a . "<br>\n";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    PHP は、算術演算子で文字変数を扱った場合に C ではなく Perl の慣習に
    従います。例えば、perl では 'Z'+1 は 'AA' を返しますが C では 'Z'+1 は
    '[' ( ord('Z') == 90, ord('[') == 91 ) を返します。
    文字変数はインクリメントされることは可能ですがデクリメントは不可能であるということ、
    またプレーンな ASCII 文字 (a-z および A-Z) のみがサポートされるということに注意しましょう。
    <example>
     <title>文字変数に対する算術演算子の使用</title>
     <programlisting role="php">
<![CDATA[
<?php
$i = 'W';
for ($n=0; $n<6; $n++) {
    echo ++$i . "\n";
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
X
Y
Z
AA
AB
AC
]]>
     </screen>
    </example>
   </para>
   <para>
    論理型に対する加算/減算は何の影響も及ぼしません。
   </para>
  </sect1>
 
  <sect1 id="language.operators.logical">
   <title>論理演算子</title>
 
   <table>
    <title>論理演算子</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例</entry>
       <entry>名前</entry>
       <entry>結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a and $b</entry>
       <entry>論理積</entry>
       <entry>$a および $b が共に &true; の場合に &true;</entry>
      </row>
      <row>
       <entry>$a or $b</entry>
       <entry>論理和</entry>
       <entry>$a または $b のどちらかが &true; の場合に &true;</entry>
      </row>
      <row>
       <entry>$a xor $b</entry>
       <entry>排他的論理和</entry>
       <entry>
    $a または $b のどちらかが &true; でかつ両方とも &true; でない場合に &true;
       </entry>
      </row>
      <row>
       <entry>! $a</entry>
       <entry>否定</entry>
       <entry>$a が &true; でない場合 &true;</entry>
      </row>
      <row>
       <entry>$a &amp;&amp; $b</entry>
       <entry>論理積</entry>
       <entry>$a および $b が共に &true; の場合に &true;</entry>
      </row>
      <row>
       <entry>$a || $b</entry>
       <entry>論理和</entry>
       <entry>$a または $b のどちらかが &true; の場合に &true;</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    "and" および "or" 演算子が 2 種類あるのは、演算が行われる際の優先順位が
    異なっているためです
    (<link linkend="language.operators.precedence">演算子の優先順位</link>
    を参照ください)。
   </simpara>
  </sect1>

  <sect1 id="language.operators.string">
   <title>文字列演算子</title>
   <simpara>
    文字列の演算子は 2 種類あります。最初のは結合演算子('.')で、右引数と
    左引数を結合したものを返します。2 番目は、結合代入演算子('.=')で、
    この演算子は右側の引数に左側の引数を追加します。詳細は、<link
    linkend="language.operators.assignment">代入演算子</link> を
    参照ください。
   </simpara>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = "Hello ";
$b = $a . "World!"; // $b は、"Hello World!" となります。

$a = "Hello ";
$a .= "World!"; // $a は、"Hello World!" となります。
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    <link linkend="language.types.string">文字列</link> と 
    <link linkend="ref.strings">文字列 関数</link>も参照してください。
   </para>
  </sect1>
  
  <sect1 id="language.operators.array">
   <title>配列演算子</title>
   <table>
    <title>Array Operators</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例</entry>
       <entry>名前</entry>
       <entry>結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a + $b</entry>
       <entry>結合</entry>
       <entry>$a および $b を結合する。</entry>
      </row>
      <row>
       <entry>$a == $b</entry>
       <entry>同等</entry>
       <entry>$a および $b のキー/値のペアが等しい場合に &true;。</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>同一</entry>
       <entry>
        $a および $b のキー/値のペアが等しく、その並び順が等しく、
        かつデータ型も等しい場合に &true;。
       </entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>等しくない</entry>
       <entry>$a が $b と等しくない場合に &true;。</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>等しくない</entry>
       <entry>$a が $b と等しくない場合に &true;。</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>同一でない</entry>
       <entry>$a が $b と同一でない場合に &true;。</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    <literal>+</literal> 演算子は左側の配列に右側の配列の内容を
    追加します。重複しているキーは上書き「されません」。
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("a" => "apple", "b" => "banana");
$b = array("a" => "pear", "b" => "strawberry", "c" => "cherry");

$c = $a + $b; // Union of $a and $b
echo "Union of \$a and \$b: \n";
var_dump($c);

$c = $b + $a; // Union of $b and $a
echo "Union of \$b and \$a: \n";
var_dump($c);
?>
]]>
     </programlisting>
    </informalexample>
    このスクリプトを実行すると、以下のように出力されます。
    <screen role="php">
<![CDATA[
Union of $a and $b:
array(3) {
  ["a"]=>
  string(5) "apple"
  ["b"]=>
  string(6) "banana"
  ["c"]=>
  string(6) "cherry"
}
Union of $b and $a:
array(3) {
  ["a"]=>
  string(4) "pear"
  ["b"]=>
  string(10) "strawberry"
  ["c"]=>
  string(6) "cherry"
}
]]>
    </screen>
   </para>
   <para>
    同じキーと値を保持している場合に、配列が等しいとみなされます。
   </para>
   <para>
    <example>
     <title>配列の比較</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("apple", "banana");
$b = array(1 => "banana", "0" => "apple");

var_dump($a == $b); // bool(true)
var_dump($a === $b); // bool(false)
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <link linkend="language.types.array">配列</link>と 
    <link linkend="ref.array">配列関数</link>も参照してください。
   </para>
  </sect1>

  <sect1 id="language.operators.type">
   <title>型演算子</title>
   <para>
    <literal>instanceof</literal> を使用して、
    ある PHP 変数が特定の
    <link linkend="language.oop5.basic.class">クラス</link>
    のオブジェクトのインスタンスであるかどうかを調べます。
    <example>
     <title>クラスでの instanceof の使用法</title>
     <programlisting role="php">
     <![CDATA[
<?php
class MyClass
{
}
class NotMyClass
{
}
$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof NotMyClass);
?>
     ]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
bool(false)
]]>
     </screen>
    </example>
    <literal>instanceof</literal> は、ある変数が
    特定の親クラスを継承したクラスのオブジェクトのインスタンスであるかどうかを調べることもできます。
    <example>
     <title>継承したクラスでの instanceof の使用法</title>
     <programlisting role="php">
     <![CDATA[
<?php
class ParentClass
{
}
class MyClass extends ParentClass
{
}
$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof ParentClass);
?>
     ]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
    最後に、<literal>instanceof</literal>
    は、ある変数が特定の
    <link linkend="language.oop5.interfaces">インターフェイス</link>
    を実装したクラスのオブジェクトのインスタンスであるかどうかも調べることができます。
    <example>
     <title>クラスでの instanceof の使用法</title>
     <programlisting role="php">
     <![CDATA[
<?php
interface MyInterface
{
}
class MyClass implements MyInterface
{
}
$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof MyInterface);
?>
     ]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    通常、<literal>instanceof</literal> ではリテラルのクラス名を使用しますが、
    別のオブジェクトや文字列変数を使用することもできます。
    <example>
     <title>変数を用いた instanceof の使用法</title>
     <programlisting role="php">
     <![CDATA[
<?php
interface MyInterface
{
}
class MyClass implements MyInterface
{
}
$a = new MyClass;
$b = new MyClass;
$c = 'MyClass';
$d = 'NotMyClass';
var_dump($a instanceof $b); // $b MyClass クラスのオブジェクトです
var_dump($a instanceof $c); // $c は文字列 'MyClass' です
var_dump($a instanceof $d); // $d は文字列 'NotMyClass' です
?>
     ]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    注意すべき落とし穴があります。PHP 5.1.0 より前のバージョンでは、
    <literal>instanceof</literal> は、クラス名が存在しない場合に
    <link linkend="language.oop5.autoload">__autoload()</link> をコールしていました。
    さらに、クラスが読み込めなかった場合に致命的なエラーが発生していました。
    この問題の回避策としては、<literal>動的なクラス参照</literal>
    を使用するか、クラス名を含む文字列変数を使用します。
    <example>
     <title>PHP 5.0 における、クラス名検索時の致命的エラーの回避策</title>
     <programlisting role="php">
     <![CDATA[
<?php
$d = 'NotMyClass';
var_dump($a instanceof $d); // これで、致命的なエラーは発生しません
?>
     ]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(false)
]]>
     </screen>
    </example>
   </para>
   <simpara>
    <literal>instanceof</literal> 演算子は PHP 5 から使用可能になりました。
    それ以前には <function>is_a</function> が使用されていましたが、
    現在は <function>is_a</function> は推奨されておらず、
    <literal>instanceof</literal> の使用が推奨されています。
   </simpara>
   <para>
    <function>get_class</function> および
    <function>is_a</function> も参照ください。
   </para>
  </sect1>
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
