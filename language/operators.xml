<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.27 $ -->
<!-- EN-Revision: 1.96 Maintainer: hirokawa Status: working -->
<!-- CREDITS: takagi -->
 <chapter id="language.operators">
  <title>演算子</title>
  <simpara>
   An operator is something that you feed with one or more values (or
   expressions, in programming jargon) which yields another value (so that the
   construction itself becomes an expression). So you can think of functions
   or constructions that return a value (like print) as operators and those
   that return nothing (like echo) as any other thing.
  </simpara>
  <para>
   There are three types of operators.  Firstly there is the unary operator which
   operates on only one value, for example ! (the negation operator) or ++
   (the increment operator). The second group are termed binary operators; this
   group contains most of the operators that PHP supports, and a list follows
   below in the section <link linkend="language.operators.precedence">Operator
   Precedence</link>.
  </para>
  <para>
   The third group is the ternary operator: ?:.  It should be used to select
   between two expressions depending on a third one, rather than to select two
   sentences or paths of execution. Surrounding ternary expressions with
   parentheses is a very good idea.
  </para>

  <sect1 id="language.operators.precedence">
   <title>演算子の優先順位</title>
   <para>
    演算子の優先順位は、二つの式が"緊密に"結合している度合いを指定します。
    例えば、式 <literal>1 + 5 * 3</literal> の答えは
    <literal>16</literal>になり、<literal>18</literal>とはなりません。
    これは乗算演算子("*")は、加算演算子("+")より高い優先順位を有するか
    らです。必要に応じて強制的に優先順位を設定するために括弧を使用する
    ことが可能です。例えば、<literal>18</literal>と評価するためには、
    <literal>(1 + 5) * 3</literal> とします。
    If operator precedence is equal, left to right 
    associativity is used.
   </para>
   <para>
    The following table lists the precedence of operators with the
    highest-precedence operators listed at the top of the table. Operators
    on the same line have equal precedence, in which case their
    associativity decides which order to evaluate them in.
    <table>
     <title>演算子の優先順位</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>結合時の評価</entry>
        <entry>演算子</entry>
        <entry>追加情報</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>結合しない</entry>
        <entry>new</entry>
        <entry><link linkend="language.oop5.basic.new">new</link></entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>[</entry>
        <entry><function>array</function></entry>
       </row>
       <row>
        <entry>結合しない</entry>
        <entry>++ --</entry>
        <entry>
         <link linkend="language.operators.increment">加算子/減算子</link>
        </entry>
       </row>
       <row>
        <entry>結合しない</entry>
        <entry>! ~ - (int) (float) (string) (array) (object) @</entry>
        <entry>
         <link linkend="language.types">型</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>* / %</entry>
        <entry>
         <link linkend="language.operators.arithmetic">代数演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>+ - .</entry>
        <entry>
         <link linkend="language.operators.arithmetic">代数演算子</link>&listendand; 
         <link linkend="language.operators.string">文字列演算子</link></entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>&lt;&lt; &gt;&gt;</entry>
        <entry>
         <link linkend="language.operators.bitwise">ビット演算子</link>
        </entry>
       </row>
       <row>
        <entry>結合しない</entry>
        <entry>&lt; &lt;= &gt; &gt;=</entry>
        <entry>
         <link linkend="language.operators.comparison">比較演算子</link>
        </entry>
       </row>
       <row>
        <entry>結合しない</entry>
        <entry>== != === !==</entry>
        <entry>
         <link linkend="language.operators.comparison">比較演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>&amp;</entry>
        <entry>
         <link linkend="language.operators.bitwise">ビット演算子</link>&listendand; 
         <link linkend="language.references">リファレンス</link></entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>^</entry>
        <entry>
         <link linkend="language.operators.bitwise">ビット演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>|</entry>
        <entry>
         <link linkend="language.operators.bitwise">ビット演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>&amp;&amp;</entry>
        <entry>
         <link linkend="language.operators.logical">論理演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>||</entry>
        <entry>
         <link linkend="language.operators.logical">論理演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>? :</entry>
        <entry>
         <link linkend="language.operators.comparison.ternary">三項演算子</link>
        </entry>
       </row>
       <row>
        <entry>right</entry>
        <entry>
         = += -= *= /= .= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;=
        </entry>
        <entry>
         <link linkend="language.operators.assignment">代入演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>and</entry>
        <entry>
         <link linkend="language.operators.logical">論理演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>xor</entry>
        <entry>
         <link linkend="language.operators.logical">論理演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>or</entry>
        <entry>
         <link linkend="language.operators.logical">論理演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>,</entry>
        <entry>さまざまな利用法</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <para>
    Left associativity means that the expression is evaluated from left to right,
    right associativity means the opposite.
    <example>
     <title>Associativity</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 3 * 3 % 5; // (3 * 3) % 5 = 4
$a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2

$a = 1;
$b = 2;
$a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5
?>
]]>
     </programlisting>
    </example>
    Use parentheses to increase readability of the code.
   </para>
   <note>
    <para>
     <literal>!</literal>は<literal>=</literal>よりも優先されるはずなの
     にもかかわらず、PHPは依然として<literal>if (!$a = foo())</literal>
     のような式も許します。この場合は<literal>foo()</literal>の出力が
     <varname>$a</varname>に代入されます。
    </para>
   </note>
  </sect1>
  
  <sect1 id="language.operators.arithmetic">
   <title>代数演算子</title>
   <simpara>
    学校で習った基礎代数を憶えていますか？
    この演算子はそれらと同様に動作します。
   </simpara>
   <table>
    <title>代数演算子</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例</entry>
       <entry>名前</entry>
       <entry>結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>-$a</entry>
       <entry>負にする</entry>
       <entry>$aの逆</entry>
      </row>
      <row>
       <entry>$a + $b</entry>
       <entry>加算</entry>
       <entry>$a および $b の合計</entry>
      </row>
      <row>
       <entry>$a - $b</entry>
       <entry>減算</entry>
       <entry>$aと$bの差</entry>
      </row>
      <row>
       <entry>$a * $b</entry>
       <entry>乗算</entry>
        <entry>$aおよび$bの積</entry>
      </row>
      <row>
       <entry>$a / $b</entry>
       <entry>割算</entry>
        <entry>$aおよび$bの商</entry>
      </row>
      <row>
       <entry>$a % $b</entry>
       <entry>剰余</entry>
       <entry>$aを$bで割った余り</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  
   <simpara>
    2つのオペランドが整数の場合(または整数に変換された文字列の場合)で
    あっても、割算演算子 ("/") は常にfloat値を返します。
   </simpara>
   <note>
    <simpara>
     Remainder <literal>$a % $b</literal> is negative for negative
     <literal>$a</literal>.
    </simpara>
   </note>
   <simpara>
    マニュアルの
    <link linkend="ref.math">数学関数</link>の項も参照してください。
   </simpara>

   <!--
   <simpara>
    The division operator ("/") returns an integer value (the result
    of an integer division) if the two operands are integers (or
    strings that get converted to integers) and the quotient is an
    integer. If either operand is a floating-point value, or the
    operation results in a non-integer value, a floating-point value
    is returned.
   </simpara>
   -->
  </sect1>

  <sect1 id="language.operators.assignment">
   <title>代入演算子</title>
   <simpara>
    代入演算子の基本となるものは "=" です。この演算子に関して最初に思
    い付く意味は"等しい"であるかもしれません。しかし、そうではありませ
    ん。本当は、左オペランドに右オペランドの式の値を設定する("得て代入
    する")ことを意味します。
   </simpara>
   <para>
    代入式の値は、代入される値です。つまり、"$a = 3" の値は、3です。
    これにより、以下のようなトリッキーなことができるようになります。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = ($b = 4) + 5; // $a は 9 に等しく、$b は 4 にセットされます。

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    基本代入演算子に加えて、式の中の値を使用し、その値をその式の結果とする
    ことができる全ての<link linkend="language.operators">
     バイナリ演算子</link>および文字列演算子に関して「複合演算子」があります。例えば、
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = 3;
$a += 5; // $a を 8 にセットします。$a = $a + 5; と同じです。
$b = "Hello ";
$b .= "There!"; // $bを"Hello There!"にセットします。$b = $b . "There!";と同じです。

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    代入は、元の変数を新しい変数にコピーする(値による代入)ため、
    片方の変数に対する変更はもう片方に影響を与えないということに注意し
    てください。この動作により、密なループの内側で大きな配列のようなもの
    をコピーする必要がある場合には問題を生じる可能性があります。
    PHP 4 以降では、<computeroutput>$var = &amp;$othervar;</computeroutput>
    構文により参照による代入をサポートしていますが、PHP 3 ではサポート
    しません。'参照による代入'は、両方の変数が同じデータを指し、コピー
    を行わないことを意味します。参照に関する詳細については、
    <link linkend="language.references">リファレンスの説明</link>も
    参照ください。
   </para>
   </sect1>

  <sect1 id="language.operators.bitwise">
   <title>ビット演算子</title>
   <simpara>
    ビット演算子は、整数における特定のビットをオンまたはオフにすることを
    可能にします。もし左辺値と右辺値共に文字列であった場合にはビット演算子は
    文字のASCII値に対して作用します。
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo 12 ^ 9; // '5'を出力します

echo "12" ^ "9"; // バックスペース文字を出力します(ascii 8)
                 // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8

echo "hallo" ^ "hello"; // ascii値の #0 #4 #0 #0 #0 を出力します
                        // 'a' ^ 'e' = #4
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <table>
    <title>ビット演算子</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例</entry>
       <entry>名前</entry>
       <entry>結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a &amp; $b</entry>
       <entry>ビット積</entry>
       <entry>
    $aおよび$bの両方にセットされているビット
       </entry>
      </row>
      <row>
       <entry>$a | $b</entry>
        <entry>ビット和</entry>
       <entry>
    $aまたは$bのどちらかにセットされているビット
       </entry>
      </row>
      <row>
       <entry>$a ^ $b</entry>
       <entry>排他的論理和</entry>
       <entry>
    $aまたは$bにセットされており、両方にセットされていないビット
       </entry>
      </row>
      <row>
       <entry>~ $a</entry>
       <entry>否定</entry>
       <entry>
    $aにセットされているビットはセットせず、そうでないものは逆にする
       </entry>
      </row>
      <row>
       <entry>$a &lt;&lt; $b</entry>
       <entry>左シフト</entry>
       <entry>
    $a のビットを左に $b ビットシフトする(各シフトは "2をかける"こ
    とを意味します)
       </entry>
      </row>
      <row>
       <entry>$a &gt;&gt; $b</entry>
       <entry>右シフト</entry>
       <entry>
    $a のビットを右に $b ビットシフトします (各シフトは "2で割る"
    ことを意味します)
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <warning>
    <para>
     Don't right shift for more than 32 bits on 32 bits systems. Don't left shift
     in case it results to number longer than 32 bits.
    </para>
   </warning>
  </sect1>
  
  <sect1 id="language.operators.comparison">
   <title>比較演算子</title>
   <simpara>
    比較演算子は、その名前が示すように、二つの値を比較します。
   </simpara>
   <table>
    <title>比較演算子</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例</entry>
       <entry>名前</entry>
       <entry>結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a == $b</entry>
       <entry>等しい</entry>
       <entry>$a が $b に等しい時に&true;。</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>等しい</entry>
       <entry>$a が $b に等しく同じ型でである場合に &true;。(PHP 4で導入)
       </entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>等しくない</entry>
       <entry>$a が $b に等しくない場合に&true;。</entry>
      </row>
      <row>
       <entry>$a &lt;> $b</entry>
       <entry>等しくない</entry>
       <entry>$aが$bに等しくない場合に&true;</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>等しくない</entry>
       <entry>
        $a が $b と等しくないか、同じ型でない場合に &true;。(PHP 4で導入)
       </entry>
      </row>
      <row>
       <entry>$a &lt; $b</entry>
       <entry>より少ない</entry>
       <entry>$a が $b より少ない時に&true;。</entry>
      </row>
      <row>
       <entry>$a &gt; $b</entry>
       <entry>より多い</entry>
       <entry>$a が $b より多い時に&true;。</entry>
      </row>
      <row>
       <entry>$a &lt;= $b</entry>
       <entry>より少ないか等しい</entry>
       <entry>$a が $b より少ないか等しい時に&true;。</entry>
      </row>
      <row>
       <entry>$a &gt;= $b</entry>
       <entry>より多いか等しい</entry>
       <entry>$a が $b より多いか等しい時に&true;。</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    If you compare an integer with a string, the string is
    <link linkend="language.types.string.conversion">converted to a number</link>.
    If you compare two numerical strings, they are compared as integers. These
    rules also apply to the
    <link linkend="control-structures.switch">switch</link> statement.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
var_dump(0 == "a"); // 0 == 0 -> true
var_dump("1" == "01"); // 1 == 1 -> true

switch ("a") {
case 0:
    echo "0";
    break;
case "a": // never reached because "a" is already matched with 0
    echo "a";
    break;
}
?>
]]>
     </programlisting>
    </informalexample> 
   </para>

   <para>
    多くの型では、以下の表に（上から順に）したがって比較が行われます。
   </para>
   <table>
    <title>さまざまな型の比較</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>第 1 オペランドの型</entry>
       <entry>第 2 オペランドの型</entry>
       <entry>結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>null</type> または <type>string</type></entry>
       <entry><type>string</type></entry>
       <entry>&null; を "" に変換し、数値または文字として比較します</entry>
      </row>
      <row>
       <entry><type>bool</type> または <type>null</type></entry>
       <entry>あらゆる型</entry>
       <entry><type>bool</type> に変換し、&false; &lt; &true; と判断します</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry><type>object</type></entry>
       <entry>組み込みクラスには独自の比較基準が定義されています。それ以外の
        クラスは比較できません。同じクラスであるかどうかは - プロパティが
        同じ値であるかどうかを配列形式で比較（PHP 4）、PHP 5 では <link
        linkend="language.oop5.object-comparison">ここで説明されています</link>。
       </entry>
      </row>
      <row>
       <entry><type>string</type>, <type>resource</type> または <type>number</type></entry>
       <entry><type>string</type>, <type>resource</type> または <type>number</type></entry>
       <entry>文字列やリソースを数値に変換し、算術演算を行います</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry><type>array</type></entry>
       <entry>要素数の少ない配列のほうが小さくなります。オペランド 1 のキーが
        オペランド 2 に存在しない場合、配列は比較できません。そうでない場合は
        個々の要素の値を比較します（以下の例を参照ください）</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry>あらゆる型</entry>
       <entry><type>array</type> のほうが常に大きくなります</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry>あらゆる型</entry>
       <entry><type>object</type> のほうが常に大きくなります</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    <example>
     <title>一般的な配列の比較</title>
     <programlisting role="php">
<![CDATA[
<?php
// 標準の比較演算子を用いて、配列はこのように比較されます
function standard_array_compare($op1, $op2)
{
    if (count($op1) < count($op2)) {
        return -1; // $op1 < $op2
    } elseif (count($op1) > count($op2)) {
        return 1; // $op1 > $op2
    }
    foreach ($op1 as $key => $val) {
        if (!array_key_exists($key, $op2)) {
            return null; // uncomparable
        } elseif ($val < $op2[$key]) {
            return -1;
        } elseif ($val > $op2[$key]) {
            return 1;
        }
    }
    return 0; // $op1 == $op2
}
?>
]]>
     </programlisting>
    </example> 
   </para>

   <para>
    <function>strcasecmp</function>,
    <function>strcmp</function>、
    <link linkend="language.operators.array">配列演算子</link>,
    マニュアルの
    <link linkend="language.types">型</link> のセクションも参照してください。
   </para>

   <sect2 id="language.operators.comparison.ternary">
    <title>三項演算子</title>
    <para>
     もうひとつの条件演算子として "?:"（あるいは三項）演算子があります。
     <example>
      <title>デフォルト値を設定する</title>
      <programlisting role="php">
 <![CDATA[
 <?php
 // 三項演算子の使用例
 $action = (empty($_POST['action'])) ? 'default' : $_POST['action'];

 // 上記は以下のif/else式と同じです。
 if (empty($_POST['action'])) {
     $action = 'default';
 } else {
     $action = $_POST['action'];
 }

 ?>
 ]]>
      </programlisting>
     </example> 
     <literal>(expr1) ? (expr2) : (expr3)</literal>
     という式は、<replaceable>式1</replaceable> が &true; の場合に
     <replaceable>式2</replaceable> を、
     <replaceable>式1</replaceable> が &false; の場合に
     <replaceable>式3</replaceable> を値とします。
    </para>
    <note>
     <simpara>
      三項演算子は式であり、値としては評価されずに式の結果として評価される
      ことに注意してください。演算結果をリファレンスとして返したい場合に、
      これを知っておくことが大切です。結果をリファレンスとして返す関数で
      <literal>return $var == 42 ? $a : $b;</literal> とすることはできず、
      新しいバージョンの PHP では警告を発生します。
     </simpara>
    </note>
   </sect2>

  </sect1>
 
  <sect1 id="language.operators.errorcontrol">
   <title>エラー制御演算子</title>
   <simpara>
    PHPは、エラー制御演算子(@)をサポートしています。PHPの式の前に付け
    た場合、その式により生成されたエラーメッセージは無視されます。
   </simpara>
   <simpara>
    <link linkend="ini.track-errors"><option>track_errors</option></link>機能が有効の場
    合、式により生成されたエラーメッセージはグローバル変数
    <link linkend="reserved.variables.phperrormsg">$php_errormsg</link>
    に保存されます。この変数は、誤差発生の度に上書きされ、
    このため、この変数を使用したい場合には速やかに確認する必要がありま
    す。
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* 意図的なエラー */
$my_file = @file ('non_existent_file') or
    die ("Failed opening file: error was '$php_errormsg'");

// この演算子は関数だけでなく、全ての式で動作します。
$value = @$cache[$key]; 
// インデックス $key が存在しない場合でも、警告を発生しません。

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <simpara>
     @演算子は、<link linkend="language.expressions">式</link>
     でのみ動作します。基本的なルールは次のようになります。
     値を得ることができるものの場合、@演算子を前に付けることが可能です。
     例えば、変数、関数、<function>include</function>コール、定数等の
     前にこの演算子をつけることが可能です。関数またはクラスの定義や
     <literal>if</literal>や<literal>foreach</literal>等のような条件構
     造の前にこの演算子を付けることはできません。
    </simpara>
   </note>
   <simpara>
    <function>error_reporting</function>と、
    <link linkend="ref.errorfunc">エラー処理とログ出力関数</link>
    も参照してください。
   </simpara>
   <warning>
    <para>
     現在、誤差制御演算子プレフィックス"@"は、スクリプトの実行を終了す
     るような致命的なエラーの出力さえ抑圧します。このため、ある関数の
     エラー出力を抑制するために "@" を使用した場合、その関数が利用でき
     なかったり、ミスタイプがあった場合でも、原因を示すことなくその場
     所でスクリプトは終了してしまいます。
    </para>
   </warning>
  </sect1>
  
  <sect1 id="language.operators.execution">
   <title>実行演算子</title>
   <para>
    PHP は1種類の実行演算子、バッククォート (``) をサポートします。シ
    ングルクォートではないことに注意してください!PHP は、後方引用符の
    中身をシェルコマンドとして実行しようとします。出力が返されます。
    (すなわち、出力を単にダンプするのではなく、変数に代入することがで
    きます。) 
    バッククォート演算子の使用は<function>shell_exec</function>と等価です。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$output = `ls -al`;
echo "<pre>$output</pre>";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     バッククオート演算子は、&safemode; が有効な場合
     もしくは<function>shell_exec</function>が無効な場合は無効となります。
    </para>
   </note>
   <para>
    <function>escapeshellcmd</function>, <function>exec</function>,
    <function>passthru</function>, <function>popen</function>,
    <function>shell_exec</function>, <function>system</function>
    <link linkend="features.commandline">PHPをコマンドラインから使用する</link>
    も参照してください。
   </para>
  </sect1>
   
  <sect1 id="language.operators.increment">
   <title>加算子/減算子</title>
   <para>
    PHP は C 言語形式の加算子/減算子（前置・後置ともに）をサポートします。
   </para>
   <note>
    <simpara>
     加算子/減算子は bool 型の値には何も変更を加えません。
     同じく &null; に減算子を適用しても何も起こりませんが、&null; に加算子を
     適用すると <literal>1</literal> となります。
    </simpara>
   </note>
   <table>
    <title>加算子/減算子</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例</entry>
       <entry>名前</entry>
       <entry>効果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>++$a</entry>
       <entry>前置加算子</entry>
       <entry>$a に1を加え、$a を返します。</entry>
      </row>
      <row>
       <entry>$a++</entry>
       <entry>後置加算子</entry>
       <entry>$a を返し、$a に1を加えます。</entry>
      </row>
      <row>
       <entry>--$a</entry>
       <entry>前置減算子</entry>
       <entry>$a から1を引き、$a を返します。</entry>
      </row>
      <row>
       <entry>$a--</entry>
       <entry>後置減算子</entry>
       <entry>$aを返し、$a から1を引きます。</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    以下に簡単なスクリプトの例を示します。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo "<h3>後置加算</h3>";
$a = 5;
echo "5となります: " . $a++ . "<br>\n";
echo "6となります: " . $a . "<br>\n";
 
echo "<h3>前置加算</h3>";
$a = 5;
echo "6となります: " . ++$a . "<br>\n";
echo "6となります: " . $a . "<br>\n";

echo "<h3>後置減算</h3>";
$a = 5;
echo "5となります: " . $a-- . "<br>\n";
echo "4となります: " . $a . "<br>\n";

echo "<h3>前置減算</h3>";
$a = 5;
echo "4となります: " . --$a . "<br>\n";
echo "4となります: " . $a . "<br>\n";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    PHPは算術演算子で文字変数を扱った場合にCではなくperlの慣習に
    従います。例えば、perlでは 'Z'+1 は 'AA' を返しますが Cでは 'Z'+1 は
    '[' ( ord('Z') == 90, ord('[') == 91 ) を返します。
    文字変数はインクリメントされることは可能ですがデクリメントは不可能である
    ことに注意してください。
    <example>
     <title>文字変数に対する算術演算子の使用</title>
     <programlisting role="php">
<![CDATA[
<?php
$i = 'W';
for ($n=0; $n<6; $n++) {
    echo ++$i . "\n";
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
X
Y
Z
AA
AB
AC
]]>
     </screen>
    </example>
   </para>
   <para>
    Incrementing or decrementing booleans has no effect.
   </para>
  </sect1>
 
  <sect1 id="language.operators.logical">
   <title>論理演算子</title>
 
   <table>
    <title>論理演算子</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例</entry>
       <entry>名前</entry>
       <entry>結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a and $b</entry>
       <entry>論理積</entry>
       <entry>$a および $b が共に &true; の場合に &true;</entry>
      </row>
      <row>
       <entry>$a or $b</entry>
       <entry>論理和</entry>
       <entry>$a または $b のどちらかが &true; の場合に &true;</entry>
      </row>
      <row>
       <entry>$a xor $b</entry>
       <entry>排他的論理和</entry>
       <entry>
    $aまたは$bのどちらかが&true;でかつ両方とも&true;でない場合に&true;
       </entry>
      </row>
      <row>
       <entry>! $a</entry>
       <entry>否定</entry>
       <entry>$a が &true; でない場合 &true;</entry>
      </row>
      <row>
       <entry>$a &amp;&amp; $b</entry>
       <entry>論理積</entry>
       <entry>$a および $b が共に &true; の場合に &true;</entry>
      </row>
      <row>
       <entry>$a || $b</entry>
       <entry>論理和</entry>
       <entry>$a または $b のどちらかが &true; の場合に &true;</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    "and" および "or" 演算子が2種類あるのは、演算が行われる際の優先順
    位が異なっているためです。
    (<link linkend="language.operators.precedence">演算子の優先順位</link>
    を参照ください。)
   </simpara>
  </sect1>

  <sect1 id="language.operators.string">
   <title>文字列演算子</title>
   <simpara>
    文字列の演算子は2種類あります。最初のは結合演算子('.')で、右引数と
    左引数を結合したものを返します。2番目は、結合代入演算子('.=')で、
    この演算子は右側の引数に左側の引数を追加します。詳細は、<link
    linkend="language.operators.assignment">代入演算子</link> を参照下
    さい。
   </simpara>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = "Hello ";
$b = $a . "World!"; // $b は、"Hello World!" となります。

$a = "Hello ";
$a .= "World!"; // $a は、"Hello World!" となります。
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    <link linkend="language.types.string">文字列</link> と 
    <link linkend="ref.strings">文字列 関数</link>も参照してください。
   </para>
  </sect1>
  
  <sect1 id="language.operators.array">
   <title>配列演算子</title>
   <table>
    <title>Array Operators</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例</entry>
       <entry>名前</entry>
       <entry>結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a + $b</entry>
       <entry>Union</entry>
       <entry>Union of $a and $b.</entry>
      </row>
      <row>
       <entry>$a == $b</entry>
       <entry>Equality</entry>
       <entry>&true; if $a and $b have the same key/value pairs.</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Identity</entry>
       <entry>&true; if $a and $b have the same key/value pairs in the same
        order and of the same types.</entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>Inequality</entry>
       <entry>&true; if $a is not equal to $b.</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>Inequality</entry>
       <entry>&true; if $a is not equal to $b.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>Non-identity</entry>
       <entry>&true; if $a is not identical to $b.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    The <literal>+</literal> operator
    appends the right handed array to the left handed, whereas 
    duplicated keys are NOT overwritten.
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("a" => "apple", "b" => "banana");
$b = array("a" => "pear", "b" => "strawberry", "c" => "cherry");

$c = $a + $b; // Union of $a and $b
echo "Union of \$a and \$b: \n";
var_dump($c);

$c = $b + $a; // Union of $b and $a
echo "Union of \$b and \$a: \n";
var_dump($c);
?>
]]>
     </programlisting>
    </informalexample>
    When executed, this script will print the following:
    <screen role="php">
<![CDATA[
Union of $a and $b:
array(3) {
  ["a"]=>
  string(5) "apple"
  ["b"]=>
  string(6) "banana"
  ["c"]=>
  string(6) "cherry"
}
Union of $b and $a:
array(3) {
  ["a"]=>
  string(4) "pear"
  ["b"]=>
  string(10) "strawberry"
  ["c"]=>
  string(6) "cherry"
}
]]>
    </screen>
   </para>
   <para>
    Elements of arrays are equal for the comparison if they have the
    same key and value.
   </para>
   <para>
    <example>
     <title>Comparing arrays</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("apple", "banana");
$b = array(1 => "banana", "0" => "apple");

var_dump($a == $b); // bool(true)
var_dump($a === $b); // bool(false)
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <link linkend="language.types.array">配列</link> と 
    <link linkend="ref.array">配列関数</link>も参照してください。
   </para>
  </sect1>

  <sect1 id="language.operators.type">
   <title>Type Operators</title>
   <para>
    PHP has a single type operator: <literal>instanceof</literal>. 
    <literal>instanceof</literal> is used to determine whether a given
    object is of a specified <link linkend="language.oop">object class</link>.
   </para>
   <simpara>
    The <literal>instanceof</literal> operator was introduced in PHP 5.
    Before this time <function>is_a</function> was used but
    <function>is_a</function> has since been deprecated in favor of
    <literal>instanceof</literal>. 
   </simpara>
   <informalexample>
    <programlisting>
<![CDATA[
<?php
class A { }
class B { }

$thing = new A;

if ($thing instanceof A) {
    echo 'A';
}
if ($thing instanceof B) {
    echo 'B';
}
?>
]]>
    </programlisting>
    <simpara>
     As <varname>$thing</varname> is an <type>object</type> of type A, but
     not B, only the block dependent on the A type will be executed:
    </simpara>
    <screen>A</screen>
   </informalexample>
   <para>
    See also <function>get_class</function> and 
    <function>is_a</function>.
   </para>
  </sect1>
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
