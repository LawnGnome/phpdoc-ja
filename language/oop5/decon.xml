<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.1 $ -->
<!-- EN-Revision: 1.8 Maintainer: hirokawa Status: ready -->

<sect1 id="language.oop5.decon">
 <title>コンストラクタとデストラクタ</title>
 
 <sect2 id="language.oop5.decon.constructor">
  <title>コンストラクタ</title>
  <methodsynopsis>
   <type>void</type><methodname>__construct</methodname>
   <methodparam choice="opt"><type>mixed</type><parameter>args</parameter></methodparam>
   <methodparam choice="opt"><parameter>...</parameter></methodparam>
  </methodsynopsis>
  <para>
   PHP 5 では、開発者がクラスのコンストラクタメソッドを宣言することが
   できます。コンストラクタメソッドを有するクラスは、新たにオブジェクトが
   生成される度にこのメソッドをコールします。これにより、
   そのオブジェクトを使用する前に必要な初期化を行うことができます。
  </para>
  <note>
   <simpara>
    子クラスがコンストラクタを有している場合、親クラスのコンストラクタが
    暗黙の内にコールされることはありません。
    親クラスのコンストラクタを実行するには、子クラスのコンストラクタの
    中で <function>parent::__construct</function> をコールすることが
    必要です。
   </simpara>
  </note>
  <example>
   <title>新しい統一されたコンストラクタを使用する</title>
   <programlisting role="php">
<![CDATA[
<?php
class BaseClass {
   function __construct() {
       print "In BaseClass constructor\n";
   }
}

class SubClass extends BaseClass {
   function __construct() {
       parent::__construct();
       print "In SubClass constructor\n";
   }
}

$obj = new BaseClass();
$obj = new SubClass();
?> 
]]>
   </programlisting>
  </example>
  <para>
   下位互換性を維持するため、PHP 5 が指定されたクラスの
   <function>__construct</function> 関数をみつけられない場合には、
   古い形式のコンストラクタ関数、つまり、そのクラスの名前と同じ関数、が探されます。
   実際、互換性の問題が発生する可能性があるのは、
   そのクラスが <function>__construct</function> という名前のメソッドを
   有しており、それが異なる用途で使用されている場合です。
  </para>
 </sect2>

 <sect2 id="language.oop5.decon.destructor">
  <title>デストラクタ</title>
  <methodsynopsis>
   <type>void</type><methodname>__destruct</methodname>
   <void />
  </methodsynopsis>
  <para>
   PHP 5 では、C++のような他のオブジェクト指向言語に似た概念のデストラクタが
   導入されました。デストラクタメソッドは、特定のオブジェクトへの全てのリファレンスが
   削除された直後やオブジェクトが明示的に破棄された直後にコールされます。
  </para>
  <example>
   <title>デストラクタの例</title>
   <programlisting role="php">
<![CDATA[
<?php
class MyDestructableClass {
   function __construct() {
       print "In constructor\n";
       $this->name = "MyDestructableClass";
   }

   function __destruct() {
       print "Destroying " . $this->name . "\n";
   }
}

$obj = new MyDestructableClass();
?> 
]]>
   </programlisting>
  </example>
  <para>
   コンストラクタと同様、親クラスのデストラクタがエンジンにより暗黙のうちに
   コールされるということはありません。親クラスのデストラクタを実行するには、
   デストラクタの中で明示的に<function>parent::__destruct</function>
   をコールする必要があります。
  </para>
 </sect2>
 
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
