<?xml version="1.0" encoding="UTF-8"?>
<!-- $Revision: 1.4 $ -->
<!-- EN-Revision: 1.4 Maintainer: takagi Status: ready -->
<chapter xml:id="language.namespaces" xmlns="http://docbook.org/ns/docbook"
 version="1.1">
 <title>名前空間</title>

 <sect1 xml:id="language.namespaces.rationale">
  <title>名前空間の概要</title>
  <simpara>
   PHP における名前空間は、PHP のライブラリが巨大化したときの
   スコープの問題を解決するために設計されています。
   PHP では、すべてのクラス定義はグローバルです。
   したがって、ライブラリの作者がさまざまな公開 API を作成する際には、
   他のライブラリの同様の機能との競合に注意する必要があります。
   お互いに名前が重複しないよう、一意な名前を選択する必要があるのです。
   このとき、通常はクラス名を先頭に付加することで一意な名前を作成します。
   たとえばデータベースのクラスなら、その先頭に
   <classname>My_Library_DB</classname> を付加するなどといったことです。
   ライブラリが巨大化するにつれて、このプレフィックスもどんどん追加され、
   非常に長ったらしい名前になってしまいます。
  </simpara>
  <simpara>
   名前空間を使用すると、そのクラスを参照する際に毎回長い名前を使用する必要がなくなります。
   コードの可読性を保ったまま、グローバル空間の共用の問題を解決することができます。
  </simpara>
  <simpara>
   名前空間は、PHP 5.3.0 以降で使用可能です。
   このセクションの内容は実験的なものであり、変更される可能性があります。
  </simpara>
 </sect1>

 <sect1 xml:id="language.namespaces.definition">
  <title>名前空間の定義</title>
  <para>
   名前空間の宣言は、<literal>namespace</literal>
   キーワードを用いて行います。これを、ファイルの先頭に記述しなければなりません。
   たとえば次のようになります。
   <example>
    <title>名前空間の定義</title>
    <programlisting role="php">
     <![CDATA[
<?php
    namespace MyProject::DB;
    
    const CONNECT_OK = 1;

    class Connection { /* ... */ }
    
    function connect() { /* ... */  }
    
?>
]]>
    </programlisting>
   </example>
   同一の名前空間を、複数のファイルで使用することもできます。
  </para>
  
  <para>
  名前空間の中にはクラスや定数、関数定義を含めることができます。
  ただしそれら以外のコードを含めることはできません。
  </para>

  <para>
   名前空間の定義は次のようなものです。
   <itemizedlist>
    <listitem>
     <simpara>
      名前空間の内部では、すべてのクラスや関数、
      定数名には自動的に名前空間名のプレフィックスが付加されます。
      クラス名は常にフルネームとなります。つまり、
      上の例のクラスをコールする際は
      <classname>MyProject::DB::Connection</classname>
      とします。
     </simpara>
    </listitem>
    <listitem>
    <simpara>
     定数を定義すると、名前空間名と定数名を組み合わせた定数を作成します。
     クラス定数と同様、名前空間定数にも静的な値しか保持できません。
    </simpara>
    </listitem>
    <listitem>
     <para>
      修飾されていないクラス名 (<literal>::</literal> を含まない名前)
      は、実行時に次の手順で解決されます。
      <orderedlist>
       <listitem>
        <simpara>
         そのクラスを、現在の名前空間から
         (つまり現在の名前空間名を先頭につけて) 探します。
         その際には
         <link linkend="language.oop5.autoload">autoload</link>
         を試みません。
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         グローバル名前空間から、autoload を試みずにそのクラスを探します。
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         現在の名前空間で autoload を試みます。
        </simpara>
       </listitem>
       <listitem>
        <simpara>以上がすべて失敗した場合は、クラスの検索が失敗します。</simpara>
       </listitem>
      </orderedlist>
     </para>
    </listitem>
    <listitem>
     <para>
      修飾されていない関数名 (<literal>::</literal> を含まない名前)
      は、実行時にまず現在の名前空間で探され、
      次にグローバル空間で探します。
     </para>
    </listitem>
    <listitem>
    <para>
     修飾されていない定数名は、
     まず現在の名前空間で探され、次にグローバル空間で探します。
    </para>
    </listitem>
   </itemizedlist>
   完全な <link linkend="language.namespaces.rules">名前解決の規則</link>
   も参照ください。
  </para>
 
 </sect1>

 <sect1 xml:id="language.namespaces.using">
  <title>名前空間の使用法</title>
  <para>
   名前空間内のすべてのクラスや関数は、どこからでも
   <classname>MyProject::DB::Connection</classname> や
   <classname>MyProject::DB::connect</classname>
   のようにフルネームで参照することができます。
   <example>
    <title>名前空間内の名前の使用法</title>
    <programlisting role="php">
     <![CDATA[
<?php
    require 'MyProject/Db/Connection.php';
    $x = new MyProject::DB::Connection;
    MyProject::DB::connect();
?>
]]>
    </programlisting>
   </example>
  </para>

  <para>
   名前空間を現在のコンテキスト (グローバル空間あるいは別の名前空間)
   にインポートするには <literal>use</literal> 演算子を使用します。
   この演算子の構文は、次のようになります。
   <informalexample>
    <programlisting role="php">
     <![CDATA[
<?php
/* ... */
use Some::Name as Othername;

// シンプルな使用法
use Foo::Bar;
// これは、さきほどと同じ意味になります
use Foo::Bar as Bar;
?>
]]>
    </programlisting>
   </informalexample>
   インポートされた名前の働きは、次のようになります。
   コンパイラがローカル名 <literal>Othername</literal>
   (それ単体か、あるいは <literal>::</literal> で区切られた長い名前へのプレフィックス)
   に遭遇すると、インポートされた名前 <literal>Some::Name</literal>
   でそれを置き換えます。
  </para>

  <para>
   <literal>use</literal> はグローバルスコープでのみ使用可能です。
   関数やクラスの内部では使用できません。
   インポートされた名前が有効なのは、
   インポートした箇所からそのファイルの最後までの間です。
   混乱を避けるため、インポートはファイルの先頭で行うようにしましょう。
  </para>

  <para>
   <example>
    <title>名前空間のインポート、名前空間へのアクセス</title>
    <programlisting role="php">
     <![CDATA[
<?php
    require 'MyProject/Db/Connection.php';
    use MyProject::DB;
    use MyProject::DB::Connection as DbConnection;
    
    $x = new MyProject::DB::Connection();
    $y = new DB::connection();
    $z = new DbConnection();
    DB::connect();
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <note>
    <simpara>
     インポート処理はコンパイル時にのみ行われ、
     すべてのローカル名はコンパイラによって完全な名前に変換されます。
     この変換は文字列で行うわけではないので、
     コールバック関数の指定がインポートの影響を受けることはありません。
    </simpara>
   </note>
  </para>
 </sect1>

 <sect1 xml:id="language.namespaces.global">
  <title>グローバル空間</title>
  <para>
   名前空間を定義しない場合は、すべてのクラスや関数の定義はグローバル空間に配置されます。
   これは、名前空間をサポートする前のバージョンの PHP と同じ状態です。
   名前の先頭に <literal>::</literal> をつけると、
   名前空間のコンテキストでも明示的にグローバル空間を指定することができます。
   <example>
    <title>グローバル空間の指定</title>
    <programlisting role="php">
     <![CDATA[
<?php
    namespace A::B::C;
 
 /* この関数は A::B::C::fopen です */
    function fopen() { 
         /* ... */
         $f = ::fopen(...); // グローバル空間の fopen をコールします
         return $f;
    } 
?>
]]>
    </programlisting>
   </example>
  </para>
 </sect1>

 <sect1 xml:id="language.namespaces.constant">
  <title>__NAMESPACE__</title>
  <para>
   コンパイル時に、現在の名前空間を表す定数
   <constant>__NAMESPACE__</constant> が定義されます。
   名前空間の外部では、この定数の値は空文字列となります。
   この定数は、名前空間内のローカル名から完全な名前を作成する際に便利です。
   <example>
    <title>__NAMESPACE__ の使用法</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace A::B::C;
         
function foo() {
// 何かの処理
}

set_error_handler(__NAMESPACE__ . "::foo");
?>
]]>
    </programlisting>
   </example>
  </para>
 </sect1>

 <sect1 xml:id="language.namespaces.rules">
  <title>名前解決の規則</title>
  <para>
   名前解決は、以下の規則に基づいて行います。
   <orderedlist>
    <listitem>
     <simpara>
      すべての修飾名が、コンパイル時に import の指定にあわせて変換されます。
      たとえば、名前空間 A::B::C をインポートした環境で
      <code>C::D::e()</code> をコールすると、それが
      <code>A::B::C::D::e()</code> に変換されます。
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      修飾されていないクラス名が、コンパイル時に import の指定にあわせて変換されます
      (短い名前を完全な名前に変換します)。
      たとえば、名前空間 <literal>A::B::C</literal> をインポートした環境では
      <code>new C()</code> が <code>new A::B::C()</code> に変換されます。
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      名前空間の中で、修飾されていない関数コールのうち、現在の名前空間で定義されているもの
      (そしてその関数コールをパースする時点で既知のもの) については、
      現在の名前空間の関数に変換されます。
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      名前空間 (たとえば A::B) の中で、修飾されていない関数コールのうち、
      現在の名前空間では定義されていないものについては実行時に解決されます。
      関数 <literal>foo()</literal> のコールは、次のように解決されます。
     </simpara>
      <orderedlist>
       <listitem>
        <simpara>
         現在の名前空間の関数
         <literal>A::B::foo()</literal> を探します。
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         内部関数
         <literal>foo()</literal> を探します。
        </simpara>
       </listitem>
      </orderedlist>
      <simpara>
      グローバル名前空間にあるユーザ定義の関数をコールするには、
      <literal>::foo()</literal> とする必要があります。
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      名前空間 (たとえば <literal>A::B</literal>) の中で、
      修飾されていないクラス名については実行時に解決されます。
      <code>new C()</code> のコールは、次のように解決されます。
     </simpara>
     <orderedlist>
      <listitem>
       <simpara>
        現在の名前空間のクラス
        <literal>A::B::C</literal> を探します。
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        内部クラス
        <literal>C</literal> を探します。
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <literal>A::B::C</literal>
        の autoload を試みます。
       </simpara>
      </listitem>
     </orderedlist>
     <simpara>
      グローバル名前空間にあるユーザ定義のクラスを参照するには
      <code>new ::C()</code> とする必要があります。
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      修飾されている関数コールを実行時に解決します。
      <literal>A::B::foo()</literal> のコールは、次のように解決されます。
     </simpara>
      <orderedlist>
       <listitem>
        <simpara>
         名前空間 <literal>A::B</literal> の関数
         <literal>foo()</literal> を探します。
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         クラス <literal>A::B</literal> を探し、その静的メソッド
         <literal>foo()</literal> をコールします。
         必要に応じてクラスを autoload します。
        </simpara>
       </listitem>
      </orderedlist>
    </listitem>
    <listitem>
     <simpara>
      修飾されているクラス名を、コンパイル時にその名前空間のクラスとして解決します。
      たとえば <code>new A::B::C()</code> は、名前空間
      <literal>A::B</literal> のクラス <classname>C</classname> を指します。
     </simpara>
    </listitem>
   </orderedlist>
  </para>
  <example>
   <title>名前解決の解説</title>
   <programlisting role="php">
<![CDATA[
<?php
namespace A;

// 関数コール

foo();      // まずは名前空間 "A" の関数 "foo" のコールを試み、
            // それがなければ内部関数 "foo" をコールします

::foo();    // グローバルスコープで定義されている関数 "foo" をコールします

// クラスの参照

new B();    // まずは名前空間 "A" で定義されているクラス "B" のオブジェクトの作成を試み、
            // それがなければ内部クラス "B" のオブジェクトを作成します

new ::B();  // グローバルスコープで定義されているクラス "B" のオブジェクトをします

// 他の名前空間の静的メソッド/関数

B::foo();   // まずは名前空間 "A::B" の関数 "foo" のコールを試み、
            // 次に内部クラス "B" のメソッド "foo" をコールします

::B::foo(); // まずは名前空間 "B" の関数 "foo" のコールを試み、
            // 次にグローバルスコープのクラス "B" のメソッド "foo" をコールします

// 現在の名前空間の静的メソッド/関数

A::foo();   // まずは名前空間 "A::A" の関数 "foo" のコールを試み、
            // 次に名前空間 "A" のクラス "A" のメソッド "foo"、
            // それから名前空間 "A" の関数 "foo"、
            // さらにその次に内部クラス "A" のメソッド "foo" という順になります

::A::foo(); // まずは名前空間 "A" の関数 "foo" のコールを試み、次に
            // グローバルスコープのクラス "A" のメソッド "foo" をコールします
?>
]]>
   </programlisting>
  </example>
 </sect1>
</chapter>

<!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 vim600: syn=xml fen fdm=syntax fdl=2 si
 vim: et tw=78 syn=sgml
 vi: ts=1 sw=1
-->
