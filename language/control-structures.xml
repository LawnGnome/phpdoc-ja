  <chapter id="control-structures">
   <title>制御構造</title>

   <simpara>
   全てのPHPスクリプトは、一連の文からなります。
   文としては、代入、関数コール、ループ、条件文、そして、何もしない文(空の文)さえ
   使用することができます。
   文は、通常セミコロンで終了します。加えて、文は、中括弧によるグループ文で
   カプセル化することによりグループ化することが可能です。
   グループ文は、同時に文にもなります。
   本章では、様々な文の型が記述されています。</simpara>

   <sect1 id="control-structures.if">
    <title><literal>if</literal></title>
 
    <para>
     <literal>if</literal> 構文は、PHP を含む全ての言語において最も重要な機能の一つです。
   この構文は、命令の条件実行を可能にします。
   PHP では、次のような C 言語に似た<literal>if</literal> 構文が使用されます。

     <informalexample><programlisting>
 if (式)
     文
 </programlisting></informalexample></para>
 
    <simpara>
    式のセクションで記述したように式
    は論理値で評価されます。<replaceable>式</replaceable>
    が <literal>TRUE</literal> と評価された場合、PHP は文を実行します。
   <literal>FALSE</literal> と評価された場合は、これを無視します。</simpara>

    <para>
   以下の例は、<replaceable>$a</replaceable> が <replaceable>$b</replaceable> より
   大きい場合、<computeroutput>a は b より大きい</computeroutput>
   を表示します。
 
     <informalexample><programlisting>
 if ($a > $b)
     print "a は b より大きい";
 </programlisting></informalexample></para>

    <para>
   条件分岐させたい文が一つ以上ある場合もしばしばあります。
   もちろん、各々の文を<literal>if</literal> 文で括る必要はありません。
   代わりに、複数の文をグループ化することができます。
   例えば、このコードは、<replaceable>$a</replaceable> が<replaceable>$b</replaceable>
    よりも大きい場合に
   <computeroutput>a は b よりも大きい</computeroutput> を表示し、
   <replaceable>$a</replaceable> の値を <replaceable>$b</replaceable> に代入します。
 
     <informalexample><programlisting>
 if ($a > $b) {
     print "a は b より大きい";
     $b = $a;
 }
 </programlisting></informalexample></para>
 
    <simpara>
   if 文は、他の <literal>if</literal> 文の中で無限に入れ子にできます。
   これは、プログラムの様々な部分の条件付実行について
   完全な柔軟性を提供します。</simpara></sect1>

  <sect1 id="control-structures.else">
    <title><literal>else</literal></title>

    <para>
      ある条件が満たされている場合にある文を実行し、
      その条件が満たされていない場合に別の文を実行したいと考えた
      ことが度々あるかと思います。
      このために<literal>else</literal> があります。
   <literal>else</literal> は、<literal>if</literal>文における式の値が 
   <literal>FALSE</literal> の場合にある文を
   実行するように<literal>if</literal> 文を拡張します。     
   例えば、次のコードは、<replaceable>$a</replaceable> が <replaceable>$b</replaceable>
    よりも大きい場合に
   <computeroutput>a は b より大きい</computeroutput> を表示し、そうでない場合に、
   <computeroutput>a は b よりも大きくない</computeroutput> と表示します。

     <informalexample>
      <programlisting>
 if ($a > $b) {
     print "a は b よりも大きい";
 } else {
     print "a は b よりも大きくない";
 }
      </programlisting>
     </informalexample>
 
     <literal>else</literal> 文は、
     the <literal>if</literal> 式が <literal>FALSE</literal> と評価された場合
     のみ実行されます。
     また、<literal>elseif</literal> 式がある場合には、それも
     <literal>FALSE</literal> とい評価された場合にのみ実行されます。
     (以下参照)</para></sect1>
 
   <sect1 id="control-structures.elseif">
    <title><literal>elseif</literal></title>
 
    <para>
     <literal>elseif</literal> は、その名前から分かるように、<literal>if</literal>
     と <literal>else</literal> の組み合わせです。<literal>elseif</literal> は、
     <literal>else</literal> のように、元の <literal>if</literal> 式の値が
    <literal>FALSE</literal> の場合に別の文を実行するように <literal>if</literal> 
    文を拡張します。
    しかし、<literal>else</literal> とは異なり、<literal>elseif</literal> 式が
    <literal>TRUE</literal>  の場合にのみ代わりの式を実行します。
    例えば、次のコードは、<computeroutput>a は b より大きい</computeroutput>、
    <computeroutput>a は b に等しい</computeroutput> 、
    <computeroutput>a は b より小さい</computeroutput> を出力します。
 
     <informalexample>
      <programlisting>
 if ($a > $b) {
     print "a は b より大きい";
 } elseif ($a == $b) {
     print "a は b と等しい";
 } else {
     print "a は b より小さい";
 }
      </programlisting>
     </informalexample></para>
 
    <simpara>
   複数の <literal>elseif</literal> を同じ <literal>if</literal> 文の中で
   使用することができます。
   <literal>TRUE</literal> と評価された最初の <literal>elseif</literal> 式
   が実行されます。
   PHP では、(単語二つで) 'else if' と書くこともできます。
   動作は(一単語の) 'elseif' と同じです。
   文法的な意味はやや異なっています。
   (あなたが C 言語に詳しいとすると、C 言語のそれと同じ動作です。)
   しかし、最終的には、両者は全く同じ動作をします。</simpara>

    <simpara>
   <literal>elseif</literal> 文は、前にある全ての <literal>if</literal> 文と 
   <literal>elseif</literal> の値が<literal>FALSE</literal>であり、
   カレントの<literal>elseif</literal>式の値が<literal>TRUE</literal>である場合にのみ実行されます。</simpara></sect1>
 
    <sect1 id="control-structures.alternative-syntax">
     <title>制御構造に関する別の構文</title>
 
     <para>
     PHPは、いくつかの制御構造、つまり、<literal>if</literal>、<literal>while</literal>、
     <literal>for</literal>、<literal>switch</literal> に関する別の構文を提供します。
     各構造において基本的に開き波括弧をコロン(:)コロンに、
     閉じ波括弧をそれぞれ <literal>endif;</literal>、
     <literal>endwhile;</literal>, <literal>endfor;</literal>, <literal>endswitch;</literal>
     に変更するのが別の構文の基本形式となります。
 
      <informalexample>
       <programlisting>
 &lt;?php if ($a==5): ?&gt;
 A は 5 に等しい
 &lt;?php endif; ?&gt;
       </programlisting>
      </informalexample>
     </para>
 
     <simpara>
   上の例では、HTML ブロック "A = 5" はこの構文で
    書かれた<literal>if</literal> 文の内部で入れ子になっています。
    この HTML ブロックは、 $a が 5 の場合にのみ表示されます。</simpara>
 
     <para>
      この方法は、<literal>else</literal> や<literal>elseif</literal> にも
      同様に適用することができます。
      次の例は、この形式で <literal>if</literal> 文を <literal>elseif</literal> 
      および <literal>else</literal> と共に使用しています。
      
      <informalexample>
       <programlisting>
if ($a==5):
    print "a は 5 に等しい";
    print "...";
elseif ($a==6):
    print "a は 6 に等しい";
    print "!!!";
else
    print "a は 5 でも 6 でもない";
endif;
       </programlisting>
      </informalexample>
     </para>

     <para>
        より多くの例を参照するには、
	<link linkend="control-structures.while">while</link>,
	<link linkend="control-structures.for">for</link>, <link
	 linkend="control-structures.if">if</link> も参照下さい。
    </para>

   </sect1>
 
   <sect1 id="control-structures.while">
    <title><literal>while</literal></title>
 
    <para>
     <literal>while</literal>ループは、PHPで最も簡単なタイプのループです。
     このループは、C の WHILE ループと同様の動作をします。
     <literal>while</literal> ループの基本形は次のようになります。

     <informalexample>
     <programlisting>
    while (式) 文
    </programlisting>
    </informalexample></para>

   <simpara>
   <literal>while</literal> 文の意味は簡単です。
   <literal>while</literal> 文は、式の値が<literal>TRUE</literal>である間、
   入れ子の文を繰り返し実行することを PHP に指示します。
   式の値はループを開始する度にチェックされますので、
   入れ子になった文の実行中にこの値が代わった場合でも
   実行は、繰り返しの終わりまで終わらないでしょう。
   (PHP がループの中の文を実行する各回が一回の繰り返しです)      
   <literal>while</literal>式の値が初めから <literal>FALSE</literal> となる
   場合は、内部の文は一回も実行されません。</simpara>
  
    <para>
     <literal>if</literal> 文と同様に、
    波括弧で文の集まりを囲うか、以下に示す別の構文を
    用いることにより、
    同じ<literal>while</literal>ループの中に複数の文をグループ化することができます。
 
     <informalexample>
      <programlisting>
     while (式): 文 ... endwhile;
 </programlisting></informalexample></para>
 
     <para>
    次の例は同じです。
    両方共、1 から 10 までの数を出力します。

     <informalexample>
      <programlisting>
 /* 例 1 */
 
 $i = 1;
 while ($i <= 10) {
     print $i++;  /* 出力される値は、足される前の $i の値です。(後置加算) */
 }
 
 /* 例 2 */
 
 $i = 1;
 while ($i <= 10):
     print $i;
     $i++;
 endwhile;
      </programlisting>
     </informalexample></para></sect1>
 
 
   <sect1 id="control-structures.do.while">
    <title><literal>do..while</literal></title>
 
    <simpara>
   <literal>do..while</literal> ループは、論理式のチェックが各繰り返しの
   最初ではなく最後に行われること以外は、<literal>while</literal> ループに
   非常に似ています。
   通常の <literal>while</literal> ループとの主な差は、
   <literal>do..while</literal> ループは最低一回の実行を保証されていることです。
   一方、通常の <literal>while</literal> ループは、実行されないかもしれません。
   (論理式は、各繰り返しの最初でチェックされるので、
   最初から値が <literal>FALSE</literal> である場合はループの実行はすぐに終わるでしょう。)</simpara>
   <para>
   <literal>do..while</literal> ループの構文は次の一つのみです。
 
     <informalexample>
      <programlisting>
 $i = 0;
 do {
     print $i;
 } while ($i>0);
      </programlisting>
     </informalexample></para>
 
    <simpara>
  上記のループは必ず一度だけ実行されます。その原因は、
   最初の繰り返しの後、論理値のチェックを行った際に値が
   <literal>FALSE</literal>と
   なり($i は 0 より大きくない)、ループの実行が終了するためです。</simpara>
 
    <para>
   優れた C プログラマは、コードブロック中での実行中止が可能な
   <literal>do..while</literal> ループの別の使用法について熟知しているかもしれません。
   これは、<literal>do..while</literal>(0) でコードを括り、
   <link linkend="control-structures.break"><literal>break</literal></link>文を使用する方法です。
   次のコードは、この方法の例を示しています。
 
     <informalexample>
      <programlisting>
 do {
     if ($i < 5) {
         print "i は十分大きくはありません。";
         break;
     }
     $i *= $factor;
     if ($i < $minimum_limit) {
         break;
     }
     print "i はOKです。";
     ...process i...
 } while(0);
      </programlisting>
     </informalexample></para>
 
    <simpara>
     この例をすぐに理解できなかったり、全く理解できなかったりしても
    問題ありません。この '機能' を使用しなくても
    スクリプトコードを書くことができますし、強力なスクリプトでさえ
    作成することが可能です。</simpara></sect1>
 
   <sect1 id="control-structures.for">
    <title><literal>for</literal></title>
 
    <para>
   <literal>for</literal> ループは、PHP で最も複雑なループです。
   <literal>for</literal> は、C の for ループと同様に動作します。
   <literal>for</literal>ループの構文は、次のようになります。
 
     <informalexample>
      <programlisting>
for (式1; 式2; 式3) 文
      </programlisting>
     </informalexample>
    </para>
 
    <simpara>
    最初の式(<replaceable>式1</replaceable>)は、ループ開始時に無条件に
    評価(実行)されます。</simpara>

   <simpara>
   各繰り返しの開始時に、<replaceable>式2</replaceable>が評価されます。
   その式の値が<literal>TRUE</literal>が場合、ループは継続され、括弧内の文が
   実行されます。
   値が <literal>FALSE</literal>の場合、ループの実行は終了します。</simpara>

   <simpara>
   各繰り返しの後、<replaceable>式3</replaceable>が評価(実行)されます。</simpara>

   <simpara>
   各式は、空とすることができます。<replaceable>式2</replaceable>を空にすることは、
   無限実行ループを意味します。(PHP は、この状態を C のように暗黙の内に 
   <literal>TRUE</literal>とみなします)
   <literal>for</literal> 論理式を使用するよりも条件付 <link linkend="control-structures.break">
   <literal>break</literal></link> 文によりループを終了させたいと
   考える傾向がある場合には、この機能は思ったほど便利ではないかもしれません。</simpara>
 
     <para>
     次の例について考えてみましょう。全ての例は、1～10までの数を
     表示します。
 
     <informalexample>
      <programlisting>
 /* 例 1 */
 
 for ($i = 1; $i <= 10; $i++) {
     print $i;
 }
 
 /* 例 2 */
 
 for ($i = 1;;$i++) {
     if ($i > 10) {
         break;
     }
     print $i;
 }
 
 /* 例 3 */
 
 $i = 1;
 for (;;) {
     if ($i > 10) {
         break;
     }
     print $i;
     $i++;
 }
 
 /* 例 4 */
 
 for ($i = 1; $i <= 10; print $i, $i++) ;
      </programlisting>
     </informalexample></para>
 
    <simpara>
    もちろん、最初の例(もしくは 4番目の例)が最善であると考えられます。
    しかし、<literal>for</literal>ループにおいて空の式を使用できると、多くの場合、
    便利だということに気づかれるかと思います。</simpara>
 
    <para>
    PHP は、<literal>for</literal>ループ用に "コロン構文" もサポートします。

     <informalexample>
      <programlisting>
 for (式1; 式2; 式3): 文; ...; endfor;
      </programlisting>
     </informalexample></para>
 
    <para>
    他の言語には、配列やハッシュを連続的に処理するために
    <literal>foreach</literal>文があります。PHP3 にはこうした
    構文はありません。PHP4 はこれをサポートしています。
    (<link linkend="control-structures.foreach">foreach</link>を参照下さい)
    PHP3 では、同様の効果を得るために <link linkend="control-structures.while">
    while</link>文を <function>list</function> および <function>each</function>
    と組み合わせて使用します。
    例については、これらの関数のドキュメントを参照下さい。
    </para>
   
   </sect1>
 
   <sect1 id="control-structures.foreach">
    <title><literal>foreach</literal></title>
 
    <para>
     (PHP3 ではなく) PHP4 には、Perl や他の言語とよく似た
     <literal>foreach</literal> 構文があります。
     This simply gives an easy 
     way to iterate over arrays. There are two syntaxes; the second is
     a minor but useful extension of the first:
     <informalexample>
      <programlisting>
 foreach(array_expression as $value) statement
 foreach(array_expression as $key => $value) statement
      </programlisting>
     </informalexample>
    </para>
      
    <simpara>
     The first form loops over the array given by
     <literal>array_expression</literal>. On each loop, the value of
     the current element is assigned to <literal>$value</literal> and
     the internal array pointer is advanced by one (so on the next
     loop, you'll be looking at the next element).
    </simpara>
 
    <simpara>
     The second form does the same thing, except that the current
     element's key will be assigned to the variable
     <literal>$key</literal> on each loop.
    </simpara>
 
    <simpara>
     When <literal>foreach</literal> first starts executing, the
     internal array pointer is automatically reset to the first element 
     of the array. This means that you do not need to call
     <function>reset</function> before a <literal>foreach</literal>
     loop.
    </simpara>
 
    <para>
     You may have noticed that the following are functionally
     identical:
     <informalexample>
      <programlisting>
 reset( $arr );
 while( list( , $value ) = each( $arr ) ) {
    echo "Value: $value&lt;br&gt;\n";
 }
 
 foreach( $arr as $value ) {
    echo "Value: $value&lt;br&gt;\n";
 }
      </programlisting>
     </informalexample>
     The following are also functionally identical:
     <informalexample>
      <programlisting>
 reset( $arr );
 while( list( $key, $value ) = each( $arr ) ) {
    echo "Key: $key; Value: $value&lt;br&gt;\n";
 }
 
 foreach( $arr as $key => $value ) {
    echo "Key: $key; Value: $value&lt;br&gt;\n";
 }
      </programlisting>
     </informalexample>
    </para>
 
    <para>
     Some more examples to demonstrate usages:
     <informalexample>
      <programlisting>
 /* foreach example 1: value only */
 $a = array(1, 2, 3, 17);
 
 foreach($a as $v) {
    print "Current value of \$a: $v.\n";
 }
 
 /* foreach example 2: value (with key printed for illustration) */
 $a = array(1, 2, 3, 17);
 
 $i = 0; /* for illustrative purposes only */
 
 foreach($a as $v) {
    print "\$a[$i] => $k.\n";
 }
 
 /* foreach example 3: key and value */
 $a = array(
    "one" => 1,
    "two" => 2,
    "three" => 3,
    "seventeen" => 17
 );
 
 foreach($a as $k => $v) {
    print "\$a[$k] => $v.\n";
 }
      </programlisting>
     </informalexample>
 
    </para>
 
   </sect1>

   <sect1 id="control-structures.break">
    <title><literal>break</literal></title>
 
    <para>
     <literal>break</literal> は、現在のループ構造を抜け出します。
 
     <informalexample>
      <programlisting>
 $i = 0;
 while ($i < 10) {
     if ($arr[$i] == "stop") {
         break;
     }
     $i++;
 }
      </programlisting>
     </informalexample></para></sect1>
 
   <sect1 id="control-structures.continue">
    <title><literal>continue</literal></title>
 
    <para>
     <literal>continue</literal> は、ループ構造において現在の繰り返しループ
     の残りの処理をスキップし、次の繰り返しの最初から実行を続けるために
     使用されます、
 
     <informalexample>
      <programlisting>
 while (list($key,$value) = each($arr)) {
     if ($key % 2) { // キーが偶数の組をスキップ
         continue;
     }
     do_something_odd ($value);
 }
      </programlisting>
     </informalexample></para></sect1>
 
   <sect1 id="control-structures.switch">
    <title><literal>switch</literal></title>
 
    <simpara>
     The <literal>switch</literal> 文は、同じ式を用いて IF 文を並べたのに似ています。
   同じ変数を異なる値と比較し、値に応じて異なったコードを実行したいと
   思うことがしばしばあるかと思います。   
   <literal>switch</literal> 文は、まさにこのためにあるのです。</simpara>
 
    <para>
    次の二つの例は、同じことを二つの異なった方法で書いたものです。
    一つは、<literal>if</literal> 文を、もう一つは、<literal>switch</literal> 
    文を使っています。
 
     <informalexample>
      <programlisting>
 if ($i == 0) {
    print "i は 0 に等しい";
 }
 if ($i == 1) {
    print "i は 1 に等しい";
 }
 if ($i == 2) {
    print "i は 2 に等しい";
 }
 
 switch ($i) {
     case 0:
         print "i は 0 に等しい";
         break;
     case 1:
         print "i は 1 に等しい";
         break;
     case 2:
         print "i は 2 に等しい";
         break;
 }
      </programlisting>
     </informalexample></para>
 
    <para>
    失敗を避けるために <literal>switch</literal> 文がどのように実行されるのかを
    理解することが重要です。
    <literal>switch</literal>文は、行毎に実行されます。(実際には、文毎に実行されます。)
    初めは、何も実行しません。        
    <literal>switch</literal>式の値と一致する値を有する <literal>case</literal>文
    が見つけられたときに
    PHP は命令の実行を開始します。
    PHP は <literal>switch</literal> ブロックの終わりまたは最初の <literal>break</literal>
    文まで実行を続けます。
    CASE 文の終わりに <literal>break</literal> 文を書かない場合は、PHP は
    次の CASE 文を実行しつづけます。例えば、

     <informalexample>
      <programlisting>
 switch ($i) {
     case 0:
         print "i は 0 に等しい";
     case 1:
         print "i は 1 に等しい";
     case 2:
         print "i は 2 に等しい";
 }
      </programlisting>
     </informalexample></para>
 
    <simpara>
   ここで、$i が 0 に等しい場合は、PHP は全ての文を出力してしまいます!
   $i が 1 の場合、PHP は最後の二つの文を出力します。
   $i が 2 に等しい場合のみ、'期待した'動作をし、
   'i は 2 に等しい' と表示します。
   このため、(ある種の状況下では、BREAK を付加することを避けたいと
   思うかもしれませんが、)   
   <literal>break</literal> 文を忘れないようにすることは重要です。
   </simpara>

   <simpara>
     <literal>switch</literal>文では、条件は1度だけ評価され、
     その結果が各<literal>case</literal>文と比較されます。
     <literal>elseif</literal>文では、条件は、再度評価されます。
     使用する条件が単純な比較処理よりも複雑な処理を行ったり、
     重い繰り返し処理を行う場合、<literal>switch</literal>の方が
     より処理が速い可能性があります。
   </simpara>

    <para>
    case に付随する文は、空とすることが可能です。
    この場合、次の case に付随する文に制御が移行します。
     <informalexample>
      <programlisting>
 switch ($i) {
     case 0:
     case 1:
     case 2:
         print "i は 3 より小さいですが負ではありません";
         break;
     case 3:
         print "i は3です";
 }
      </programlisting>
     </informalexample></para>
 
    <para>
    default  は、case 文の特別な場合です。
   これは、他の全ての case にマッチしない場合に、
   実行されます。例を以下に示します。
 
     <informalexample>
      <programlisting>
 switch ($i) {
     case 0:
         print "i は 0 に等しい";
         break;
     case 1:
         print "i は 1 に等しい";
         break;
     case 2:
         print "i は 2 に等しい";
         break;
     default:
         print "i は 0, 1 ,2 に等しくない";
 }
      </programlisting>
     </informalexample>
    </para>
 
    <para>
     <literal>case</literal> 式は、スカラー型に式を評価する
     任意の式、つまり、整数又は浮動小数点、文字列、とすることができます。
     配列又はオブジェクトは、単純な型を指していない限り
     使用することができません。
    </para>

    <para>
      switch 文の制御構造に関する別の構文がサポートされています。
      詳細は、<link
 	 linkend="control-structures.alternative-syntax">制御構造に関する別の構文
	 </link>  を参照下さい。
  
      <informalexample>
       <programlisting>
 switch ($i):
      case 0:
          print "i は 0 に等しい";
          break;
      case 1:
          print "i は 1 に等しい";
          break;
      case 2:
          print "i は 2 に等しい";
          break;
      default:
          print "i は 0 でも 1 でも 2 でもない";
  endswitch;
       </programlisting>
      </informalexample></para>

   </sect1>
 
   <sect1 id="function.require">
    <title><literal>require</literal></title>
 
    <simpara>
     <literal>require</literal> 文は、
     プリプロセッサの #include 文の動作と
     同じく、自分自身を指定したファイルで置き換えます。</simpara>

    <para>
	これは、ループ構造の中に <literal>require</literal> 文
	を置き、各ループ毎に別のファイルの内容を読み込むことが
	できないことを意味します。
	これを行うには、<literal>include</literal>文を使用して下さい。

     <informalexample>
      <programlisting>
 require 'header.inc';
      </programlisting>
     </informalexample>
    </para>

    <para>
 	<function>include</function> および<function>require</function> は共に
	実際にターゲットファイルの中身を呼出側のファイル自体に読みこむことに
	注意してください。ターゲットを HTTP のようなものを経由してコールする
	わけではありません。よって、
	インクルードされるファイルは効率的に呼出側のファイルの一部になるため、
	インクルードされた側のスコープで設定された全ての変数はインクルード
	されるファイルの中でも自動的に利用可能です。
 	<informalexample>
 	 <programlisting>
 include( "file.inc?varone=1&amp;vartwo=2" ); /* 動作しません */
 
 $varone = 1;
 $vartwo = 2;
 include( "file.inc" );  /* $varone および $vartwo は file.inc で利用可能です */
 
 	 </programlisting>
 	</informalexample>
 
    </para>

   </sect1>
 
   <sect1 id="function.include">
    <title><literal>include</literal></title>
 
    <simpara>
     <literal>include</literal> 文は指定されたファイルを読み込み、
	評価します。</simpara>
 
    <para>
	 この処理は、<literal>include</literal> 文を処理する度に行われます。
	このため、異なった複数のファイルを読み込むためにループ構造の中で
	 <literal>include</literal> を使用することができます。
 
     <informalexample>
      <programlisting>
 $files = array ('first.inc', 'second.inc', 'third.inc');
 for ($i = 0; $i < count($files); $i++) {
     include $files[$i];
 }
      </programlisting>
     </informalexample></para>

    <para>
     <link linkend="function.include"><literal>include</literal></link> は、
     <link linkend="function.require"><literal>require</literal></link> とは
     異なっています。つまり、include 文はその文の処理が行われる度に
     (実行時においてのみ)再度評価されますが、
     <link linkend="function.require"><literal>require</literal></link> 文は、
     (例えば、条件が FALSE となる if 文の中のように)
     要求されたファイルの内容が評価されるかどうかにかかわらず
     最初に読み込まれたファイルで置き換えられます。</para>
 
    <para>
     <link linkend="function.include"><literal>include</literal></link> は
     特殊な言語構造なので、条件ブロックの内部にある時には、命令ブロックの中に
     入れておく必要があります。
 
     <informalexample>
      <programlisting>
 /* 以下は誤っており、希望通りに動作しません。 */
 
 if ($condition)
     include($file);
 else
     include($other);
 
 /* 以下が正解です。 */
 
 if ($condition) {
     include($file);
 } else {
     include($other);
 }
      </programlisting>
     </informalexample></para>
 
    <para>
    ファイルが評価された際、パーサーは "HTML-mode" となっており、
    PHP 開始タグ (&lt;?) に合うまで、ファイルの内容が出力されます。</para>
 
    <para>
 	<function>include</function> および<function>require</function> は共に
	実際にターゲットファイルの中身を呼出側のファイル自体に読みこむことに
	注意してください。ターゲットを HTTP のようなものを経由してコールする
	わけではありません。よって、
	インクルードされるファイルは効率的に呼出側のファイルの一部になるため、
	インクルードされた側のスコープで設定された全ての変数はインクルード
	されるファイルの中でも自動的に利用可能です。
 	<informalexample>
 	 <programlisting>
 include( "file.inc?varone=1&amp;vartwo=2" ); /* 動作しません */
 
 $varone = 1;
 $vartwo = 2;
 include( "file.inc" );  /* $varone および $vartwo は file.inc で利用可能です */
 
 	 </programlisting>
 	</informalexample>
 
    </para>

    <para>
     <function>readfile</function>, <function>require</function>,
     <function>virtual</function>も参照下さい。 </para></sect1>

  </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:nil
 sgml-default-dtd-file:"../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
