<?xml version="1.0" encoding="utf-8"?>
<!-- sync: 1.78 -->
 <chapter id="control-structures">
  <title>制御構造</title>

  <simpara>
   全てのPHPスクリプトは、一連の文からなります。
   文としては、代入、関数コール、ループ、条件文、そして、何もしない文(空の文)
   さえ使用することができます。
   文は、通常セミコロンで終了します。加えて、文は、中括弧によるグループ文で
   カプセル化することによりグループ化することが可能です。
   グループ文は、同時に文にもなります。
   本章では、様々な文の型が記述されています。
  </simpara>

  <sect1 id="control-structures.if">
   <title><literal>if</literal></title>
   <para>
    <literal>if</literal> 構文は、PHP を含む全ての言語において最も重要な
    機能の一つです。
    この構文は、命令の条件実行を可能にします。
    PHPでは、次のようなC言語に似た<literal>if</literal>構文が使用されます。
    <informalexample>
     <programlisting>
<![CDATA[
if (式)
    文
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    <link linkend="language.expressions">式のセクション</link>で
    記述したように<replaceable>式</replaceable>は論理値で評価されます。
    <replaceable>式</replaceable>が&true;と評価された場合、
    PHPは<replaceable>文</replaceable>を実行します。&false;
    と評価された場合は、これを無視します。どのような値が
    &false;と評価されるについては<link 
    linkend="language.types.boolean.casting">論理値への変換</link>
    を参照してください。
   </simpara>
   <para>
    以下の例は、<replaceable>$a</replaceable>が<replaceable>$b</replaceable>
    より大きい場合、<computeroutput>aはbより大きい</computeroutput>
    を表示します。
    <informalexample>
     <programlisting role="php">
<![CDATA[
if ($a > $b)
    print "aはbより大きい";
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    条件分岐させたい文が一つ以上ある場合もしばしばあります。
    もちろん、各々の文を<literal>if</literal> 文で括る必要はありません。
    代わりに、複数の文をグループ化することができます。
    例えば、このコードは、<replaceable>$a</replaceable>
    が<replaceable>$b</replaceable>よりも大きい場合に
    <computeroutput>aはbよりも大きい</computeroutput>を表示し、
    <replaceable>$a</replaceable>の値を<replaceable>$b</replaceable>に
    代入します。
    <informalexample>
     <programlisting role="php">
<![CDATA[
if ($a > $b) {
    print "aはbより大きい";
    $b = $a;
}
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    <literal>if</literal>文は、他の<literal>if</literal>文の中で無限に入れ子にできます。
    これは、プログラムの様々な部分の条件付実行について
    完全な柔軟性を提供します。
   </simpara>
  </sect1>

  <sect1 id="control-structures.else">
   <title><literal>else</literal></title>
   <para>
    ある条件が満たされている場合にある文を実行し、
    その条件が満たされていない場合に別の文を実行したいと考えた
    ことが度々あるかと思います。
    このために<literal>else</literal>があります。
    <literal>else</literal>は、<literal>if</literal>文における式の値が 
    &false;の場合にある文を
    実行するように<literal>if</literal>文を拡張します。     
    例えば、次のコードは、<replaceable>$a</replaceable>が
    <replaceable>$b</replaceable>よりも大きい場合に
    <computeroutput>aはbより大きい</computeroutput>と表示し、
    そうでない場合に、
    <computeroutput>aはbよりも大きくない</computeroutput>と表示します。
    <informalexample>
     <programlisting role="php">
<![CDATA[
if ($a > $b) {
    print "aはbよりも大きい";
} else {
    print "aはbよりも大きくない";
}
]]>
     </programlisting>
    </informalexample>
    
    <literal>else</literal> 文は、<literal>if</literal>式が
    &false;と評価された場合のみ実行されます。
    また、<literal>elseif</literal>式がある場合には、それも
    &false;と評価された場合にのみ実行されます。
    (<link linkend="control-structures.elseif">elseif</link>参照)

   </para>
  </sect1>
 
  <sect1 id="control-structures.elseif">
   <title><literal>elseif</literal></title>
   <para>
    <literal>elseif</literal>は、その名前から分かるように、<literal>if</literal>
    と<literal>else</literal>の組み合わせです。<literal>elseif</literal>は、
    <literal>else</literal>のように、元の<literal>if</literal>式の値が
    &false;の場合に別の文を実行するように<literal>if</literal> 
    文を拡張します。
    しかし、<literal>else</literal>とは異なり、<literal>elseif</literal>式が
    &true;の場合にのみ代わりの式を実行します。
    例えば、次のコードは、<computeroutput>aはbより大きい</computeroutput>、
    <computeroutput>aはbに等しい</computeroutput>、
    <computeroutput>aはbより小さい</computeroutput>を出力します。
    <informalexample>
     <programlisting role="php">
<![CDATA[
if ($a > $b) {
    print "aはbより大きい";
} elseif ($a == $b) {
    print "aはbと等しい";
} else {
    print "aはbより小さい";
}
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    複数の<literal>elseif</literal>を同じ<literal>if</literal>文の中で
    使用することができます。
    &true;と評価された最初の<literal>elseif</literal>式
    が実行されます。PHPでは、(単語二つで)'else if'と書くこともできます。
    動作は(一単語の) 'elseif'と同じです。文法的な意味はやや異なっています。
    (あなたが C 言語に詳しいとすると、C 言語のそれと同じ動作です。)
    しかし、最終的な両者の動作は全く同じです。
   </simpara>
   <simpara>
    <literal>elseif</literal>文は、前にある全ての<literal>if</literal>文と 
    <literal>elseif</literal>の値が&false;であり、
    カレントの<literal>elseif</literal>式の値が&true;である
    場合にのみ実行されます。
   </simpara>
  </sect1>
 
  <sect1 id="control-structures.alternative-syntax">
   <title>制御構造に関する別の構文</title>
   <para>
    PHPは、いくつかの制御構造、つまり、<literal>if</literal>、
    <literal>while</literal>、<literal>for</literal>、
    <literal>foreach</literal>、<literal>switch</literal>
    に関する別の構文を提供します。
    各構造において開き波括弧をコロン(:)、閉じ波括弧をそれぞれ
    <literal>endif;</literal>,<literal>endwhile;</literal>,
    <literal>endfor;</literal>,<literal>endforeach;</literal>,
    <literal>endswitch;</literal>に変更するのが
    別の構文の基本的な形式となります。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php if ($a == 5): ?>
Aは5に等しい
<?php endif; ?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    上の例では、HTMLブロック"Aは5に等しい"はこの構文で
    書かれた<literal>if</literal>文の内部で入れ子になっています。
    このHTMLブロックは、$aが5の場合にのみ表示されます。
   </simpara>
   <para>
    この方法は、<literal>else</literal>や<literal>elseif</literal>にも
    同様に適用することができます。
    次の例は、この形式で<literal>if</literal>文を<literal>elseif</literal> 
    および<literal>else</literal>と共に使用しています。
    <informalexample>
     <programlisting role="php">
<![CDATA[
if ($a == 5):
    print "aは5に等しい";
    print "...";
elseif ($a == 6):
    print "aは6に等しい";
    print "!!!";
else:
    print "aは5でも6でもない";
endif;
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    より多くの例を参照するには、
    <link linkend="control-structures.while">while</link>,
    <link linkend="control-structures.for">for</link>, 
    <link linkend="control-structures.if">if</link>も参照下さい。
   </para>
  </sect1>
 
  <sect1 id="control-structures.while">
   <title><literal>while</literal></title>
   <para>
    <literal>while</literal>ループは、PHPで最も簡単なタイプのループです。
    このループは、CのWHILEループと同様の動作をします。
    <literal>while</literal>ループの基本形は次のようになります。
    <informalexample>
     <programlisting>
<![CDATA[
while (式) 文
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    <literal>while</literal>文の意味は簡単です。
    <literal>while</literal>文は、式の値が&true;である間、
    入れ子の文を繰り返し実行することをPHPに指示します。
    式の値は各反復処理の開始時にチェックされるので、ループ内の文の実行により
    この値が代わった場合でもループ実行は各ループを終るまで終わりません。
    (PHPによるループ内の文の実行が1回分の反復に相当します)      
    <literal>while</literal>式の値が初めから&false;の
    場合は、内部の文は一回も実行されません。
   </simpara>
   <para>
    <literal>if</literal>文と同様に、波括弧で複数の文を囲うか、
    以下に示す別の構文を用いることにより、同じ<literal>while</literal>
    ループの中に複数の文をグループ化することができます。
    <informalexample>
     <programlisting>
<![CDATA[
while (式): 文 ... endwhile;
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    次の例は同じです。両方共、1から10までの数を出力します。
    <informalexample>
     <programlisting role="php">
<![CDATA[
/* 例 1 */
 
$i = 1;
while ($i <= 10) {
    print $i++;  /* 出力される値は、足される前の
                    $iの値です。
                    (後置加算) */
}
 
/* 例 2 */
 
$i = 1;
while ($i <= 10):
    print $i;
    $i++;
endwhile;
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>
 
  <sect1 id="control-structures.do.while">
   <title><literal>do..while</literal></title>
   <simpara>
    <literal>do..while</literal>ループは、論理式のチェックが各反復の
    最初ではなく最後に行われること以外は、<literal>while</literal>ループと
    全く同じです。通常の<literal>while</literal>ループとの主な差は、
    <literal>do..while</literal>ループは最低1回の実行を保証されていることです。
    一方、通常の<literal>while</literal>ループは、実行されないかもしれません。
    (論理式は各反復の最初でチェックされるので、
    最初から値が&false;である場合はループの実行は
    すぐに終わります。)
   </simpara>
   <para>
    <literal>do..while</literal> ループの構文は次の一つのみです。
 
    <informalexample>
     <programlisting role="php">
<![CDATA[
$i = 0;
do {
    print $i;
} while ($i>0);
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    上記のループは必ず一度だけ実行されます。その原因は、最初の反復の後、
    論理値のチェックを行った際に値が&false;と
    なり($iは0より大きくない)、ループの実行が終了するためです。
   </simpara>
   <para>
    優れたCプログラマは、コードブロック中での実行中止が可能な
    <literal>do..while</literal>ループの別の使用法について熟知している
    かもしれません。
    これは、<literal>do..while</literal>(0)でコードを括り、
    <link linkend="control-structures.break"><literal>break</literal></link>
    文を使用する方法です。次のコードは、この方法の例を示しています。
    <informalexample>
     <programlisting role="php">
<![CDATA[
do {
    if ($i < 5) {
        print "i は十分大きくはありません。";
        break;
    }
    $i *= $factor;
    if ($i < $minimum_limit) {
        break;
    }
    print "iはOKです。";

    ...iを使った処理...

} while(0);
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    この例をすぐに理解できなかったり、全く理解できなかったりしても
    問題ありません。この'機能'を使用しなくても
    スクリプトコードを書くことができますし、強力なスクリプトでさえ
    作成することが可能です。
   </simpara>
  </sect1>
  
  <sect1 id="control-structures.for">
   <title><literal>for</literal></title>
   <para>
    <literal>for</literal> ループは、PHPで最も複雑なループです。
    <literal>for</literal> は、Cのforループと同様に動作します。
    <literal>for</literal>ループの構文は、次のようになります。
    <informalexample>
     <programlisting>
<![CDATA[
for (式1; 式2; 式3) 文
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    最初の式(<replaceable>式1</replaceable>)は、ループ開始時に無条件に
    評価(実行)されます。
   </simpara>
   <simpara>
    各繰り返しの開始時に、<replaceable>式2</replaceable>が評価されます。
    その式の値が&true;が場合、ループは継続され、括弧
    内の文が実行されます。値が&false;の場合、ループの
    実行は終了します。
   </simpara>
   <simpara>
    各繰り返しの後、<replaceable>式3</replaceable>が評価(実行)されます。
   </simpara>
   <simpara>
    各式は、空とすることができます。<replaceable>式2</replaceable>を空
    にすることは、無限実行ループを意味します。(PHPは、この状態をC言語
    のように暗黙の内に &true;とみなします)
    <literal>for</literal>論理式を使用するよりも条件付
    <link linkend="control-structures.break"><literal>break</literal></link>
    文によりループを終了させる方が好ましい場合には、この機能は思った
    ほど便利ではないかもしれません。
   </simpara>
   <para>
    次の例について考えてみましょう。以下の例は全て1～10までの数を表示します。
    <informalexample>
     <programlisting role="php">
<![CDATA[
/* 例 1 */
 
for ($i = 1; $i <= 10; $i++) {
    print $i;
}
 
/* 例 2 */
 
for ($i = 1;;$i++) {
    if ($i > 10) {
        break;
    }
    print $i;
}
 
/* 例 3 */
 
$i = 1;
for (;;) {
    if ($i < 10) {
        break;
    }
    print $i;
    $i++;
}
 
/* 例 4 */

for ($i = 1; $i <= 10; print $i, $i++) ;
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    もちろん、最初の例(もしくは 4番目の例)が最善であると考えられます。
    しかし、<literal>for</literal>ループにおいて空の式を使用できると、
    多くの場合、便利だということに気づかれるかと思います。
   </simpara>
   <para>
    PHPは、<literal>for</literal>ループ用に"コロン構文"もサポートします。
    <informalexample>
     <programlisting>
<![CDATA[
for (式1; 式2; 式3): 文; ...; endfor;
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    他の言語には、配列やハッシュを連続的に処理するために
    <literal>foreach</literal>文があります。PHP 3にはこうした
    構文はありません。PHP 4はこれをサポートしています。
    (<link linkend="control-structures.foreach">foreach</link>を参照下さい)
    PHP 3 では、同様の効果を得るために<link linkend="control-structures.while">
    while</link>文を<function>list</function>および<function>each</function>
    と組み合わせて使用します。
    例については、これらの関数に関するドキュメントを参照下さい。
   </para>
   
   </sect1>
 
   <sect1 id="control-structures.foreach">
    <title><literal>foreach</literal></title>
    <para>
    (PHP 3ではなく)PHP 4には、Perlや他の言語とよく似た
    <literal>foreach</literal>構文があります。これにより
    配列要素に関する反復処理が容易になります。この構造には、
    2種類の構文があります。2番目の構文はあまり知られていませんが、
    最初の構文の便利な拡張になっています。
    <informalexample>
     <programlisting>
<![CDATA[
foreach(array_expression as $value) 文
foreach(array_expression as $key => $value) 文
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    最初の形式は、<literal>array_expression</literal>で指定した配列に
    関してループ処理を行います。各ループにおいて現在の要素の値が
    <literal>$value</literal>に代入され、内部配列ポインタが一つ前に
    進められます。(よって、次のループでは次の要素を見ることになります。)
   </simpara>
   <simpara>
    2番目の形式も同様ですが、各ループで現在の要素のキーが変数
    <literal>$key</literal>に代入されるところが異なります。
   </simpara>
   <para>
    <note>
     <para>
      <literal>foreach</literal>の実行開始時に内部配列ポインタは、
      配列の先頭要素を指すように自動的にリセットされます。
      このため、<literal>foreach</literal>ループの前に
      <function>reset</function>をコールする必要はありません。
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      <literal>foreach</literal>は、指定した配列自体に対してではなく、
      そのコピーに対して処理を行うことに注意して下さい。このため、
      <function>each</function> 文のように配列のポインタ位置が変更され
      ることはなく、返される配列要素への変更は、元の配列には反映されま
      せん。
     </para>
    </note>
   </para>
   <note>
    <para>
     <literal>foreach</literal> は、'@' によりエラーメッセージ出力を抑
     制する機能をサポートしていません。
    </para>
   </note>
   <para>
    既にご存知かと思いますが、以下の文は機能的に等価です。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array("one", "two", "three");
reset ($arr);
while (list(, $value) = each ($arr)) {
    echo "Value: $value<br>\n";
}

foreach ($arr as $value) {
    echo "Value: $value<br>\n";
}
?>
]]>
     </programlisting>
    </informalexample>
    以下の文も機能的に等価です。
    <informalexample>
     <programlisting role="php">
<![CDATA[
reset ($arr);
while (list($key, $value) = each ($arr)) {
    echo "Key: $key; Value: $value<br>\n";
}
 
foreach ($arr as $key => $value) {
    echo "Key: $key; Value: $value<br>\n";
}
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    使用法を示すためにその他の例を示します。
    <informalexample>
     <programlisting role="php">
<![CDATA[
/* foreach の例 1: 値のみ */

$a = array (1, 2, 3, 17);
 
foreach ($a as $v) {
   print "Current value of \$a: $v.\n";
}
 
/* foreachの例2: 値 (説明用にキーを出力) */

$a = array (1, 2, 3, 17);

$i = 0; /* 説明用 */

foreach($a as $v) {
    print "\$a[$i] => $v.\n";
    $i++;
}
 
/* foreachの例3: キーと値 */

$a = array(
    "one" => 1,
    "two" => 2,
    "three" => 3,
    "seventeen" => 17
);
 
foreach($a as $k => $v) {
    print "\$a[$k] => $v.\n";
}

/* foreach の例4: 多次元配列 */

$a[0][0] = "a";
$a[0][1] = "b";
$a[1][0] = "y";
$a[1][1] = "z";

foreach($a as $v1) {
    foreach ($v1 as $v2) {
        print "$v2\n";
    }
}

/* foreach の例5: 動的配列 */

foreach(array(1, 2, 3, 4, 5) as $v) {
    print "$v\n";
}
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="control-structures.break">
   <title><literal>break</literal></title>
   <simpara>
    <literal>break</literal>は、現在実行中の
    <literal>for</literal>, <literal>foreach</literal>
    <literal>while</literal>, <literal>do..while</literal>,
    <literal>switch</literal>構造の実行を終了します。
   </simpara>
   <simpara>
    <literal>break</literal>では、オプションの引数で
    ネストしたループ構造を抜ける数を指定することができます。
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
$arr = array ('one', 'two', 'three', 'four', 'stop', 'five');
while (list (, $val) = each ($arr)) {
   if ($val == 'stop') {
      break;    /* ここでは、'break 1;'と書くこともできる。 */
   }
   echo "$val<br>\n";
}

/* オプション引数を使用する。 */
$i = 0;
while (++$i) {
    switch ($i) {
    case 5:
        echo "At 5<br>\n";
        break 1;  /* switch構造のみを抜ける */
    case 10:
        echo "At 10; quitting<br>\n";
        break 2;  /* switchとwhileを抜ける */
    default:
        break;
    }
}
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>
 
  <sect1 id="control-structures.continue">
   <title><literal>continue</literal></title>
   <simpara>
    <literal>continue</literal>は、ループ構造において現在の繰り返しループ
    の残りの処理をスキップし、次の繰り返しの最初から実行を続けるために
    使用されます、
   </simpara>
   <note>
    <simpara>
     <link linkend="control-structures.switch">switch</link> 
     命令はループ構造における<literal>continue</literal>の効果
     を考慮してつくられていることに留意してください。
    </simpara>
   </note>
   <simpara>
    <literal>continue</literal>では、オプションの引数で
    処理をスキップするループ構造のレベルの数を指定できます。
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
while (list ($key,$value) = each ($arr)) {
    if (!($key % 2)) { // キーが偶数の組をスキップ
        continue;
    }
    do_something_odd ($value);
}

$i = 0;
while ($i++ < 5) {
    echo "Outer<br>\n";
    while (1) {
        echo "&nbsp;&nbsp;Middle<br>\n";
        while (1) {
             echo "&nbsp;&nbsp;Inner<br>\n";
             continue 3;
        }
        echo "This never gets output.<br>\n";
    }
    echo "Neither does this.<br>\n";
}
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>
 
  <sect1 id="control-structures.switch">
   <title><literal>switch</literal></title>
   <simpara>
    <literal>switch</literal>文は、同じ式を用いてIF文を並べたのに似ています。
    同じ変数を異なる値と比較し、値に応じて異なったコードを実行したいと
    思うことがしばしばあるかと思います。   
    <literal>switch</literal>文は、まさにこのためにあるのです。
   </simpara>
   <note>
    <simpara>
     Note that unlike some other languages, the
     <link linkend="control-structures.continue">continue</link> statement
     applies to switch and acts similar to <literal>break</literal>.  If you
     have a switch inside a loop and wish to continue to the next iteration of
     the outer loop, use <literal>continue 2</literal>.
    </simpara>
   </note>
   <para>
    次の二つの例は、同じことを二つの異なった方法で書いたものです。
    一つは、<literal>if</literal>文を、もう一つは<literal>switch</literal> 
    文を使っています。
    <informalexample>
     <programlisting role="php">
<![CDATA[
if ($i == 0) {
   print "iは0に等しい";
}
if ($i == 1) {
   print "iは1に等しい";
}
if ($i == 2) {
   print "iは2に等しい";
}

switch ($i) {
    case 0:
        print "iは0に等しい";
        break;
    case 1:
        print "iは1に等しい";
        break;
    case 2:
        print "iは2に等しい";
        break;
}
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    失敗を避けるために<literal>switch</literal>文がどのように実行されるのかを
    理解することが重要です。
    <literal>switch</literal>文は、行毎に実行されます。
    (実際には、文毎に実行されます。)初めは、何も実行しません。        
    <literal>switch</literal>式の値と一致する値を有する
    <literal>case</literal>文が見つけられたときに初めてPHにより
    命令の実行が行われます。
    PHPは<literal>switch</literal>ブロックの終わりまたは最初の
    <literal>break</literal>文まで実行を続けます。
    CASE文の終わりに<literal>break</literal>文を書かない場合は、PHPは
    次のCASE文を実行しつづけます。例えば、
     <informalexample>
      <programlisting role="php">
<![CDATA[
switch ($i) {
    case 0:
        print "iは0に等しい";
    case 1:
        print "iは1に等しい";
    case 2:
        print "iは2に等しい";
}
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    ここで、$iが0に等しい場合は、PHPは全ての文を出力してしまいます!
    $iが1の場合、PHPは最後の二つの文を出力します。
    $iが2に等しい場合のみ、'期待した'動作をし、'iは2に等しい'と表示します。
    このため、(ある種の状況下では、BREAKを付加することを避けたいと
    思うかもしれませんが、)   
    <literal>break</literal>文を忘れないようにすることが重要です。
   </simpara>
   <simpara>
    <literal>switch</literal>文では、条件は1度だけ評価され、
    その結果が各<literal>case</literal>文と比較されます。
    <literal>elseif</literal>文では、条件は、再度評価されます。
    使用する条件が単純な比較処理よりも複雑な処理を行ったり、
    重い繰り返し処理を行う場合、<literal>switch</literal>の方が
    より処理が速い可能性があります。
   </simpara>
   <para>
    caseに付随する文は、空とすることが可能です。
    この場合、次のcaseに付随する文に制御が移行します。
    <informalexample>
     <programlisting role="php">
<![CDATA[
switch ($i) {
    case 0:
    case 1:
    case 2:
        print "iは3より小さいですが負ではありません";
        break;
    case 3:
        print "iは3です";
}
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    <literal>default</literal>は、case文の特別な場合です。これは他の全てのcaseに
    マッチしない場合に実行され、最後の <literal>case</literal> 文に置
    く必要があります。例を以下に示します。
    <informalexample>
     <programlisting role="php">
<![CDATA[
switch ($i) {
    case 0:
        print "iは0に等しい";
        break;
    case 1:
        print "iは1に等しい";
        break;
    case 2:
        print "iは2に等しい";
        break;
    default:
        print "iは0,1,2に等しくない";
}
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    <literal>case</literal>式は、スカラー型に式を評価する
    任意の式、つまり、整数、浮動小数点、文字列とすることができます。
    配列又はオブジェクトは、単純な型にキャストされていない限り
    使用することができません。
   </para>
   <para>
    switch文の制御構造に関する別の構文がサポートされています。
    詳細は、<link linkend="control-structures.alternative-syntax">
    制御構造に関する別の構文</link>を参照下さい。
  
    <informalexample>
     <programlisting role="php">
<![CDATA[
switch ($i):
    case 0:
        print "iは0に等しい";
        break;
    case 1:
        print "iは1に等しい";
        break;
    case 2:
        print "iは2に等しい";
        break;
    default:
        print "iは0でも1でも2でもない";
endswitch;
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="control-structures.declare">
   <title><literal>declare</literal></title>
   <para>
    <literal>declare</literal> 命令は、あるコードブロックの中に
    実効命令をセットするために使用されます。<literal>declare</literal>
    の文法は他の制御構造と似ています。
    <informalexample>
     <programlisting>
<![CDATA[
declare (命令) 文
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    <literal>命令</literal>の箇所で、セットされた<literal>
    declare</literal>ブロックの挙動を指定することが出来ます。
    現在のところ、使用できる命令は<literal>ticks</literal>の
    一つだけです。(<link linkend="control-structures.declare.ticks">
    ticks</link>に関しては以下を参照してください)
   </para>
   <para>
    <literal>declare</literal>ブロックの<literal>文</literal>
    の実行のされ方や実行時にどのような作用が起こるかについては
    <literal>命令</literal>に何が指定されたかに依存します。
   </para>
   <para>
    <literal>declare</literal>構造はグローバルスコープしても使用され、
    それはそれ以降のコード上の全てにおいて影響します。
    <informalexample>
     <programlisting>
<![CDATA[
<?php
// 以下は同じです:

// you can use this:
declare(ticks=1) {
    // ここに全てのスクリプトを書く
}

// or you can use this:
declare(ticks=1);
    // ここに全てのスクリプトを書く
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  <sect2 id="control-structures.declare.ticks">
   <title>ticks</title>
   <para>
    tickとは<literal>declare</literal>ブロックの実行中にパーサが
    <replaceable>N</replaceable>個の低レベル命令を実行するごとに
    発生するイベントのことです。<replaceable>N</replaceable>の値は
    <literal>declare</literal>ブロックの<literal>命令</literal>の箇所で
    <literal>ticks=<replaceable>N</replaceable></literal>のように
    指定します。
   </para>
   <para>
    tickごとに発生させるイベントは<function>register_tick_function</function>
    を使用して指定します。詳細は以下の例を参照してください。1回のtickで
    複数のイベントが起こり得ることに注意してください。
   </para>
   <para>
    <example>
     <title>PHPのコードの一部をプロファイルする</title>
     <programlisting role="php">
<![CDATA[
<pre>
<?php
// 呼び出されるとその時間を記録する関数
function profile ($dump = FALSE)
{
    static $profile;

    // 格納されたプロファイルを返し、その値を削除する
    if ($dump) {
        $temp = $profile;
        unset ($profile);
        return ($temp);
    }

    $profile[] = microtime ();
}

// tickハンドラの設定
register_tick_function("profile");

// declareブロックの前で初期化しておく
profile ();

// 2命令ごとにtickを投げるように設定しブロックを実行する
declare (ticks=2) {
    for ($x = 1; $x < 50; ++$x) {
        echo similar_text (md5($x), md5($x*$x)), "<br>";
    }
}

// プロファイラに格納されたデータを表示する
print_r (profile (TRUE));
?>
</pre>
]]>
     </programlisting>
    </example>
    この例では、'declare'ブロックのコード中で2個の低レベル
    命令が実行されるごとにその時間を記録してプロファイルを
    行っています。この情報はコードのあるセクションの中で
    遅い箇所を探すのに使用できます。この処理は他の手法でも
    使用できます。ticksを使用することで実装が簡単になる
    場合が多々あるのです。
   </para>
   <simpara>
    ticksはデバッグ、単純なマルチタスク処理、バックグラウンドI/Oや
    その他多くの処理を実装するのに便利です。
   </simpara>
   <simpara>
    <function>register_tick_function</function>と
    <function>unregister_tick_function</function>も参照してください。
   </simpara>
   </sect2>
  </sect1>

  <sect1 id="function.return">
   <title>return</title>
   <simpara>
    関数内で呼び出されると、<function>return</function>文は即座に
    その関数の実行を停止し、引数を関数の値として返します。
    <function>return</function>はまた、<function>eval</function>文や
    スクリプト自体の実行を終了させることが出来ます。
   </simpara>
   <simpara>
    グローバルスコープで呼び出されると、現在実行中のスクリプトが終了
    します。もしそのスクリプトが<function>include</function>もしくは
    <function>require</function>されたものである場合、制御は呼び出し元
    のファイルに戻ります。また、そのスクリプトが<function>include</function>
    されたものである場合は、<function>return</function>に与えられた引数
    の値は<function>include</function>の戻り値となります。
    <function>return</function>がメインスクリプトで呼び出された場合は
    スクリプトが終了します。また、<link linkend="configuration.file">
    設定ファイル</link>の<link linkend="ini.auto-prepend-file">
    auto_prepend_file</link> 又は <link linkend="ini.auto-append-file">
    auto_append_file</link>オプションで指定されたスクリプトの場合も
    同様にそのスクリプトが終了します。
   </simpara>
   <simpara>
    さらに詳しい情報に関しては<link linkend="functions.returning-values">
    返り値</link>を参照してください。
   </simpara>
   <note>
    <simpara>
     <function>return</function>は関数ではなく言語構造であるため引数を
     括弧で囲う必要はありません。実際に、括弧を使用しない記法の方がより
     一般的ですし、どちらにせよ何ら問題はありません。
    </simpara>
   </note>
  </sect1>
 
  <sect1 id="function.require">
   <title><function>require</function></title>

   <simpara>
    <function>require</function>文は指定されたファイルを読み込み、評価します。
    ファイルが読み込まれ評価される際の詳細な情報に関しては
    <function>include</function>に記述されています。
   </simpara>
   <simpara>
    <function>require</function>と<function>include</function>は
    エラーの扱い方を除けば全く同様に振舞います。エラーが発生すると
    <function>include</function>は<link linkend="internal.e-warning">Warning
    </link>を出力しますが<function>require</function>を使用している場合は
    <link linkend="internal.e-error">Fatal Error</link>となります。
    言い換えると、指定されたファイルが無い場合に処理を停止したい場合は
    <function>require</function>を使用した方が良い、ということになります。
    <function>include</function>を使用すると、読み込むべきファイルが存在しない
    場合も処理が続行されます。<link linkend="ini.include-path">include_path
    </link>を適切に設定することも忘れないで下さい。
   </simpara>
   <para>
    <example>
     <title>基本的な<function>require</function>の例</title>
     <programlisting role="php">
<![CDATA[
<?php

require 'prepend.php';

require $somefile;

require ('somefile.txt');

?>
]]>
     </programlisting>
   </example>
   </para>
   <simpara>
    <function>include</function>のドキュメントにはさらに多くの例がありますので
    参照してください。
   </simpara>
   <note>
    <simpara>
     PHP 4.0.2以前での挙動は以下の様になっています: <function>require</function>は
     その行が実行される/されないにかかわらず常に指定されたファイルを読み込もうと
     します。従って条件文は<function>require</function>には影響を与えません。
     しかしながら、<function>require</function>がある行が実行されない場合、
     読み込まれるファイル内のコードは実行されません。同様に、ループ構造は
     <function>require</function>の動作には影響しません。読み込まれるファイル内の
     コードがループに依存している場合でも <function>require</function>は
     読み込みを一回しか行いません。 
    </simpara>
   </note>
   
   &note.language-construct;
   
   &warn.no-win32-fopen-wrapper;
   
   <simpara>
    <function>include</function>, <function>require_once</function>,
    <function>include_once</function>, <function>eval</function>, 
    <function>file</function>, <function>readfile</function>, 
    <function>virtual</function>, <link linkend="ini.include-path">include_path</link>
    も参照してください。
   </simpara>
  </sect1>

 <sect1 id="function.include">
   <title><function>include</function></title>
   <simpara>
    <function>include</function>文は指定されたファイルを読み込み、評価します。
   </simpara>
   <simpara>
    以下の記述内容は<function>require</function>にも当てはまります。これら2つの
    構文はエラーの扱い方を除けば、その振る舞いは全く同じです。エラーが発生すると
    <function>include</function>は<link linkend="internal.e-warning">Warning
    </link>を出力しますが<function>require</function>を使用している場合は
    <link linkend="internal.e-error">Fatal Error</link>となります。
    言い換えると、指定されたファイルが無い場合に処理を停止したい場合は
    <function>require</function>を使用した方が良い、ということになります。
    <function>include</function>を使用すると、読み込むべきファイルが存在しない
    場合も処理が続行されます。<link linkend="ini.include-path">include_path
    </link>を適切に設定することも忘れないで下さい。
   </simpara>
   <simpara>
    ファイルが読み込まれるとそのファイルに含まれるコードは、
    <function>include</function>もしくは<function>require</function>が実行された
    行の<link linkend="language.variables.scope">変数スコープ</link>を継承します。
    呼び出し側の行で利用可能である全ての変数は、読み込まれたファイル内で利用可能です。
   </simpara>
   <para>
     <example>
      <title>基本的な<function>include</function>の例</title>
      <programlisting role="php">
<![CDATA[
vars.php
<?php

$color = 'green';
$fruit = 'apple';

?>

test.php
<?php

echo "A $color $fruit"; // A

include 'vars.php';

echo "A $color $fruit"; // A green apple

?>
]]>
      </programlisting>
     </example>
   </para>
   <simpara>
    呼び出し側のファイルの関数定義の中で読み込みが行われ場合は、読み込まれる
    ファイルに含まれる全てのコードは、その関数内で定義されているものとして
    動作します。従って変数スコープのその関数のものが継承されます。
   </simpara>
   <para>
     <example>
     <title>関数内での読み込み</title>
      <programlisting role="php">
<![CDATA[
<?php

function foo()
{
global $color;

    include 'vars.php';

    echo "A $color $fruit";
}

/* vars.php は foo() のスコープを継承するため *
 * $fruit はこの関数の外では無効となります。  *
 * $color はglobalとして宣言されているため    *
 * 有効です。                                 */

foo();                    // A green apple
echo "A $color $fruit";   // A green

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    ファイルが読み込まれるときには、読み込まれるファイルの先頭で
    PHPモードを抜けてHTMLモードになり、最後に再びPHPモードに戻ります。
    このため、読み込むファイル中のPHPコードとして実行する必要がある
    コードは、<link linkend="language.basic-syntax.phpmode">
    有効なPHPの開始タグおよび終了タグ</link>で括る必要があります。
   </simpara>
   <simpara>
    "<link linkend="ini.allow-url-fopen">URL fopenラッパー</link>"が
    有効になっている場合(デフォルト設定では有効です)、ローカルなパス名
    の代わりにURL(HTTP経由)を用いて読み込むファイルを指定することが可能です。
    URLで指定されたサーバがファイルをPHPコードとして解釈することが
    出来る場合には、HTTP GETを使用してURLリクエストに引数を指定することが
    出来ます。これはファイルの読み込み云々やスコープの継承とは関係なく、
    ただ単純にスクリプトがリモートのサーバで実行されて結果がローカルの
    スクリプトに読み込まれる、というだけのことです。
   </simpara>
   &warn.no-win32-fopen-wrapper;
   <para>
    <example>
     <title>HTTP経由の<function>include</function></title>
     <programlisting role="php">
<![CDATA[
<?php

/* この例は www.example.com が.phpはPHPスクリプトとして扱い、.txtは通常の *
 * ファイルとして扱うように設定されていると仮定しています。また、ここでの *
 * '動作します'という言葉の意味は、変数$fooと$barが読み込まれる側のファイ *
 * ルで使用可能である、ということです。                                   */

// 動作しません: www.example.com では file.txt はPHPコードとして解釈されません。
include 'http://www.example.com/file.txt?foo=1&bar=2';

// 動作しません: 'file.php?foo=1&bar=2' という名前のファイルをローカルファイル
// システム上から探し出そうとします。
include 'file.php?foo=1&bar=2';

// 動作します。
include 'http://www.example.com/file.php?foo=1&bar=2';

$foo = 1;
$bar = 2;
include 'file.txt';  // Works.
include 'file.php';  // Works.

?>
]]>
     </programlisting>
    </example>
     <link linkend="features.remote-files">リモートファイル</link>,
     <function>fopen</function>, <function>file</function>も参照してください。
   </para>
   <para>
    <function>include</function>と<function>require</function>は特殊な
    言語構造であるため、条件構造内にある場合は命令ブロックとして
    括っておく必要があります。 
   </para>
   <para>
    <example>
     <title>include() と 条件ブロック</title>
     <programlisting role="php">
<![CDATA[
<?php

// これは誤っており希望した通りには動作しません。
if ($condition)
    include $file;
else
    include $other;


// これが正解です。
if ($condition) {
    include $file;
} else {
    include $other;
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    値の返し方: 読み込まれたファイル内では、ファイルの実行処理を終了し呼出側の
    スクリプトに戻るために<function>return</function>文を実行することが可能です。 
    同時に値を返すことや、通常の関数と同様に呼び出しの値を取得することも出来ます。
   </simpara>
   <note>
    <simpara>
     PHP 3では関数ブロック以外のブロック内でreturnを 使用することはできません。
     <function>return</function>が適用されるのは関数であり、ファイル全体ではありません。 
    </simpara>
   </note>
   <para>
    <example>
     <title><function>include</function>と<function>return</function>文</title>
      <programlisting role="php">
<![CDATA[
return.php
<?php

$var = 'PHP';

return $var;

?>

noreturn.php
<?php

$var = 'PHP';

?>

testreturns.php
<?php

$foo = include 'return.php';

echo $foo; // 'PHP'と出力されます

$bar = include 'noreturn.php';

echo $bar; // 1が出力されます

?>
]]>
      </programlisting>
    </example>
   </para>
   <simpara>
    読み込みが成功すると<literal>$bar</literal>の値は1となります。上の2つの例の違いに
    注目してください。最初の例では読み込まれるファイル側で<function>return</function>
    を使用し、もう一方では使用していません。ファイルを"読み込む"ための他の方法としては
    <function>fopen</function>や<function>file</function>、そして
    <function>include</function>を<link linkend="ref.outcontrol">出力制御関数</link>
    と共に使用する方法があります。
   </simpara>

   &note.language-construct;

   <simpara>
    <function>require</function>, <function>require_once</function>,
    <function>include_once</function>, <function>readfile</function>,
    <function>virtual</function>,
    <link linkend="ini.include-path">include_path</link>も参照してください。
   </simpara>

  </sect1>

  <sect1 id="function.require-once">
   <title><function>require_once</function></title>
   <para>
    <function>require_once</function>文は、スクリプトの実行中に指定された
    ファイルを読み込み、評価します。この振る舞いは<function>require</function>
    文と似ていて、唯一の違いは既にコードが読み込まれている場合には再度読み込まれる
    ことがないことです。この文がどのように動作するかについては
    <function>require</function>を参照してください。
   </para>
   <para>
    <function>require_once</function>は、スクリプトの実行時に同じファイ
    ルが複数回読み込まれ、評価される可能性がある場合に、関数の再定義や
    変数値の再代入といった問題を回避するために一回だけ読み込ませるため
    に使用します。
   </para>
   <para>
    <function>require_once</function>および
    <function>include_once</function>の使用例に関する他の例については、
    最新のPHPソースコード配布ファイルに含まれる
    <ulink url="&url.php.pear;">PEAR</ulink>のコードを参照下さい。
   </para>
   <note>
    <para>
     <function>require_once</function>はPHP 4.0.1pl2で追加されました。
    </para>
   </note>
  <note>
   <para>
    (Windowsのように)大文字小文字を区別しないオペレーティングシステムでは、
    <function>require_once</function>および
    <function>include_once</function>の動作が意図したものにならない
    可能性があるので注意して下さい。
    <example>
     <title>
      <function>require_once</function> は大文字小文字を区別します
     </title>
     <programlisting role="php">
<![CDATA[
require_once("a.php"); // a.phpを読み込みます
require_once("A.php"); // Windowsはこれもa.phpを読み込みます!
]]>
       </programlisting>
     </example>
    </para>
   </note>
   &warn.no-win32-fopen-wrapper;
   <para>
    <function>require</function>,
    <function>include</function>, <function>include_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function>,
    <function>virtual</function>も参照してください。
   </para>
  </sect1>
  
  <sect1 id="function.include-once">
   <title><function>include_once</function></title>
   <para>
    <function>include_once</function>命令は、スクリプトの実行時に指定
    したファイルを読み込み評価します。この動作は、
    <function>include</function>命令と似ていますが、ファイルからのコー
    ドが既に読み込まれている場合は、再度読み込まれないという重要な違い
    があります。その名が示す通り、ファイルは一度しか読み込まれません。
   </para>
   <para>
    <function>include_once</function>は、スクリプトの実行時に同じファイ
    ルが複数回読み込まれ、評価される可能性がある場合に、関数の再定義や
    変数値の再代入といった問題を回避するために一回だけ読み込ませるため
    に使用します。
   </para>
   <para>
    <function>require_once</function>および
    <function>include_once</function>の使用例に関する他の例については、
    最新のPHPソースコード配布ファイルに含まれる
    <ulink url="&url.php.pear;">PEAR</ulink>のコードを参照下さい。
   </para>
   <para>
     <function>include_once</function> は、PHP 4.0.1pl2で追加されまし
     た。
   </para>
  <note>
   <para>
    (Windowsのように)大文字小文字を区別しないオペレーティングシステムでは、
    <function>include_once</function>および
    <function>require_once</function>の動作が意図したものにならない
    可能性があるので注意して下さい。
    <example>
     <title>
      <function>include_once</function> は大文字小文字を区別します
     </title>
     <programlisting role="php">
<![CDATA[
include_once("a.php"); // a.phpを読み込みます
include_once("A.php"); // Windowsはこれもa.phpを読み込みます!
]]>
       </programlisting>
     </example>
    </para>
   </note>
   &warn.no-win32-fopen-wrapper;
   <para>
    <function>include</function>、<function>require</function>、
    <function>require_once</function>、
    <function>get_required_files</function>、
    <function>get_included_files</function>、
    <function>readfile</function>、<function>virtual</function>
    も参照して下さい。
   </para>
  </sect1>
 
 </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
