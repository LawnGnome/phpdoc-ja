<?xml version="1.0" encoding="utf-8"?>
 <chapter id="control-structures">
  <title>制御構造</title>

  <simpara>
   全てのPHPスクリプトは、一連の文からなります。
   文としては、代入、関数コール、ループ、条件文、そして、何もしない文(空の文)
   さえ使用することができます。
   文は、通常セミコロンで終了します。加えて、文は、中括弧によるグループ文で
   カプセル化することによりグループ化することが可能です。
   グループ文は、同時に文にもなります。
   本章では、様々な文の型が記述されています。
  </simpara>

  <sect1 id="control-structures.if">
   <title><literal>if</literal></title>
   <para>
    <literal>if</literal> 構文は、PHP を含む全ての言語において最も重要な
    機能の一つです。
    この構文は、命令の条件実行を可能にします。
    PHPでは、次のようなC言語に似た<literal>if</literal>構文が使用されます。
    <informalexample>
     <programlisting>
if (式)
    文
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    式のセクションで記述したように式は論理値で評価されます。
    <replaceable>式</replaceable>が&true;と評価された場合、
    PHPは文を実行します。&false;と評価された場合は、
    これを無視します。
   </simpara>
   <para>
    以下の例は、<replaceable>$a</replaceable>が<replaceable>$b</replaceable>
    より大きい場合、<computeroutput>aはbより大きい</computeroutput>
    を表示します。
    <informalexample>
     <programlisting role="php">
if ($a > $b)
    print "aはbより大きい";
     </programlisting>
    </informalexample>
   </para>
   <para>
    条件分岐させたい文が一つ以上ある場合もしばしばあります。
    もちろん、各々の文を<literal>if</literal> 文で括る必要はありません。
    代わりに、複数の文をグループ化することができます。
    例えば、このコードは、<replaceable>$a</replaceable>
    が<replaceable>$b</replaceable>よりも大きい場合に
    <computeroutput>aはbよりも大きい</computeroutput>を表示し、
    <replaceable>$a</replaceable>の値を<replaceable>$b</replaceable>に
    代入します。
    <informalexample>
     <programlisting role="php">
if ($a > $b) {
    print "aはbより大きい";
    $b = $a;
}
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    if文は、他の<literal>if</literal>文の中で無限に入れ子にできます。
    これは、プログラムの様々な部分の条件付実行について
    完全な柔軟性を提供します。
   </simpara>
  </sect1>

  <sect1 id="control-structures.else">
   <title><literal>else</literal></title>
   <para>
    ある条件が満たされている場合にある文を実行し、
    その条件が満たされていない場合に別の文を実行したいと考えた
    ことが度々あるかと思います。
    このために<literal>else</literal>があります。
    <literal>else</literal>は、<literal>if</literal>文における式の値が 
    &false;の場合にある文を
    実行するように<literal>if</literal>文を拡張します。     
    例えば、次のコードは、<replaceable>$a</replaceable>が
    <replaceable>$b</replaceable>よりも大きい場合に
    <computeroutput>aはbより大きい</computeroutput>と表示し、
    そうでない場合に、
    <computeroutput>aはbよりも大きくない</computeroutput>と表示します。
    <informalexample>
     <programlisting role="php">
if ($a > $b) {
    print "aはbよりも大きい";
} else {
    print "aはbよりも大きくない";
}
     </programlisting>
    </informalexample>
    
    <literal>else</literal> 文は、<literal>if</literal>式が
    &false;と評価された場合のみ実行されます。
    また、<literal>elseif</literal>式がある場合には、それも
    &false;と評価された場合にのみ実行されます。
    (<link linkend="control-structures.elseif">elseif</link>参照)

   </para>
  </sect1>
 
  <sect1 id="control-structures.elseif">
   <title><literal>elseif</literal></title>
   <para>
    <literal>elseif</literal>は、その名前から分かるように、<literal>if</literal>
    と<literal>else</literal>の組み合わせです。<literal>elseif</literal>は、
    <literal>else</literal>のように、元の<literal>if</literal>式の値が
    &false;の場合に別の文を実行するように<literal>if</literal> 
    文を拡張します。
    しかし、<literal>else</literal>とは異なり、<literal>elseif</literal>式が
    &true;の場合にのみ代わりの式を実行します。
    例えば、次のコードは、<computeroutput>aはbより大きい</computeroutput>、
    <computeroutput>aはbに等しい</computeroutput>、
    <computeroutput>aはbより小さい</computeroutput>を出力します。
    <informalexample>
     <programlisting role="php">
if ($a > $b) {
    print "aはbより大きい";
} elseif ($a == $b) {
    print "aはbと等しい";
} else {
    print "aはbより小さい";
}
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    複数の<literal>elseif</literal>を同じ<literal>if</literal>文の中で
    使用することができます。
    &true;と評価された最初の<literal>elseif</literal>式
    が実行されます。PHPでは、(単語二つで)'else if'と書くこともできます。
    動作は(一単語の) 'elseif'と同じです。文法的な意味はやや異なっています。
    (あなたが C 言語に詳しいとすると、C 言語のそれと同じ動作です。)
    しかし、最終的な両者の動作は全く同じです。
   </simpara>
   <simpara>
    <literal>elseif</literal>文は、前にある全ての<literal>if</literal>文と 
    <literal>elseif</literal>の値が&false;であり、
    カレントの<literal>elseif</literal>式の値が&true;である
    場合にのみ実行されます。
   </simpara>
  </sect1>
 
  <sect1 id="control-structures.alternative-syntax">
   <title>制御構造に関する別の構文</title>
   <para>
    PHPは、いくつかの制御構造、つまり、<literal>if</literal>、
    <literal>while</literal>、<literal>for</literal>、
    <literal>foreach</literal>、<literal>switch</literal>
    に関する別の構文を提供します。
    各構造において開き波括弧をコロン(:)、閉じ波括弧をそれぞれ
    <literal>endif;</literal>,<literal>endwhile;</literal>,
    <literal>endfor;</literal>,<literal>endforeach;</literal>,
    <literal>endswitch;</literal>に変更するのが
    別の構文の基本的な形式となります。
    <informalexample>
     <programlisting role="php">
 &lt;?php if ($a == 5): ?&gt;
 Aは5に等しい
 &lt;?php endif; ?&gt;
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    上の例では、HTMLブロック"A = 5"はこの構文で
    書かれた<literal>if</literal>文の内部で入れ子になっています。
    このHTMLブロックは、$aが5の場合にのみ表示されます。
   </simpara>
   <para>
    この方法は、<literal>else</literal>や<literal>elseif</literal>にも
    同様に適用することができます。
    次の例は、この形式で<literal>if</literal>文を<literal>elseif</literal> 
    および<literal>else</literal>と共に使用しています。
    <informalexample>
     <programlisting role="php">
if ($a == 5):
    print "aは5に等しい";
    print "...";
elseif ($a == 6):
    print "aは6に等しい";
    print "!!!";
else
    print "aは5でも6でもない";
endif;
     </programlisting>
    </informalexample>
   </para>
   <para>
    より多くの例を参照するには、
    <link linkend="control-structures.while">while</link>,
    <link linkend="control-structures.for">for</link>, 
    <link linkend="control-structures.if">if</link>も参照下さい。
   </para>
  </sect1>
 
  <sect1 id="control-structures.while">
   <title><literal>while</literal></title>
   <para>
    <literal>while</literal>ループは、PHPで最も簡単なタイプのループです。
    このループは、CのWHILEループと同様の動作をします。
    <literal>while</literal>ループの基本形は次のようになります。
    <informalexample>
     <programlisting>
while (式) 文
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    <literal>while</literal>文の意味は簡単です。
    <literal>while</literal>文は、式の値が&true;である間、
    入れ子の文を繰り返し実行することをPHPに指示します。
    式の値は各反復処理の開始時にチェックされるので、ループ内の文の実行により
    この値が代わった場合でもループ実行は各ループを終るまで終わりません。
    (PHPによるループ内の文の実行が1回分の反復に相当します)      
    <literal>while</literal>式の値が初めから&false;の
    場合は、内部の文は一回も実行されません。
   </simpara>
   <para>
    <literal>if</literal>文と同様に、波括弧で複数の文を囲うか、
    以下に示す別の構文を用いることにより、同じ<literal>while</literal>
    ループの中に複数の文をグループ化することができます。
    <informalexample>
     <programlisting>
while (式): 文 ... endwhile;
     </programlisting>
    </informalexample>
   </para>
   <para>
    次の例は同じです。両方共、1から10までの数を出力します。
    <informalexample>
     <programlisting>
/* 例 1 */
 
$i = 1;
while ($i &lt;= 10) {
    print $i++;  /* 出力される値は、足される前の
                    $iの値です。
                    (後置加算) */
}
 
/* 例 2 */
 
$i = 1;
while ($i &lt;= 10):
    print $i;
    $i++;
endwhile;
     </programlisting>
    </informalexample>
   </para>
  </sect1>
 
  <sect1 id="control-structures.do.while">
   <title><literal>do..while</literal></title>
   <simpara>
    <literal>do..while</literal>ループは、論理式のチェックが各反復の
    最初ではなく最後に行われること以外は、<literal>while</literal>ループと
    全く同じです。通常の<literal>while</literal>ループとの主な差は、
    <literal>do..while</literal>ループは最低1回の実行を保証されていることです。
    一方、通常の<literal>while</literal>ループは、実行されないかもしれません。
    (論理式は各反復の最初でチェックされるので、
    最初から値が&false;である場合はループの実行は
    すぐに終わります。)
   </simpara>
   <para>
    <literal>do..while</literal> ループの構文は次の一つのみです。
 
    <informalexample>
     <programlisting role="php">
$i = 0;
do {
    print $i;
} while ($i>0);
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    上記のループは必ず一度だけ実行されます。その原因は、最初の反復の後、
    論理値のチェックを行った際に値が&false;と
    なり($iは0より大きくない)、ループの実行が終了するためです。
   </simpara>
   <para>
    優れたCプログラマは、コードブロック中での実行中止が可能な
    <literal>do..while</literal>ループの別の使用法について熟知している
    かもしれません。
    これは、<literal>do..while</literal>(0)でコードを括り、
    <link linkend="control-structures.break"><literal>break</literal></link>
    文を使用する方法です。次のコードは、この方法の例を示しています。
    <informalexample>
     <programlisting role="php">
do {
    if ($i &lt; 5) {
        print "i は十分大きくはありません。";
        break;
    }
    $i *= $factor;
    if ($i &lt; $minimum_limit) {
        break;
    }
    print "iはOKです。";

    ...iを使った処理...

} while(0);
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    この例をすぐに理解できなかったり、全く理解できなかったりしても
    問題ありません。この'機能'を使用しなくても
    スクリプトコードを書くことができますし、強力なスクリプトでさえ
    作成することが可能です。
   </simpara>
  </sect1>
  
  <sect1 id="control-structures.for">
   <title><literal>for</literal></title>
   <para>
    <literal>for</literal> ループは、PHPで最も複雑なループです。
    <literal>for</literal> は、Cのforループと同様に動作します。
    <literal>for</literal>ループの構文は、次のようになります。
    <informalexample>
     <programlisting>
for (式1; 式2; 式3) 文
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    最初の式(<replaceable>式1</replaceable>)は、ループ開始時に無条件に
    評価(実行)されます。
   </simpara>
   <simpara>
    各繰り返しの開始時に、<replaceable>式2</replaceable>が評価されます。
    その式の値が&true;が場合、ループは継続され、括弧
    内の文が実行されます。値が&false;の場合、ループの
    実行は終了します。
   </simpara>
   <simpara>
    各繰り返しの後、<replaceable>式3</replaceable>が評価(実行)されます。
   </simpara>
   <simpara>
    各式は、空とすることができます。<replaceable>式2</replaceable>を空
    にすることは、無限実行ループを意味します。(PHPは、この状態をC言語
    のように暗黙の内に &true;とみなします)
    <literal>for</literal>論理式を使用するよりも条件付
    <link linkend="control-structures.break"><literal>break</literal></link>
    文によりループを終了させる方が好ましい場合には、この機能は思った
    ほど便利ではないかもしれません。
   </simpara>
   <para>
    次の例について考えてみましょう。以下の例は全て1～10までの数を表示します。
    <informalexample>
     <programlisting role="php">
/* 例 1 */
 
for ($i = 1; $i &lt;= 10; $i++) {
    print $i;
}
 
/* 例 2 */
 
for ($i = 1;;$i++) {
    if ($i &gt; 10) {
        break;
    }
    print $i;
}
 
/* 例 3 */
 
$i = 1;
for (;;) {
    if ($i &gt; 10) {
        break;
    }
    print $i;
    $i++;
}
 
/* 例 4 */

for ($i = 1; $i &lt;= 10; print $i, $i++) ;
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    もちろん、最初の例(もしくは 4番目の例)が最善であると考えられます。
    しかし、<literal>for</literal>ループにおいて空の式を使用できると、
    多くの場合、便利だということに気づかれるかと思います。
   </simpara>
   <para>
    PHPは、<literal>for</literal>ループ用に"コロン構文"もサポートします。
    <informalexample>
     <programlisting>
for (式1; 式2; 式3): 文; ...; endfor;
     </programlisting>
    </informalexample>
   </para>
   <para>
    他の言語には、配列やハッシュを連続的に処理するために
    <literal>foreach</literal>文があります。PHP 3にはこうした
    構文はありません。PHP 4はこれをサポートしています。
    (<link linkend="control-structures.foreach">foreach</link>を参照下さい)
    PHP 3 では、同様の効果を得るために<link linkend="control-structures.while">
    while</link>文を<function>list</function>および<function>each</function>
    と組み合わせて使用します。
    例については、これらの関数に関するドキュメントを参照下さい。
   </para>
   
   </sect1>
 
   <sect1 id="control-structures.foreach">
    <title><literal>foreach</literal></title>
    <para>
    (PHP 3ではなく)PHP 4には、Perlや他の言語とよく似た
    <literal>foreach</literal>構文があります。これにより
    配列要素に関する反復処理が容易になります。この構造には、
    2種類の構文があります。2番目の構文はあまり知られていませんが、
    最初の構文の便利な拡張になっています。
    <informalexample>
     <programlisting>
foreach(array_expression as $value) statement
foreach(array_expression as $key =&gt; $value) statement
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    最初の形式は、<literal>array_expression</literal>で指定した配列に
    関してループ処理を行います。各ループにおいて現在の要素の値が
    <literal>$value</literal>に代入され、内部配列ポインタが一つ前に
    進められます。(よって、次のループでは次の要素を見ることになります。)
   </simpara>
   <simpara>
    2番目の形式も同様ですが、各ループで現在の要素のキーが変数
    <literal>$key</literal>に代入されるところが異なります。
   </simpara>
   <para>
    <note>
     <para>
      <literal>foreach</literal>の実行開始時に内部配列ポインタは、
      配列の先頭要素を指すように自動的にリセットされます。
      このため、<literal>foreach</literal>ループの前に
      <function>reset</function>をコールする必要はありません。
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      <literal>foreach</literal>は、指定した配列自体に対してではなく、
      そのコピーに対して処理を行うことに注意して下さい。このため、
      <function>each</function> 文のように配列のポインタ位置が変更され
      ることはなく、返される配列要素への変更は、元の配列には反映されま
      せん。
     </para>
    </note>
   </para>
   <note>
    <para>
     <literal>foreach</literal> は、'@' によりエラーメッセージ出力を抑
     制する機能をサポートしていません。
    </para>
   </note>
   <para>
    既にご存知かと思いますが、以下の文は機能的に等価です。
    <informalexample>
     <programlisting role="php">
reset ($arr);
while (list(, $value) = each ($arr)) {
   echo "Value: $value&lt;br&gt;\n";
}
 
foreach ($arr as $value) {
   echo "Value: $value&lt;br&gt;\n";
}
     </programlisting>
    </informalexample>
    以下の文も機能的に等価です。
    <informalexample>
     <programlisting role="php">
reset ($arr);
while (list($key, $value) = each ($arr)) {
   echo "Key: $key; Value: $value&lt;br&gt;\n";
}
 
foreach ($arr as $key =&gt; $value) {
   echo "Key: $key; Value: $value&lt;br&gt;\n";
}
     </programlisting>
    </informalexample>
   </para>
   <para>
    使用法を示すためにその他の例を示します。
    <informalexample>
     <programlisting role="php">
/* foreach の例 1: 値のみ */

$a = array (1, 2, 3, 17);
 
foreach ($a as $v) {
   print "Current value of \$a: $v.\n";
}
 
/* foreachの例2: 値 (説明用にキーを出力) */

$a = array (1, 2, 3, 17);

$i = 0; /* 説明用 */

foreach($a as $v) {
   print "\$a[$i] =&gt; $v.\n";
}
 
/* foreachの例3: キーと値 */

$a = array(
   "one" =&gt; 1,
   "two" =&gt; 2,
   "three" =&gt; 3,
   "seventeen" =&gt; 17
);
 
foreach($a as $k =&gt; $v) {
   print "\$a[$k] =&gt; $v.\n";
}

/* foreach の例4: 多次元配列 */

$a[0][0] = "a";
$a[0][1] = "b";
$a[1][0] = "y";
$a[1][1] = "z";

foreach($a as $v1) {
    foreach ($v1 as $v2) {
        print "$v2\n";
    }
}

/* foreach の例5: 動的配列 */

foreach(array(1, 2, 3, 4, 5) as $v) {
    print "$v\n";
}
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="control-structures.break">
   <title><literal>break</literal></title>
   <simpara>
    <literal>break</literal>は、現在実行中の
    <literal>for</literal>, <literal>foreach</literal>
    <literal>while</literal>, <literal>do..while</literal>,
    <literal>switch</literal>構造の実行を終了します。
   </simpara>
   <simpara>
    <literal>break</literal>では、オプションの引数で
    ネストしたループ構造を抜ける数を指定することができます。
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
$arr = array ('one', 'two', 'three', 'four', 'stop', 'five');
while (list (, $val) = each ($arr)) {
   if ($val == 'stop') {
      break;    /* ここでは、'break 1;'と書くこともできる。 */
   }
   echo "$val&lt;br>\n";
}

/* オプション引数を使用する。 */
$i = 0;
while (++$i) {
    switch ($i) {
    case 5:
        echo "At 5&lt;br&gt;\n";
        break 1;  /* switch構造のみを抜ける */
    case 10:
        echo "At 10; quitting&lt;br&gt;\n";
        break 2;  /* switchとwhileを抜ける */
    default:
        break;
    }
}
     </programlisting>
    </informalexample>
   </para>
  </sect1>
 
  <sect1 id="control-structures.continue">
   <title><literal>continue</literal></title>
   <simpara>
    <literal>continue</literal>は、ループ構造において現在の繰り返しループ
    の残りの処理をスキップし、次の繰り返しの最初から実行を続けるために
    使用されます、
   </simpara>
   <simpara>
    <literal>continue</literal>では、オプションの引数で
    処理をスキップするループ構造のレベルの数を指定できます。
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
while (list ($key,$value) = each ($arr)) {
    if (!($key % 2)) { // キーが偶数の組をスキップ
        continue;
    }
    do_something_odd ($value);
}

$i = 0;
while ($i++ &lt; 5) {
    echo "Outer&lt;br&gt;\n";
    while (1) {
        echo "&nbsp;&nbsp;Middle&lt;br&gt;\n";
        while (1) {
             echo "&nbsp;&nbsp;Inner&lt;br&gt;\n";
             continue 3;
        }
        echo "This never gets output.&lt;br&gt;\n";
    }
    echo "Neither does this.&lt;br&gt;\n";
}
     </programlisting>
    </informalexample>
   </para>
  </sect1>
 
  <sect1 id="control-structures.switch">
   <title><literal>switch</literal></title>
   <simpara>
    <literal>switch</literal>文は、同じ式を用いてIF文を並べたのに似ています。
    同じ変数を異なる値と比較し、値に応じて異なったコードを実行したいと
    思うことがしばしばあるかと思います。   
    <literal>switch</literal>文は、まさにこのためにあるのです。
   </simpara>
   <para>
    次の二つの例は、同じことを二つの異なった方法で書いたものです。
    一つは、<literal>if</literal>文を、もう一つは<literal>switch</literal> 
    文を使っています。
    <informalexample>
     <programlisting role="php">
if ($i == 0) {
   print "iは0に等しい";
}
if ($i == 1) {
   print "iは1に等しい";
}
if ($i == 2) {
   print "iは2に等しい";
}

switch ($i) {
    case 0:
        print "iは0に等しい";
        break;
    case 1:
        print "iは1に等しい";
        break;
    case 2:
        print "iは2に等しい";
        break;
}
     </programlisting>
    </informalexample>
   </para>
   <para>
    失敗を避けるために<literal>switch</literal>文がどのように実行されるのかを
    理解することが重要です。
    <literal>switch</literal>文は、行毎に実行されます。
    (実際には、文毎に実行されます。)初めは、何も実行しません。        
    <literal>switch</literal>式の値と一致する値を有する
    <literal>case</literal>文が見つけられたときに初めてPHにより
    命令の実行が行われます。
    PHPは<literal>switch</literal>ブロックの終わりまたは最初の
    <literal>break</literal>文まで実行を続けます。
    CASE文の終わりに<literal>break</literal>文を書かない場合は、PHPは
    次のCASE文を実行しつづけます。例えば、
     <informalexample>
      <programlisting role="php">
switch ($i) {
    case 0:
        print "iは0に等しい";
    case 1:
        print "iは1に等しい";
    case 2:
        print "iは2に等しい";
}
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    ここで、$iが0に等しい場合は、PHPは全ての文を出力してしまいます!
    $iが1の場合、PHPは最後の二つの文を出力します。
    $iが2に等しい場合のみ、'期待した'動作をし、'iは2に等しい'と表示します。
    このため、(ある種の状況下では、BREAKを付加することを避けたいと
    思うかもしれませんが、)   
    <literal>break</literal>文を忘れないようにすることが重要です。
   </simpara>
   <simpara>
    <literal>switch</literal>文では、条件は1度だけ評価され、
    その結果が各<literal>case</literal>文と比較されます。
    <literal>elseif</literal>文では、条件は、再度評価されます。
    使用する条件が単純な比較処理よりも複雑な処理を行ったり、
    重い繰り返し処理を行う場合、<literal>switch</literal>の方が
    より処理が速い可能性があります。
   </simpara>
   <para>
    caseに付随する文は、空とすることが可能です。
    この場合、次のcaseに付随する文に制御が移行します。
    <informalexample>
     <programlisting role="php">
switch ($i) {
    case 0:
    case 1:
    case 2:
        print "iは3より小さいですが負ではありません";
        break;
    case 3:
        print "iは3です";
}
     </programlisting>
    </informalexample>
   </para>
   <para>
    defaultは、case文の特別な場合です。これは他の全てのcaseに
    マッチしない場合に実行され、最後の <literal>case</literal> 文に置
    く必要があります。例を以下に示します。
    <informalexample>
     <programlisting role="php">
switch ($i) {
    case 0:
        print "iは0に等しい";
        break;
    case 1:
        print "iは1に等しい";
        break;
    case 2:
        print "iは2に等しい";
        break;
    default:
        print "iは0,1,2に等しくない";
}
     </programlisting>
    </informalexample>
   </para>
   <para>
    <literal>case</literal>式は、スカラー型に式を評価する
    任意の式、つまり、整数、浮動小数点、文字列とすることができます。
    配列又はオブジェクトは、単純な型にキャストされていない限り
    使用することができません。
   </para>
   <para>
    switch文の制御構造に関する別の構文がサポートされています。
    詳細は、<link linkend="control-structures.alternative-syntax">
    制御構造に関する別の構文</link>を参照下さい。
  
    <informalexample>
     <programlisting role="php">
switch ($i):
    case 0:
        print "iは0に等しい";
        break;
    case 1:
        print "iは1に等しい";
        break;
    case 2:
        print "iは2に等しい";
        break;
    default:
        print "iは0でも1でも2でもない";
endswitch;
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="control-structures.declare">
   <title><literal>declare</literal></title>
   <simpara>
    <literal>declare</literal> 命令は、あるコードブロックの中のパーサ
    の状態を一時的に変更するために使用されます。以下に例を示します。
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
function tick()
{
    static $i;
    printf("[tick i=%d]\n", ++$i);
}

register_tick_function("tick");

declare (ticks = 2) {
    1; 2; 3;
}
     </programlisting>
    </informalexample>
    この例は、現在のパーサに実装されているパラメータ ticks を示してい
    ます。tick は、パーサにより実行される<replaceable>N</replaceable>
    個の低レベル命令毎に生じるイベントです。ただし、
    <replaceable>N</replaceable>は、<literal>declare</literal>命令で指
    定されます。上の例の出力は次のようになります。
    <computeroutput>[tick i=1]
[tick i=2]
    </computeroutput>
   </para>
   <simpara>
    ticks は、PHPでバックグラウンドIOやその他の多くの処理といった、簡
    単なマルチタスク処理を実装する際に便利です。
   </simpara>
   <simpara>
    <function>register_tick_function</function> および
    <function>unregister_tick_function</function>も参照下さい。
   </simpara>
  </sect1>
 
  <sect1 id="function.require">
   <title><literal>require</literal></title>
   <simpara>
    <literal>require</literal>文は、C言語のプリプロセッサの
    #include文の動作と非常に似ており、自分自身を指定したファイルの内容
    に置換します。
   </simpara>
   <simpara>
    "URL fopen ラッパー"がPHPで有効な場合(デフォルト設定では有効です)、
    ローカルなパス名の代わりにURLを用いて<function>require</function>
    されるファイルを指定することが可能です。詳細な情報については、
    <link linkend="features.remote-files">リモートファイル</link>と
    <function>fopen</function>を参照下さい。 
   </simpara>
   <simpara>
    ファイルの読み込みに関して注意すべき点としては、ファイルが
    <function>include</function>または<function>require</function>
    される際には、読み込まれるファイルの先頭でPHPモードから抜け
    HTMLモードになること、読み込み完了時にPHPモードに戻ることがあります。
    このため、読み込むファイル中のPHPコードとして実行する必要がある
    コードは、<link linkend="language.basic-syntax.phpmode">
     有効なPHPの開始タグおよび終了タグ </link>で括る必要があります。
   </simpara>
   <simpara>
    <function>require</function>は、実際にはPHPの関数ではなく、
    むしろ言語構造です。この文は、関数とは異なる規則に従っています。
    例えば、<function>require</function>はファイル内にある制御構造には影響
    を受けません。また、この文は値を返しません。
    よって、<function>require</function>コールから返り値を取得しようとすると
    パース時にエラーとなります。
   </simpara>
   <simpara>
    <function>include</function>と異なり、<function>require</function>は
    <emphasis>その行が実行されない場合でも</emphasis>
    <emphasis>常に</emphasis>指定されたファイルを読み込みます。
    条件に応じてファイルを読み込みたい場合には、<function>include</function>
    を使用して下さい。条件文は、<function>require</function>には
    影響しません。しかし、<function>require</function>がある行が実行
    されない場合、読み込まれるファイル内のコードは実行されません。
   </simpara>
   <simpara>
    同様に、ループ構造は<function>require</function>の動作には影響
    しません。読み込まれるファイル内のコードがループに依存している場合でも
    <function>require</function>は読み込みを一回しか行いません。
   </simpara>
   <para>
    これは、ループ構造の中に<literal>require</literal>文を置き、
    各ループ毎に別のファイルの内容を読み込むことができないことを意味します。
    これを行うには、<literal>include</literal>文を使用して下さい。
     <informalexample>
      <programlisting role="php">
require ('header.inc');
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    ファイルが<function>require</function>で読み込まれる際、そのファイ
    ルに含まれるコードは、<function>require</function>を実行する行の変
    数スコープを継承します。コールする側のファイルのその行で利用可能な
    全ての変数が、読み込まれたファイル内で利用可能です。コールする側の
    ファイルの関数内で<function>require</function>を行う場合、コールさ
    れるファイルに含まれる全てのコードは、その関数内で定義されているも
    のとして動作します。
   </simpara>
   <para>
    <function>require</function>で読み込まれたファイルが、fopen ラッパー
    を用いてHTTP経由でコールされた場合、そして、ターゲットのサーバーが
    そのターゲットファイルをPHPコードとして解釈する場合、変数は、
    HTTP GETを使用している場合と同様にURLリクエストとして
    <function>require</function>されたファイルに渡すことが可能です。
    直接的な記述ではありませんが、<function>require</function>でファイル
    を読み込むのと同様に親ファイルの変数スコープを継承します。
    スクリプトは、実際にはリモートサーバーで実行された後、結果はローカ
    ルスクリプトに読み込まれます。
    <informalexample>
     <programlisting role="php">
/* この例は、someserverで .php を処理するように設定されており、.txt に
 * ついては設定されていないことを仮定しています。また、ここでの'動作す
 * る'という意味は、変数 $varoneと$vartwoがrequire()で読み込まれたファ
 * イルで利用であることを意味します。*/

/* 動作しない; file.txt は、someserverで処理されない。 */
require ("http://someserver/file.txt?varone=1&amp;vartwo=2");

/* 動作しない; ローカルファイルシステムの'file.php?varone=1&amp;vartwo=2'
 *  という名前のファイルを探す。 */
require ("file.php?varone=1&amp;vartwo=2");               

/* 動作する。 */
require ("http://someserver/file.php?varone=1&amp;vartwo=2"); 

$varone = 1;
$vartwo = 2;
require ("file.txt");  /* 動作する。 */
require ("file.php");  /* 動作する。 */
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    PHP 3では、<function>require</function>されたファイルのグローバルス
    コープでのみ<function>require</function>されたファイル内で
    <literal>return</literal>文を実行することが可能です。
    ブロック内(括弧{}の中を意味します)では使用することはできません。
    しかし、PHP 4では、この機能は廃止されました。この機能が必要な場合、
    <function>include</function>を参照下さい。
   </simpara>
   <simpara>
    <function>include</function>, <function>require_once</function>,
    <function>include_once</function>, <function>readfile</function>,
    <function>virtual</function>も参照下さい。
   </simpara>
  </sect1>
 
  <sect1 id="function.include">
   <title><literal>include</literal></title>
   <simpara>
    <literal>include</literal>文は指定されたファイルを読み込み、
    評価します。
   </simpara>
   <simpara>
    "URL fopen ラッパー"がPHPで有効な場合(デフォルト設定では有効です)、
    ローカルなパス名の代わりにURLを用いて<function>include</function>
    されるファイルを指定することが可能です。詳細な情報については、
    <link linkend="features.remote-files">リモートファイル</link>と
    <function>fopen</function>を参照下さい。 
   </simpara>
   <simpara>
    ファイルの読み込みに関して注意すべき点としては、ファイルが
    <function>include</function>または<function>require</function>
    される際には、読み込まれるファイルの先頭でPHPモードから抜けてHTML
    モードになること、読み込み完了時にPHPモードに戻ることがあります。
    このため、読み込むファイル中のPHPコードとして実行する必要がある
    コードは、<link linkend="language.basic-syntax.phpmode">有効なPHP
    の開始タグおよび終了タグ </link>で括る必要があります。
   </simpara>
   <para>
    読み込み処理は<literal>include</literal>文を処理する度に行われます。
    このため、異なった複数のファイルを読み込むためにループ構造の中で
    <literal>include</literal>を使用することができます。
    <informalexample>
     <programlisting role="php">
$files = array ('first.inc', 'second.inc', 'third.inc');
for ($i = 0; $i &lt; count($files); $i++) {
    include $files[$i];
}
     </programlisting>
    </informalexample>
   </para>
   <para>
    <function>include</function>は<function>require</function>と異なり、
    include文が実行される度に再度評価されます。(そして、実行時に初めて
    評価されます。)一方、<function>require</function>文は、(条件式が
    &false;である<link linkend="control-structures.if">if</link>文の中に
    ある場合のように)読み込まれるファイルの内容が評価されるかによらず最
    初に処理された際に読み込まれるファイルで置換されます。
   </para>
   <para>
    <function>include</function>は特殊な言語構造なので、if構造内
    にある時には、命令ブロックとして括っておく必要があります。
    <informalexample>
     <programlisting role="php">
/* 以下は誤っており、希望通りに動作しません。 */
 
if ($condition)
    include($file);
else
    include($other);
 
/* 以下が正解です。 */
 
if ($condition) {
    include($file);
} else {
    include($other);
}
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    PHP 3およびPHP 4では共に<function>include</function>されたファイル内で
    ファイルの実行処理を終了し呼出側のスクリプトに戻るために
    <literal>return</literal>文を実行することが可能です。
    しかし、動作にはいくつかの違いがあります。まず、PHP 3では
    関数ブロック以外のブロック内で<literal>return</literal>を
    使用することはできません。PHP 3では、<literal>return</literal>
    が適用っMるのは関数であり、ファイル全体には適用できません。
    しかし、PHP 4ではこの制限はありません。また、PHP 4では
    <function>include</function>されたファイルから値を返すことが可能です。
    通常の関数と同様に<function>include</function>コールの値を
    取得できます。これは、PHP 3ではパース時にエラーとなります。
   </simpara>
   <example>
    <title>PHP 3とPHP 4における<function>include</function></title>
    <para>
     メインファイルと同じディレクトリに(<filename>test.inc</filename>
     という名前の)以下のファイルが存在すると仮定します。
     <programlisting role="php">
&lt;?php
echo "Before the return &lt;br&gt;\n";
if (1) {
    return 27;
}
echo "After the return &lt;br&gt;\n";
?&gt;
     </programlisting>
    </para>
    <para>
     メインファイル(<filename>main.html</filename>)に以下の文が含まれている
     仮定します。
     <programlisting role="php">
&lt;?php
$retval = include ('test.inc');
echo "File returned: '$retval'&lt;br&gt;\n";
?&gt;
     </programlisting>
    </para>
    <para>
     <filename>main.html</filename>がPHP 3でコールされた場合、
     2行目でパースエラーとなります。つまり、PHP 3では
     <function>include</function>の値を取得できないのです。
     しかし、PHP 4では、以下のような結果となります。
     <screen>
Before the return
File returned: '27'
     </screen>
    </para>
    <para>
     ここで、<filename>main.html</filename>を以下のように変えたと
     仮定しましょう。
     <programlisting role="php">
&lt;?php
include ('test.inc');
echo "Back in main.html&lt;br&gt;\n";
?&gt;
     </programlisting>
    </para>
    <para>
     PHP 4では、出力は次のようになります。
     <screen>
Before the return
Back in main.html
     </screen>
     しかし、PHP 3では出力は以下となります。
     <screen>
Before the return 
27Back in main.html

Parse error: parse error in /home/torben/public_html/phptest/main.html on line 5
     </screen>
    </para>
    <para>
     上のパースエラーは、<filename>test.inc</filename>内で
     <literal>return</literal>文が関数以外のブロックで括られている
     ためです。returnをブロックの外に移動すると、出力は次のようになります。
     <screen>
Before the return
27Back in main.html
     </screen>
    </para>
    <para>
     スプリアス'27'はPHP 3がファイルから<literal>return</literal>により
     値を返すことをサポートしていないことによるものです。
    </para>
   </example>
   <simpara>
    ファイルが<function>include</function>で読み込まれる際、そのファイ
    ルに含まれるコードは、<function>include</function>を実行する行の変
    数スコープを継承します。コールする側のファイルのその行で利用可能な
    全ての変数が、読み込まれたファイル内で利用可能です。コールする側の
    ファイルの関数内で<function>include</function>を行う場合、コールさ
    れるファイルに含まれる全てのコードは、その関数内で定義されているも
    のとして動作します。
   </simpara>
   <para>
    <function>include</function>で読み込まれたファイルが、fopen ラッパー
    を用いてHTTP経由でコールされた場合、そして、ターゲットのサーバーが
    そのターゲットファイルをPHPコードとして解釈する場合、変数は、
    HTTP GETを使用している場合と同様にURLリクエストとして
    <function>include</function>されたファイルに渡すことが可能です。
    直接的な記述ではありませんが、<function>include</function>でファイル
    を読み込むのと同様に親ファイルの変数スコープを継承します。
    スクリプトは、実際にはリモートサーバーで実行された後、結果はローカ
    ルスクリプトに読み込まれます。
    <informalexample>
     <programlisting role="php">
/* この例は、someserverで .php を処理するように設定されており、.txt に
 * ついては設定されていないことを仮定しています。また、ここでの'動作す
 * る'という意味は、変数 $varoneと$vartwoがinclude()で読み込まれたファ
 * イルで利用であることを意味します。*/

/* 動作せず; file.txt は someserverで処理されない。 */
include ("http://someserver/file.txt?varone=1&amp;vartwo=2");

/* 動作せず; ローカルファイルシステムの'file.php?varone=1&amp;vartwo=2'
 * という名前のファイルを探す。 */
include ("file.php?varone=1&amp;vartwo=2");               

/* 動作する。 */
include ("http://someserver/file.php?varone=1&amp;vartwo=2"); 

$varone = 1;
$vartwo = 2;
include ("file.txt");  /* 動作する。 */
include ("file.php");  /* 動作する。 */
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    <function>require</function>, <function>require_once</function>,
    <function>include_once</function>, <function>readfile</function>,
    <function>virtual</function>も参照下さい。
   </simpara>
  </sect1>

  <sect1 id="function.require-once">
   <title><function>require_once</function></title>
   <para>
    <function>require_once</function>命令は、C言語のプリプロセッサ
    <literal>#include</literal>の動作と全く同様にこの部分を指定したファ
    イルで置換し、この面では、<function>require</function>命令に似てい
    ます。主な違いは、読み込みの連鎖です。
    <function>require_once</function>を使用した場合、そのコードがスク
    リプトに読み込まれるのが一回だけであることが保証され、変数の値また
    は定義した関数の名前が壊されるのを回避します。
   </para>
   <para>
    例えば、<literal>utils.inc</literal>と
    <literal>foolib.inc</literal>という2つのファイルを作成するとしましょ
    う。
    <example>
     <title>utils.inc</title>
     <programlisting role="php">
&lt;?php
define("PHPVERSION", floor(phpversion()));
echo "GLOBALS ARE NICE\n";
function goodTea() {
	return "Oolong tea tastes good!";
}
?&gt;
     </programlisting>
    </example>
    <example>
     <title>foolib.inc</title>
     <programlisting role="php">
&lt;?php
require ("utils.inc");
function showVar($var) {
	if (PHPVERSION == 4) {
		print_r($var);
	} else {
		var_dump($var);
	}
}

// 他の関数の定義 ...
?&gt;
     </programlisting>
    </example>
    そして、この後、スクリプト
    <literal>cause_error_require.php</literal>を書いて下さい。
    <example>
     <title>cause_error_require.php</title>
     <programlisting role="php">
&lt;?php
require("foolib.inc");
/* 以下の処理は、エラーを発生します。 */
require("utils.inc");
$foo = array("1",array("complex","quaternion"));
echo "this is requiring utils.inc again which is also\n";
echo "required in foolib.inc\n";
echo "Running goodTea: ".goodTea()."\n";
echo "Printing foo: \n";
showVar($foo);
?&gt;
     </programlisting>
    </example>
    後の例を実行した場合、( PHP 4.01pl2を用いた)結果の出力は次のように
    なります。
	 <informalexample>
	 <programlisting>
GLOBALS ARE NICE
GLOBALS ARE NICE

Fatal error:  Cannot redeclare goodTea() in utils.inc on line 5
     </programlisting>
    </informalexample>
    <literal>foolib.inc</literal>および
    <literal>cause_errror_require.php</literal>を
    <function>require</function>の代わりに
    <function>require_once</function>を使用するように修正し、
    後の例のファイル名を
    <literal>avoid_error_require_once.php</literal>に変更すると
    次のようになります。
    <example>
     <title>foolib.inc (fixed)</title>
     <programlisting role="php">
...
require_once("utils.inc");
function showVar($var) {
...
     </programlisting>
    </example>
    <example>
     <title>avoid_error_require_once.php</title>
     <programlisting role="php">
...
require_once("foolib.inc");
require_once("utils.inc");
$foo = array("1",array("complex","quaternion"));
...
     </programlisting>
    </example>
    これを実行すると、(PHP 4.0.1pl2を用いた)出力は次のようになります。
    <informalexample>
     <programlisting>
GLOBALS ARE NICE
this is requiring globals.inc again which is also
required in foolib.inc
Running goodTea: Oolong tea tastes good!
Printing foo:
Array
(
    [0] =&gt; 1
    [1] =&gt; Array
        (
            [0] =&gt; complex
            [1] =&gt; quaternion
        )

)
     </programlisting>
    </informalexample>
   </para>
   <para>
    また、Cプリプロセッサの動作との類似にも注意して下さい。この命令は、
    "コンパイル時"、つまり、スクリプトがパースされた後で実行される前に
    実行され、実行時に動的に挿入される必要があるスクリプトの部分に使用
    するべきではありません。このような場合は、
    <function>include_once</function>または
    <function>include</function>を使用して下さい。
   </para>
   <para>
    <function>require_once</function>および
    <function>include_once</function>の他の例については、最新のPHPソー
    スコード配布ファイルに含まれるPEARのコードを参照下さい。
   </para>
   <para>
    <function>require</function>、<function>include</function>、
    <function>include_once</function>、
    <function>get_required_files</function>、
    <function>get_included_files</function>、
    <function>readfile</function>、<function>virtual</function>も参照
    下さい。
   </para>
  </sect1>
  
  <sect1 id="function.include-once">
   <title><function>include_once</function></title>
   <para>
    <function>include_once</function>命令は、スクリプトの実行時に指定
    したファイルを読み込み評価します。この動作は、
    <function>include</function>命令と似ていますが、ファイルからのコー
    ドが既に読み込まれている場合は、再度読み込まれないという重要な違い
    があります。
   </para>
   <para>
    <function>require_once</function>の説明で述べたように、
    <function>include_once</function>は、クリプトの実行時に同じファイ
    ルが複数回読み込まれ、評価される可能性がある場合に、関数の再定義や
    変数値の再代入といった問題を回避するために一回だけ読み込ませるため
    に使用します。
   </para>
   <para>
    <function>require_once</function>および
    <function>include_once</function>の使用例に関する他の例については、
    最新のPHPソースコード配布ファイルに含まれるPEARのコードを参照下さ
    い。
   </para>
   <para>
     <function>include_once</function> は、PHP 4.0.1pl2で追加されまし
     た。
   </para>
   <para>
    <function>require</function>、<function>include</function>、
    <function>require_once</function>、
    <function>get_required_files</function>、
    <function>get_included_files</function>、
    <function>readfile</function>、<function>virtual</function>も参照
    下さい。
   </para>
  </sect1>
 
 </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
