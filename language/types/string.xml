<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.3 $ -->
<!-- EN-Revision: 1.8 Maintainer: takagi Status: ready -->
<!-- CREDITS: hirokawa,shimooka -->
<sect1 xml:id="language.types.string">
 <title>文字列</title>

 <para>
  <type>string</type> は、文字が連結されたものです。PHP では、
  文字は 1 バイトと同じです。つまり、256 個の異なる文字を使用可能です。
  これは、PHP が Unicode をネイティブにサポートしていないことも意味します。
  いくつかの Unicode サポートについては<function>utf8_encode</function>
  および <function>utf8_decode</function> を参照してください。
 </para>

 <note>
  <simpara>
   文字列が非常に大きくなっても問題ありません。
   PHP に課せられる文字列のサイズの実用上の制限はありません。
   このため、長い文字列に関して恐れる必要は全くありません。
  </simpara>
 </note>

 <sect2 xml:id="language.types.string.syntax">
  <title>構文</title>

  <para>
   文字列リテラルは、4 つの異なる方法で指定することが可能です。
  </para>

  <itemizedlist>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.single">引用符</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.double">二重引用符</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.heredoc">ヒアドキュメント構文</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.nowdoc">nowdoc 構文</link>
     (PHP 5.3.0 以降)
    </simpara>
   </listitem>
  </itemizedlist>

  <sect3 xml:id="language.types.string.syntax.single">
   <title>引用符</title>

   <para>
    文字列を指定する最も簡単な方法は、引用符 (文字
    <literal>'</literal>) で括ることです。
   </para>

   <para>
    引用符をリテラルとして指定するには、多くの他の言語と同様にバックスラッシュ
    (<literal>\</literal>) でエスケープする必要があります。
    バックスラッシュを引用符の前または文字列の最後に置きたい場合は、
    二重にする必要があります。この他の文字をエスケープする場合には、
    バックスラッシュも出力されることに注意してください! このため、
    通常はバックスラッシュ自体をエスケープする必要はありません。
   </para>

   <note>
    <simpara>
     他の二つの構文と異なり、
     <link linkend="language.variables">変数</link>と特殊文字のエスケープシーケンスは、
     引用符 (シングルクオート) で括られた文字列にある場合には展開<emphasis>されません</emphasis>。
    </simpara>
   </note>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo 'this is a simple string';

echo 'You can also have embedded newlines in 
strings this way as it is
okay to do';

// 出力: Arnold once said: "I'll be back"
echo 'Arnold once said: "I\'ll be back"';

// 出力: You deleted C:\*.*?
echo 'You deleted C:\\*.*?';

// 出力: You deleted C:\*.*?
echo 'You deleted C:\*.*?';

// 出力: This will not expand: \n a newline
echo 'This will not expand: \n a newline';

// 出力: Variables do not $expand $either
echo 'Variables do not $expand $either';
?>
]]>
    </programlisting>
   </informalexample>

  </sect3>

  <sect3 xml:id="language.types.string.syntax.double">
   <title>二重引用符</title>

   <para>
    文字列が二重引用符 (") で括られた場合、
    PHP は、より多くの特殊文字のエスケープシーケンスを理解します。
   </para>

   <table>
    <title>エスケープされた文字</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>記述</entry>
       <entry>意味</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>\n</literal></entry>
       <entry>ラインフィード (LF またはアスキーの 0x0A (10))</entry>
      </row>
      <row>
       <entry><literal>\r</literal></entry>
       <entry>キャリッジリターン (CR またはアスキーの 0x0D (13))</entry>
      </row>
      <row>
       <entry><literal>\t</literal></entry>
       <entry>水平タブ (HT またはアスキーの 0x09 (9))</entry>
      </row>
      <row>
       <entry><literal>\v</literal></entry>
       <entry>垂直タブ (VT またはアスキーの 0x0B (11)) (PHP 5.2.5 以降)</entry>
      </row>
      <row>
       <entry><literal>\f</literal></entry>
       <entry>フォームフィード (FF またはアスキーの 0x0C (12)) (PHP 5.2.5 以降)</entry>
      </row>
      <row>
       <entry><literal>\\</literal></entry>
       <entry>バックスラッシュ</entry>
      </row>
      <row>
       <entry><literal>\$</literal></entry>
       <entry>ドル記号</entry>
      </row>
      <row>
       <entry><literal>\"</literal></entry>
       <entry>二重引用符</entry>
      </row>
      <row>
       <entry><literal>\[0-7]{1,3}</literal></entry>
       <entry>
        正規表現にマッチする文字シーケンスは、8 進数表記の 1 文字です。
       </entry>
      </row>
      <row>
       <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
       <entry>
        正規表現にマッチする文字シーケンスは、16 進数表記の 1 文字です。
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    繰り返しますが、この他の文字をエスケープしようとした場合には、
    バックスラッシュも出力されます!
    PHP 5.1.1 より前のバージョンでは、<literal>\{$var}</literal>
    のバックスラッシュは出力されません。
   </para>

   <para>
    しかし、二重引用符で括られた文字列で最も重要なのは、
    変数名が展開されるところです。詳細は、<link
    linkend="language.types.string.parsing">文字列のパース</link>を参照ください。
   </para>
  </sect3>
  
  <sect3 xml:id="language.types.string.syntax.heredoc">
   <title>ヒアドキュメント</title>

   <simpara>
    文字列を区切る別の方法としてヒアドキュメント構文 ("&lt;&lt;&lt;")
    があります。この場合、ある ID (と、それに続けて改行文字)
    を <literal>&lt;&lt;&lt;</literal>
    の後に指定し、文字列を置いた後で、同じ ID を括りを閉じるために置きます。
   </simpara>

   <simpara>
    終端 ID は、その行の最初のカラムから始める必要があります。
    使用するラベルは、PHP の他のラベルと同様の命名規則に従う必要があります。
    つまり、英数字およびアンダースコアのみを含み、
    数字でない文字またはアンダースコアで始まる必要があります。
   </simpara>
   
   <warning>
    <simpara>
     非常に重要なことですが、終端 ID がある行には、セミコロン
     (<literal>;</literal>) 以外の他の文字が含まれていてはならないことに注意しましょう。
     これは、特に ID はインデントしてはならないということ、
     セミコロンの前に空白やタブを付けてはいけないことを意味します。
     終端 ID の前の最初の文字は、使用するオペレーティングシステムで定義された
     改行である必要があることにも注意を要します。
     これは、例えば、Macintoshでは <literal>\r</literal> となります。
     最後の区切り文字 (たいていはその後にセミコロンが続きます)
     の後にもまた、改行を入れる必要があります。
    </simpara>

    <simpara>
     この規則が破られて終端 ID が "clean" でない場合、
     終端 ID と認識されず、PHP はさらに終端 ID を探し続けます。
     適当な終了 ID がみつからない場合、
     スクリプトの最終行でパースエラーが発生します。
    </simpara>

    <para>
     ヒアドキュメント構文を、クラスのメンバの初期化に用いることはできません。
     <link linkend="language.types.string.syntax.nowdoc">nowdoc</link>
     を使用しましょう。
    </para>

    <example>
     <title>間違った例</title>
     <programlisting role="php">
<![CDATA[
<?php
class foo {
    public $bar = <<<EOT
bar
EOT;
}
?>
]]>
     </programlisting>
    </example>
   </warning>

   <para>
    ヒアドキュメントは二重引用符を使用しませんが、
    二重引用符で括られた文字列と全く同様に動作します。
    しかし、この場合でも上記のリストでエスケープされたコードを使用することも可能です。
    変数は展開されますが、文字列の場合と同様に
    ヒアドキュメントの内部で複雑な変数を表わす場合には注意が必要です。
   </para>

   <example> 
    <title>ヒアドキュメントで文字列を括る例</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
Example of string
spanning multiple lines
using heredoc syntax.
EOD;

/* 変数を使用するより複雑な例 */
class foo
{
    var $foo;
    var $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo <<<EOT
My name is "$name". I am printing some $foo->foo.
Now, I am printing some {$foo->bar[1]}.
This should print a capital 'A': \x41
EOT;
?>
]]>
    </programlisting>
   </example>
   &example.outputs;
   <screen>
<![CDATA[
My name is "MyName". I am printing some foo.
Now I am printing some Bar2.
This should print a capital 'A': \x41]]></screen>

   <note>
    <para>
     ヒアドキュメントは PHP 4 で追加されました。
    </para>
   </note>

  </sect3>
  
  <sect3 xml:id="language.types.string.syntax.nowdoc">
   <title>Nowdoc</title>
   
   <para>
    Nowdoc はヒアドキュメントと似ていますが、
    ヒアドキュメントがダブルクォートで囲んだ文字列として扱われるのに対して、
    Nowdoc はシングルクォートで囲んだ文字列として扱われます。
    Nowdoc の使用方法はヒアドキュメントとほぼ同じですが、
    その中身について <emphasis>パース処理を行いません</emphasis>。
    PHP のコードや大量のテキストを埋め込む際に、
    エスケープが不要になるので便利です。この機能は、SGML の
    <literal>&lt;![CDATA[ ]]&gt;</literal>
    (ブロック内のテキストをパースしないことを宣言する)
    と同じようなものです。
   </para>
   
   <para>
    Nowdoc の書き方は、ヒアドキュメントと同じように
    <literal>&lt;&lt;&lt;</literal> を使用します。
    しかし、その後に続く識別子をシングルクォートで囲んで
    <literal>&lt;&lt;&lt;'EOT'</literal> のようにします。
    ヒアドキュメントの識別子に関する決まりがすべて Nowdoc
    の識別子にも当てはまります。特に終了識別子の書き方に関する決まりに注意しましょう。
   </para>
   
   <example>
    <title>Nowdoc による文字列のクォートの例</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = <<<'EOD'
Example of string
spanning multiple lines
using nowdoc syntax.
EOD;

/* 変数を使った、より複雑な例 */
class foo
{
    var $foo;
    var $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo <<<'EOT'
My name is "$name". I am printing some $foo->foo.
Now, I am printing some {$foo->bar[1]}.
This should not print a capital 'A': \x41
EOT;
?>
]]>
    </programlisting>
   </example>
   &example.outputs;
   <screen>
<![CDATA[
My name is "$name". I am printing some $foo->foo.
Now, I am printing some {$foo->bar[1]}.
This should not print a capital 'A': \x41]]></screen>
   
   <note>
    <para>
     ヒアドキュメントと異なり、Nowdoc は任意の静的データコンテキストで使用できます。
     典型的な使用例は、クラスのメンバーや定数の初期化です。
    </para>
    
    <example>
     <title>静的データの例</title>
     <programlisting role="php">
<![CDATA[
<?php
class foo {
    public $bar = <<<'EOT'
bar
EOT;
}
?>
]]>
     </programlisting>
    </example>
   </note>

   <note>
    <para>
     Nowdoc のサポートは PHP 5.3.0 で追加されました。
    </para>
   </note>
  </sect3>

  <sect3 xml:id="language.types.string.parsing">
   <title>変数のパース</title>

   <simpara>
    スクリプトが二重引用符で括られるかヒアドキュメントで指定された場合、
    その中の<link linkend="language.variables">変数</link>はパースされます。
   </simpara>

   <simpara>
    構文の型には、<link
    linkend="language.types.string.parsing.simple">単純な</link>構文と
    <link linkend="language.types.string.parsing.complex">複雑な
    </link>構文の 2 種類があります。簡単な構文は、最も一般的で便利です。
    この構文では、変数、配列値やオブジェクトのプロパティをパースすることが可能です。
   </simpara>

   <simpara>
    複雑な構文は、PHP 4 で導入されました。
    この構文は、式を波括弧で括ることにより認識されます。
   </simpara>

   <sect4 xml:id="language.types.string.parsing.simple">
    <title>簡単な構文</title>

    <simpara>
     ドル記号 (<literal>$</literal>) を見付けると、
     パーサは、有効な変数名を形成することが可能な最長のトークンを取得します。
     変数名の終りを明示的に指定したい場合は、変数名を波括弧で括ってください。
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$beer = 'Heineken';
echo "$beer's taste is great"; // 動作します。"'" は変数名として無効な文字です。
echo "He drunk some $beers";   // 動作しません。's' は、変数名として有効な文字です。
echo "He drunk some ${beer}s"; // 動作します。
echo "He drank some {$beer}s"; // 動作します。
?>
]]>
     </programlisting>
    </informalexample>

    <simpara>
     同様に、配列添字とオブジェクトのプロパティをパースすることも可能です。
     配列添字の場合、閉じ角括弧 (']') は添字の終りを意味し、
     オブジェクトのプロパティの場合、同じ規則が簡単な変数として適用されます。
     しかし、オブジェクトプロパティには、変数の場合のような手法はありません。
     
     <!-- XXX isn't &true; :(, this would be the trick
     Also, the same trick with curly-braces works if you
     want to limit the greediness of parsers.
     -->
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// これらの例は、文字列の内部で配列を使用する際のものです。
// 文字列の外部で使用する場合は、配列の文字列キーは常にクオート
// しましょう。また、{波括弧} も使用しないようにしましょう。

// すべてのエラーを表示するようにします。
error_reporting(E_ALL);

$fruits = array('strawberry' => 'red', 'banana' => 'yellow');

// シングルクオートの外では動作が異なることに注意してください。
echo "A banana is $fruits[banana].";

// 動作します。
echo "A banana is {$fruits['banana']}.";

// 動作しますが、以下に説明するように
// PHP はまず banana という名前の定数を探します。
echo "A banana is {$fruits[banana]}.";

// 動作しません。波括弧を使用しましょう。これはパースエラーとなります。
echo "A banana is $fruits['banana'].";

// 動作します。
echo "A banana is " . $fruits['banana'] . ".";

// 動作します。
echo "This square is $square->width meters broad.";

// 動作しません。解決策については、複雑な構文を参照ください。
echo "This square is $square->width00 centimeters broad.";
?>
]]>
<!-- XXX this won't work:
echo "This square is $square->{width}00 centimeters broad."; 
// XXX: php developers: it would be consequent to make this work.
// XXX: like the $obj->{expr} syntax outside a string works, 
// XXX: analogously to the ${expr} syntax for variable var's.
-->
     </programlisting>
    </informalexample>

    <simpara>
     より複雑な場合は、複雑な構文を使用する必要があります。
    </simpara>
   </sect4>

   <sect4 xml:id="language.types.string.parsing.complex">
    <title>複雑な (波括弧) 構文</title>

    <simpara>
     この構文が「複雑(complex)な構文」と呼ばれているのは、
     構文が複雑であるからではなく、
     この方法では複雑な式を含めることができるからです。
    </simpara>

    <simpara>
     事実、この構文により、文字列の中に名前空間内のあらゆる値を含めることが可能です。
     文字列の外側に置く場合と同様に式を書き、これを
     { と } の間に含めてください。'{' はエスケープすることができないため、
     この構文は $ が { のすぐ後に続く場合にのみ認識されます
     (リテラル "{$" を指定するには、"{\$" を使用してください)。
     以下のいくつかの例を見ると理解しやすくなるでしょう。
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// すべてのエラーを表示します
error_reporting(E_ALL);

$great = 'fantastic';

// うまく動作しません。出力: This is { fantastic}
echo "This is { $great}";

// うまく動作します。出力: This is fantastic
echo "This is {$great}";
echo "This is ${great}";

// 動作します
echo "This square is {$square->width}00 centimeters broad."; 

// 動作します
echo "This works: {$arr[4][3]}";

// これが動作しない理由は、文字列の外で $foo[bar]
// が動作しない理由と同じです。
// 言い換えると、これは動作するともいえます。しかし、
// PHP はまず最初に foo という名前の定数を探すため、
// E_NOTICE レベルのエラー(未定義の定数) となります。
echo "This is wrong: {$arr[foo][3]}"; 

// 動作します。多次元配列を使用する際は、
// 文字列の中では必ず配列を波括弧で囲むようにします。
echo "This works: {$arr['foo'][3]}";

// 動作します
echo "This works: " . $arr['foo'][3];

echo "You can even write {$obj->values[3]->name}";

echo "This is the value of the var named $name: {${$name}}";

echo "This is the value of the var named by the return value of getName(): {${getName()}}";

echo "This is the value of the var named by the return value of \$object->getName(): {${$object->getName()}}";
?>
]]>
<!-- maybe it's better to leave this out?? 
// this works, but i disencourage its use, since this is NOT 
// involving functions, rather than mere variables, arrays and objects.
$beer = 'Heineken';
echo "I'd like to have another {${ strrev('reeb') }}, hips";
 -->
     </programlisting>
    </informalexample>
    
    <note>
     <para>
      <literal>{$ }</literal> の内部における
      関数やメソッドのコールは、PHP 5 から動作します。
     </para>
    </note>

    <note>
     <para>
      文字列内での変数のパースは、文字列の連結に比べてよりメモリを消費します。
      メモリの使用量をできるだけ抑えた PHP スクリプトを書きたいのなら、
      変数のパースを用いるのではなく、連結演算子 (.) を使用しましょう。
     </para>
    </note>

   </sect4>
  </sect3>
  
  <sect3 xml:id="language.types.string.substr">
   <title>文字列への文字単位のアクセスと修正</title>

   <para>
    <varname>$str[42]</varname> のように、
    角括弧を使用してゼロから始まるオフセットを指定すると、
    文字列内の任意の文字にアクセスし、修正することが可能です。
    つまり、文字列を文字の配列として考えるわけです。
    波括弧の後に任意の文字をゼロから始まるオフセットで指定することにより、
    文字列内の文字にアクセス/修正することが可能です。
   </para>

   <note>
    <simpara>
     <varname>$str{42}</varname> のように波括弧を使用してアクセスすることも可能です。
     しかし、角括弧を使用する方法のほうが推奨されます。
     なぜなら、{波括弧} 形式は PHP 6 で廃止される予定だからです。
    </simpara>
   </note>

   <example>
    <title>文字列の例</title>
    <programlisting role="php">
<![CDATA[
<?php
// 文字列の最初の文字を取得します
$str = 'This is a test.';
$first = $str[0];

// 文字列の 3 番目の文字を取得します
$third = $str[2];

// 文字列の最後の文字を取得します
$str = 'This is still a test.';
$last = $str[strlen($str)-1]; 

// 文字列の最後の文字を変更します
$str = 'Look at the sea';
$str[strlen($str)-1] = 'e';

// {} を使用した、もうひとつの方法 (PHP 6 で廃止予定) です
$third = $str{2};

?>
]]>
    </programlisting>
   </example>

   <note>
    <para>
     その他の型の変数に対して <literal>[]</literal> や <literal>{}</literal>
     でアクセスすると、何もメッセージを出さずに単に &null; を返します。
    </para>
   </note>

  </sect3>
 </sect2><!-- end syntax -->

 <sect2 xml:id="language.types.string.useful-funcs">
  <title>便利な関数および演算子</title>

  <para>
   文字列は、'.' (ドット) 結合演算子で結合することが可能です。'+'
   (加算) 演算子はこの例では出てこないことに注意してください。詳細については
   <link linkend="language.operators.string">文字列演算子</link>
   を参照ください。
  </para>

  <para>
   文字列の修正を行う場合には、便利な関数がたくさん用意されています。
  </para>

  <simpara>
   一般的な関数については、<link linkend="ref.strings">文字列関数の節</link>
   を参照ください。高度な検索/置換を行う正規表現関数については
   <link linkend="ref.pcre">Perl</link> および
   <link linkend="ref.regex">POSIX 拡張</link> の 2 種類がありますが、
   それぞれの節を参照ください。
  </simpara>

  <simpara>
   <link linkend="ref.url">URL 文字列用関数</link>や文字列の暗号化/
   復号用の関数 (<link linkend="ref.mcrypt">mcrypt</link> および
   <link linkend="ref.mhash">mhash</link>) もあります。
  </simpara>

  <simpara>
   最後に、探しているものがまだ見付からない場合には、
   <link linkend="ref.ctype">文字型の関数</link>も参照ください。
  </simpara>
 </sect2>

 <sect2 xml:id="language.types.string.casting">
  <title>文字列への変換</title>
  
  <para>
   <literal>(string)</literal> キャストや <function>strval</function>
   関数を使って変数を文字列へ変換することができます。
   文字列型を必要とする式のスコープにおいて、文字列への変換は自動的に行われます。
   <function>echo</function> や <function>print</function> 関数を使うとき、
   あるいは可変変数を文字列を比較するときにこの自動変換が行われます。
   マニュアルの<link linkend="language.types">型</link> と
   <link linkend="language.types.type-juggling">型の相互変換</link>
   の項を読むとわかりやすいでしょう。
   <function>settype</function>も参照してください。
  </para>
  
  <para>
   <type>boolean</type> の &true; は文字列の <literal>"1"</literal> に、
   &false; は <literal>""</literal> (空文字列) に変換されます。
   これにより boolean と文字列の値を相互に変換することができます。
  </para>

  <para> 
   <type>integer</type> (整数) や浮動小数点数 (<type>float</type>) は
   その数値の数字として文字列に変換されます (指数の表記や浮動小数点数を含めて)。
   浮動小数点数は、指数表記
   (<literal>4.1E+6</literal>) を使用して変換されます。
  </para>

  <note>
   <para>
    小数点を表す文字は、スクリプトのロケール (LC_NUMERIC カテゴリ)
    によって決まります。
    <function>setlocale</function> を参照ください。
   </para>
  </note>

  <para>
   配列は常に <literal>"Array"</literal> という文字列に変換されるので、
   <type>array</type> の中を見るために <function>echo</function> や
   <function>print</function> を使ってダンプさせることはできません。
   一つの要素を見るためには、<literal>echo $arr['foo']</literal>
   のようにしてください。内容の全てをダンプ/見るためには以降の TIP をご覧ください。
  </para>

  <para>
   PHP 4 のオブジェクトは、常に <literal>"Object"</literal> という文字列に変換されます。
   デバッグ等のために <type>object</type> の内部の変数を出力するような場合には、
   以下をご覧ください。オブジェクトがなんという名前のクラスの
   インスタンスなのかを知るには <function>get_class</function> をご覧ください。
   PHP 5 以降では、もし存在すれば __toString() メソッドを使用します。
  </para>

  <para>
   リソースは常に <literal>"Resource id #1"</literal>
   という文字列に変換されます。<literal>1</literal> は実行中の
   PHP によって割り当てられる
   <type>resource</type> のユニークな番号です。
   リソースの型を知るためには <function>get_resource_type</function>
   を使用してください。
  </para>

  <para>
   &null; は常に空文字列に変換されます。
  </para>
  
  <para>
   以上に述べたように、配列、オブジェクト、リソースをプリントアウトしても
   その値に関する有益な情報を得られるわけではありません。
   デバッグのために値を出力するのによりよい方法が知りたければ、
   <function>print_r</function> や
   <function>var_dump</function> を参照ください。
  </para>
  
  <para>
   PHP 変数を恒久的に保存するための文字列に変換することもできます。
   この方法はシリアライゼーションと呼ばれ、
   <function>serialize</function> 関数によって実現できます。
   <link linkend="ref.wddx">WDDX</link> サポートを有効にして PHP
   をセットアップすれば、PHP 変数を XML 構造にシリアライズすることもできます。
  </para>
 </sect2>

 <sect2 xml:id="language.types.string.conversion">
  <title>文字列の数値への変換</title>

  <simpara>
   数値として文字列が評価された時、結果の値と型は次のように定義されます。
  </simpara>

  <simpara>
   文字列は、'.'、'e'、'E' のどれかが含まれている場合は
   <type>float</type>、それ以外は整数として評価されます。
  </simpara>

  <para>
   文字列の最初の部分により値が決まります。文字列が、
   有効な数値データから始まる場合、この値が使用されます。その他の場合、
   値は 0 (ゼロ) となります。有効な数値データは符号(オプション)の後に、
   1 つ以上の数字 (オプションとして小数点を 1 つ含む)、
   オプションとして指数部が続きます。指数部は 'e' または 'E' の後に
   1 つ以上の数字が続く形式です。
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$foo = 1 + "10.5";              // $foo は float です (11.5)
$foo = 1 + "-1.3e3";            // $foo は float です (-1299)
$foo = 1 + "bob-1.3e3";         // $foo は integer です (1)
$foo = 1 + "bob3";              // $foo は integer です (1)
$foo = 1 + "10 Small Pigs";     // $foo は integer です (11)
$foo = 1 + "10 Little Piggies"; // $foo は integer です (11)
$foo = "10.0 pigs " + 1;        // $foo は integer です (11)
$foo = "10.0 pigs " + 1.0;      // $foo は float です (11)
?>
]]>
   </programlisting>
  </informalexample>

  <simpara>
   この変換に関する詳細は、Unix のマニュアルページで
   strtod(3) を参照ください。
  </simpara>

  <para>
   本節の例を試したい場合、その例をカットアンドペーストしてから
   動作を確認するために次の行を挿入してください。
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
echo "\$foo==$foo; type is " . gettype ($foo) . "<br />\n";
?>
]]>
   </programlisting>
  </informalexample>

  <para>
   (C 言語で行われるように) 数値に変換することで
   一つの文字のコードを取得できると期待してはいけません。
   文字と文字コードを相互に変換するには <function>ord</function>
   および <function>chr</function> 関数を使用してください。
  </para>

 </sect2>
</sect1><!-- end string -->
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
