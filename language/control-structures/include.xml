<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.3 $ -->
<!-- EN-Revision: 1.4 Maintainer: takagi Status: ready -->

<sect1 xml:id="function.include" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title><function>include</function></title>
 <simpara>
  <function>include</function>文は指定されたファイルを読み込み、評価します。
 </simpara>
 <simpara>
  以下の記述内容は<function>require</function>にも当てはまります。これら2つの構文は、
  エラーの扱い方を除けば全く同様に振舞います。エラーが発生するとどちらも
  <link linkend="errorfunc.constants.errorlevels.e-warning">Warning</link> を出力しますが、
  <function>require</function> を使用している場合は
  <link linkend="errorfunc.constants.errorlevels.e-error">Fatal Error</link> となります。
  言い換えると、指定されたファイルが無い場合に処理を停止したい場合は
  <function>require</function> を使用した方が良い、ということになります。
  <function>include</function> を使用すると、
  読み込むべきファイルが存在しない場合も処理が続行されます。
  <link linkend="ini.include-path">include_path</link>
  を適切に設定することも忘れないでください。
  PHP 4.3.5 より前のバージョンでは include されたファイルにパースエラーが
  あっても処理が続行されましたが、それ以降のバージョンでは処理を停止します。
 </simpara>
 <simpara>
  読み込むファイルはまずカレントのワーキングディレクトリからの相対パスとしてinclude_path
  で探され、それから、カレントのスクリプトのディレクトリからの相対パスとしてinclude_path
  で探されます。
  例えば、include_pathが <literal>libraries</literal>で、カレントの
  ワーキングディレクトリが <filename class="directory">/www/</filename> の
  場合、<filename>include/a.php</filename> を読み込んで、そのファイルの中に
  <literal>include "b.php"</literal> と書いてあったとすると、
  <filename>b.php</filename> がまず
  <filename class="directory">/www/libraries</filename>で探され、その後、
  <filename class="directory">/www/include/</filename>で探されます。
  ファイル名が <literal>./</literal> あるいは
  <literal>../</literal> で始まっている場合は、
  それぞれカレントのワーキングディレクトリあるいはその親ディレクトリからの相対パスとして探されるのみとなります。
 </simpara>
 <simpara>
  ファイルが読み込まれるとそのファイルに含まれるコードは、
  <function>include</function>もしくは<function>require</function>が実行された
  行の<link linkend="language.variables.scope">変数スコープ</link>を継承します。
  呼び出し側の行で利用可能である全ての変数は、読み込まれたファイル内で利用可能です。
  しかし、読み込まれたファイル内で定義されている関数やクラスはすべて
  グローバルスコープとなります。
 </simpara>
 <para>
  <example>
   <title>基本的な<function>include</function>の例</title>
   <programlisting role="php">
<![CDATA[
vars.php
<?php

$color = 'green';
$fruit = 'apple';

?>

test.php
<?php

echo "A $color $fruit"; // A

include 'vars.php';

echo "A $color $fruit"; // A green apple

?>
]]>
   </programlisting>
  </example>
 </para>
 <simpara>
  呼び出し側のファイルの関数定義の中で読み込みが行われた場合は、
  読み込まれるファイルに含まれる全てのコードは、
  その関数内で定義されているものとして動作します。
  従って変数のスコープもその関数のものが継承されます。
  ただ <link
  linkend="language.constants.predefined">マジック定数</link>
  は例外で、これは読み込みを行う前にパーサが評価します。
 </simpara>
 <para>
  <example>
   <title>関数内での読み込み</title>
   <programlisting role="php">
<![CDATA[
<?php

function foo()
{
    global $color;

    include 'vars.php';

    echo "A $color $fruit";
}

/* vars.php は foo() のスコープを継承するため *
* $fruit はこの関数の外では無効となります。  *
* $color はglobalとして宣言されているため    *
* 有効です。                                 */

foo();                    // A green apple
echo "A $color $fruit";   // A green

?>
]]>
   </programlisting>
  </example>
 </para>
 <simpara>
  ファイルが読み込まれるときには、読み込まれるファイルの先頭で
  PHPモードを抜けてHTMLモードになり、最後に再びPHPモードに戻ります。
  このため、読み込むファイル中のPHPコードとして実行する必要がある
  コードは、<link linkend="language.basic-syntax.phpmode">
  有効なPHPの開始タグおよび終了タグ</link>で括る必要があります。
 </simpara>
 <simpara>
  "<link linkend="ini.allow-url-fopen">URL fopenラッパー</link>"が
  有効になっている場合(デフォルト設定では有効です)、ローカルなパス名
  の代わりにURL(HTTP経由)を用いて読み込むファイルを指定することが可能です。
  URLで指定されたサーバがファイルをPHPコードとして解釈することが
  出来る場合には、HTTP GETを使用してURLリクエストに引数を指定することが
  出来ます。これはファイルの読み込み云々やスコープの継承とは関係なく、
  ただ単純にスクリプトがリモートのサーバで実行されて結果がローカルの
  スクリプトに読み込まれる、というだけのことです。
 </simpara>
 &warn.no-win32-fopen-wrapper;
 <para>
  <example>
   <title>HTTP経由の<function>include</function></title>
   <programlisting role="php">
<![CDATA[
<?php

/* この例は www.example.com が.phpはPHPスクリプトとして扱い、.txtは通常の *
 * ファイルとして扱うように設定されていると仮定しています。また、ここでの *
 * '動作します'という言葉の意味は、変数$fooと$barが読み込まれる側のファイ *
 * ルで使用可能である、ということです。                                   */

// 動作しません: www.example.com では file.txt はPHPコードとして解釈されません。
include 'http://www.example.com/file.txt?foo=1&bar=2';

// 動作しません: 'file.php?foo=1&bar=2' という名前のファイルをローカルファイル
// システム上から探し出そうとします。
include 'file.php?foo=1&bar=2';

// 動作します。
include 'http://www.example.com/file.php?foo=1&bar=2';

$foo = 1;
$bar = 2;
include 'file.txt';  // 動作する
include 'file.php';  // 動作する

?>
]]>
   </programlisting>
  </example>
 </para>
 <warning>
  <title>セキュリティの警告</title>
  <para>
   リモートファイルはリモートサーバ上で実行されます（ファイルの拡張子や
   リモートサーバが PHP の実行を許可しているかどうかに依存します）が、
   有効な PHP スクリプトである必要があります。なぜならそれはローカル
   サーバ上で処理されるからです。もしリモートサーバ上で処理された結果が
   ほしいだけならば、<function>readfile</function> を使用するほうがよい
   でしょう。そうでなければ、リモートスクリプトが有効な期待通りのコードを
   生成していることを確認するため、注意を払うことが必要になります。
  </para>
 </warning>
 <para>
  <link linkend="features.remote-files">リモートファイル</link>,
  <function>fopen</function>, <function>file</function>も参照してください。
 </para>
 <simpara>
  値の返し方: 読み込まれたファイル内では、ファイルの実行処理を終了し呼出側の
  スクリプトに戻るために<function>return</function>文を実行することが可能です。
  読み込まれたファイルから値を返すことも可能です。
  通常の関数で行うのと同様にincludeコールの値を取得することができます。
  しかし、読み込まれたリモートファイル(ローカルファイルの場合も同様)の出力が、
  <link linkend="language.basic-syntax.phpmode">有効なPHPの開始／
   終了タグ</link>を有していない限り、リモートファイルを読み込む際に値を
  取得することはできません。
  必要な変数をこれらのタグの中で宣言することができ、これらの変数は
  ファイルが読み込まれた位置で使用可能となります。
 </simpara>
 <para>
  <function>include</function> は特別な言語構造であるため、
  引数の前後に括弧は不要です。
  返り値を比較する際には注意してください。
  <example>
   <title>インクルードの戻り値を比較する</title>
   <programlisting role="php">
<![CDATA[
<?php
// won't work, evaluated as include(('vars.php') == 'OK'), i.e. include('')
if (include('vars.php') == 'OK') {
    echo 'OK';
}

// works
if ((include 'vars.php') == 'OK') {
    echo 'OK';
}
?>
]]>
   </programlisting>
  </example>
 </para>
 <para>
  <example>
   <title><function>include</function>と<function>return</function>文</title>
   <programlisting role="php">
<![CDATA[
return.php
<?php

$var = 'PHP';

return $var;

?>

noreturn.php
<?php

$var = 'PHP';

?>

testreturns.php
<?php

$foo = include 'return.php';

echo $foo; // 'PHP'と出力されます

$bar = include 'noreturn.php';

echo $bar; // 1が出力されます

?>
]]>
   </programlisting>
  </example>
 </para>
 <simpara>
  読み込みが成功すると<literal>$bar</literal>の値は1となります。上の2つの例の違いに
  注目してください。最初の例では読み込まれるファイル側で<function>return</function>
  を使用し、もう一方では使用していません。
  ファイルが読み込めなかった場合、&false; が返され、
  <constant>E_WARNING</constant> が発生します。
 </simpara>
 <para>
  読み込まれるファイルで定義された関数がある場合、
  これらは、<function>return</function>の前後によらず
  メインファイルで使用できます。
  このファイルが二度読み込まれた場合、PHP 5は関数が定義済みであるため
  致命的なエラーを発生します。一方、PHP 4は
  <function>return</function>の後に定義された関数については、
  エラーを発生しません。
  ファイルが読み込み済みであるかどうかを調べ、
  読み込まれるファイルの内容を条件分岐で返すかわりに
  <function>include_once</function>を使用することを推奨します。
 </para>
 <simpara>
  PHP ファイルの内容を変数に "include する" もうひとつの方法は、
  <link linkend="ref.outcontrol">出力制御関数</link>
  を <function>include</function> とともに用いて
  出力をキャプチャすることです。たとえば、
 </simpara>
 <para>
  <example>
   <title>出力バッファリングを用い、 PHP ファイルの内容を文字列として読み込む</title>
   <programlisting role="php">
<![CDATA[
<?php
$string = get_include_contents('somefile.php');

function get_include_contents($filename) {
    if (is_file($filename)) {
        ob_start();
        include $filename;
        $contents = ob_get_contents();
        ob_end_clean();
        return $contents;
    }
    return false;
}

?>
]]>
   </programlisting>
  </example>
 </para>
 <para>
  スクリプト中で自動的にファイルをインクルードするには、&php.ini; の
  <link linkend="ini.auto-prepend-file">auto_prepend_file</link> および
  <link linkend="ini.auto-append-file">auto_append_file</link>
  オプションも参照ください。
 </para>

 &note.language-construct;

 <simpara>
  <function>require</function>, <function>require_once</function>,
  <function>include_once</function>, <function>get_included_files</function>,
  <function>readfile</function>, <function>virtual</function> および
  <link linkend="ini.include-path">include_path</link> も参照ください。
 </simpara>
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
