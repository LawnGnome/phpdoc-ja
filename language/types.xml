<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.44 $ -->
<!-- EN-Revision: 1.157 Maintainer: hirokawa Status: ready -->
<!-- CREDITS: takagi -->
 <chapter id="language.types">
  <title>型</title>
  
  <sect1 id="language.types.intro">
   <title>導入</title>
   
   <simpara>
    PHPは、8種類の基本型をサポートします。
   </simpara>

   <para>
    4種類のスカラー型:

    <itemizedlist>
     
     <listitem>
      <simpara>
       <type>論理値(boolean)</type>
      </simpara>
     </listitem>
     
     <listitem>
      <simpara>
       <type>整数(integer)</type>
      </simpara>
     </listitem>
     
     <listitem>
      <simpara>
       <type>float</type> (浮動小数点数, '<type>double</type>'も同じ)
      </simpara>
     </listitem>
     
     <listitem>
      <simpara>
       <type>文字列(string)</type>
      </simpara>
     </listitem>     
     
    </itemizedlist>
    
    2種類の複合型:

    <itemizedlist>
     
     <listitem>
      <simpara>
       <type>配列(array)</type>
      </simpara>
     </listitem>
     
     <listitem>
      <simpara>
       <type>オブジェクト(object)</type>
      </simpara>
     </listitem>
     
    </itemizedlist>
    
    そして、最後に2種類の特別な型:

    <itemizedlist>
     
     <listitem>
      <simpara>
       <type>リソース(resource)</type>
      </simpara>
     </listitem>
     
     <listitem>
      <simpara>
       <type>ヌル(NULL)</type>
      </simpara>
     </listitem>
     
    </itemizedlist>

    本マニュアルでは、可読性を向上させるため、以下のような<link
    linkend="language.pseudo-types">擬似的な型</link>も使用します。

    <itemizedlist>
     
     <listitem>
      <simpara>
       <type>mixed</type>
      </simpara>
     </listitem>
     
     <listitem>
      <simpara>
       <type>number</type>
      </simpara>
     </listitem>
     
     <listitem>
      <simpara>
       <type>callback</type>
      </simpara>
     </listitem>
     
    </itemizedlist>
    
    いくつかの場所で"double"型を使用していることに気付くかもしれません。
    doubleはfloatと同じと考えてください。2種類の名前が存在するのは歴史的
    な理由によるものです。
   </para>
  
   <simpara>
    変数の型は、基本的にプログラマによりセットされません。むしろ、その変
    数が使用される文の内容に応じてPHPにより実行時に決定されます。
   </simpara>
   <note>
    <simpara>
     もし<link linkend="language.expressions">式</link>の型と値を正確に
     知りたい場合は、<function>var_dump</function>関数を使用してください。
    </simpara>
    <para>
     単純にデバッグのために人間が読みやすい形で型を表示したい場合には
     <function>gettype</function>を使用してください。型をチェックする
     場合には<function>gettype</function>を使用しては<emphasis>いけません
     </emphasis>。<literal>is_<replaceable>type</replaceable></literal>
     関数を使用してください。いくつかの例を以下に示します。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$bool = TRUE;   // a boolean
$str  = "foo";  // a string
$int  = 12;     // an integer

echo gettype($bool); // prints out "boolean"
echo gettype($str);  // prints out "string"

// 数値であれば、4を足す
if (is_int($int)) {
    $int += 4;
}

// $bool が文字列であれば, それをprintする
// (そうでなければ何も出力されない)
if (is_string($bool)) {
    echo "String: $bool";
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </note>
   <simpara>
    ある変数の型を強制的に他の型に変換したい場合、変数を
    <link linkend="language.types.typecasting">キャスト</link> するか、
    <function>settype</function> 関数を使用します。
   </simpara>
   <simpara>
    変数は、その型に依存して異なった動作をする場合があることに
    注意してください。詳細な情報については、
    <link linkend="language.types.type-juggling">型の変換</link> のセ
    クションを参照ください。
    また<link linkend="types.comparisons">the type comparison tables</link>
    もご覧ください。さまざまな型の変数の比較に関する例があります。
   </simpara>
  </sect1>

  <sect1 id="language.types.boolean">
   <title>論理型(boolean)</title>
   
   <simpara>
    論理型は、最も簡単な型です。<type>boolean</type> は、真偽の値を表
    します。この値は、&true;または&false;のどちらかになります。
   </simpara>
   
   <note>
    <simpara>
     boolean型は、PHP 4で導入されました。
    </simpara>
   </note>
   
   <sect2 id="language.types.boolean.syntax">
    <title>構文</title>
    <para>
     booleanリテラルを指定するには、キーワード&true;
     または&false;を指定してください。両方とも大文字小
     文字に依存しません。
     <!-- technically they are just constants -->
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = True; // 値TRUEを$fooに代入する
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     通常、<type>boolean</type>型の値を返す<link
     linkend="language.operators">演算子</link>を使用してから、
     <link linkend="language.control-structures">制御構造</link>にその結果を渡
     します。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
// == は、boolean型を返す演算子
if ($action == "show_version") {
    echo "バージョンは1.23です。";
}

// これは冗長
if ($show_separators == TRUE) {
    echo "<hr>\n";
}

// 上の例は次のように簡単に書くことができます。
if ($show_separators) {
    echo "<hr>\n";
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
   
   <sect2 id="language.types.boolean.casting">
    <title>booleanへの変換</title>
    <simpara>
     <type>boolean</type>に明示的に変換を行うには、キャスト
     <literal>(bool)</literal> または <literal>(boolean)</literal> を
     使用します。しかし、演算子、関数、制御構造が<type>boolean</type>
     型の引数を必要とする場合には、値は自動的に変換されるため、多くの
     場合、キャストは不要です。
    </simpara>
    <simpara>
     <link linkend="language.types.type-juggling">型の相互変換</link>
     も参照ください。
    </simpara>
    
    <para>
     <type>boolean</type>に変換する場合、次の値は&false;とみなされます。
     
     <itemizedlist>
      <listitem>
       <simpara>
    <link linkend="language.types.boolean">boolean</link>の
    &false;
       </simpara>
      </listitem>
      <listitem>
       <simpara>
    <link linkend="language.types.integer">integer</link>の 0 (ゼ
    ロ)
       </simpara>

      </listitem>
      <listitem>
       <simpara>
    <link linkend="language.types.float">float</link>の
    0.0 (ゼロ) 
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        空の<link linkend="language.types.string">文字列</link>、
        および<link linkend="language.types.string">文字列</link>の
        "0"
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        ゼロを要素とする <link linkend="language.types.array">配列
        </link> 
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        ゼロを要素とする <link linkend="language.types.object">オブジェ
         クト</link> (PHP 4のみ)
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        特別な値 <link linkend="language.types.null">NULL</link> (値がセット
        されていない変数を含む)
       </simpara>
      </listitem>
     </itemizedlist>
       
     その他の値は全て&true;とみなされます。 (全ての
     <link linkend="language.types.resource">resource</link>を含みます。)
     <warning>
      <simpara>
         <literal>-1</literal> は、他のゼロでない数と同様に (正負によらず)
         &true; とみなされます。
      </simpara>
     </warning>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
var_dump((bool) "");        // bool(false)
var_dump((bool) 1);         // bool(true)
var_dump((bool) -2);        // bool(true)
var_dump((bool) "foo");     // bool(true)
var_dump((bool) 2.3e5);     // bool(true)
var_dump((bool) array(12)); // bool(true)
var_dump((bool) array());   // bool(false)
var_dump((bool) "false");   // bool(true)
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.types.integer">
   <title>整数</title>
   
   <simpara>
    <type>integer</type> は、Z = {..., -2, -1, 0, 1, 2, ...}という集合
    です。
   </simpara>
     
   <para>
    <link linkend="ref.gmp">任意精度整数 / GMP</link> および
    <link linkend="language.types.float">float</link>、
    <link linkend="ref.bc">任意精度整数 / BCMath</link>も参照ください。
   </para>

   <sect2 id="language.types.integer.syntax">
    <title>構文</title>
    <simpara>
     整数(integer)は、10進数(基底10)、16進数(基底16)、8進数(基底8)表記
     で指定可能です。オプションで、符号(-または+)を前に付けることが可
     能です。
    </simpara>
    <para>
     8進数表記を使用する場合、数の前に<literal>0</literal> (ゼロ)を付
     ける必要があります。また、16進数表記を使用するには、数の前に
     <literal>0x</literal>を付ける必要があります。
     <example>
      <title>整数リテラル</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = 1234; // 10進整数
$a = -123; // 負の数
$a = 0123; // 8進数 (10進数の83と等価)
$a = 0x1A; // 16進数 (10進数の26と等価)
?>
]]>
      </programlisting>
     </example>
     使用可能な整数リテラルの形式は以下のように定義されています。
     <informalexample>
      <programlisting>
<![CDATA[
decimal     : [1-9][0-9]*
            | 0

hexadecimal : 0[xX][0-9a-fA-F]+

octal       : 0[0-7]+

integer     : [+-]?decimal
            | [+-]?hexadecimal
            | [+-]?octal
]]>
      </programlisting>
     </informalexample>
     整数のサイズはプラットフォームに依存しますが、
     約20億(32ビット符号付)が一般的な値です。
     PHPは符号無し整数をサポートしていません。
    </para>
    <warning>
     <para>
       8 進数の整数値として不正な数字（例: 8 または 9）が渡された場合、
       数値の残りの部分は無視されます。
      <example>
       <title>おかしな 8 進数</title>
       <programlisting role="php">
<![CDATA[
<?php
var_dump(01090); // 010（8 進数）= 8（10 進数）
?>
]]>
       </programlisting>
      </example>
     </para>
    </warning>
   </sect2>
   
   <sect2 id="language.types.integer.overflow">
    <title>整数のオーバーフロー</title>
    <para>
     <type>integer</type>型の範囲外の数を指定した場合、かわりに
     <type>float</type>として解釈されます。また、結果が
     <type>integer</type>型の範囲外の数となるような計算を行うと
     <type>float</type>が代わりに返されます。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$large_number =  2147483647;
var_dump($large_number);
// 出力: int(2147483647)

$large_number =  2147483648;
var_dump($large_number);
// 出力: float(2147483648)

// 指定した16進表現整数を出力できない
var_dump( 0x100000000 );
// 出力: int(2147483647)

$million = 1000000;
$large_number =  50000 * $million;
var_dump($large_number);
// 出力: float(50000000000)
?>
]]>
      </programlisting>
     </informalexample>
     <warning>
      <simpara>
       不幸にして、過去のスクリプトエンジンにはバグがあり、負の数が
       含まれている場合に、常に正しく動作するわけではありませんでした。例えば、
       <literal>-50000 * $million</literal>を実行した場合、結果は、
       <literal>-429496728</literal>となりました。しかし、オペランドが共に
       正の場合は問題ありませんでした。
      </simpara>
      <simpara>
       この問題はPHP 4.1.0で解決されました。
      </simpara>
     </warning>
    </para>
    <para>
     PHPには整数の割り算はありません。<literal>1/2</literal>は<type>
      float</type>型の<literal>0.5</literal>になります。
     下方向の整数値に値を丸めるためにキャストを使用することができ、
     また、<function>round</function>関数を使用することもできます。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
var_dump(25/7);         // float(3.5714285714286) 
var_dump((int) (25/7)); // int(3)
var_dump(round(25/7));  // float(4) 
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
   
   <sect2 id="language.types.integer.casting">
    <title>整数への変換</title>
    <simpara>
     <type>integer</type> に値を明示的に変換するには、キャスト
     <literal>(int)</literal> または <literal>(integer)</literal>のど
     ちらかを使用してください。しかし、多くの場合、演算子、関数、制御構
     造が<type>integer</type> 引数を必要とする場合、値は自動的に変換さ
     れるため、キャストを使用する必要はありません。
     関数<function>intval</function>を用いて値を整数に変換することも可
     能です。
    </simpara>
    <simpara>
     <link linkend="language.types.type-juggling">型の相互変換</link>
     を参照ください。
    </simpara>
    
    <sect3 id="language.types.integer.casting.from-boolean">
     <title>
      <link linkend="language.types.boolean">booleans</link>から
     </title>
     <simpara>
      &false; は、<literal>0</literal> (ゼロ)となり、
      &true; は、<literal>1</literal>となります。
       </simpara>
    </sect3>
    
    <sect3 id="language.types.integer.casting.from-float">
     <title>
      <link linkend="language.types.float">浮動小数点数</link>から
     </title>
     <simpara>
      floatから整数に変換する場合、その数はゼロの方に丸められます。
     </simpara>
       
     <para>
      floatが整数の範囲(通常は <literal>+/- 2.15e+9 =
      2^31</literal>)を越える場合、結果は undefined となります。これは、
      そのfloatが正しい整数の結果を得るために十分な精度を得られなかっ
      たからです。この場合、警告も通知も発生しません!
     </para>
     
     <warning>
      <para>
       未知の端数を<type>integer</type>にキャストしないでください。この
       場合、予期しない結果となることがあります。
       <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo (int) ( (0.1+0.7) * 10 ); // 7が出力されます!
?>
]]>
    </programlisting>
       </informalexample>
       より詳細な情報については、<link linkend="warn.float-precision">
        floatの精度に関する注意</link>を参照ください。
      </para>
     </warning>
    </sect3>
    
    <sect3 id="language.types.integer.casting.from-string">
     <title>文字列から</title>
     <simpara>
      <link linkend="language.types.string.conversion">文字列変換
      </link>を参照ください。
     </simpara>
    </sect3>
    
    <sect3 id="language.types.integer.casting.from-other">
     <title>他の型から</title>
     <para>
      <caution>
       <simpara>
    整数への変換の動作は、他の型については定義されません。現在の
    動作は、その値がまず 
    <link linkend="language.types.boolean.casting">論理値に変換
     された</link>場合と同じです。しかし、この動作は予告なく変更
    されることがありえるので、これを前提にしていはいけません。
       </simpara>
      </caution>
     </para>
    </sect3>
   </sect2>
  </sect1>
  
  <sect1 id="language.types.float">
   <title>浮動小数点数</title>
   <para>
    ("float","double","実数"のような) フロート数は、次の構文により指定
    できます。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1.234; 
$b = 1.2e3; 
$c = 7E-10;
?>
]]>
     </programlisting>
    </informalexample>
    規約:
    <informalexample>
     <programlisting role="php">
<![CDATA[
LNUM          [0-9]+
DNUM          ([0-9]*[\.]{LNUM}) | ({LNUM}[\.][0-9]*)
EXPONENT_DNUM ( ({LNUM} | {DNUM}) [eE][+-]? {LNUM})
]]>
     </programlisting>
    </informalexample>
    floatの大きさはプラットフォーム依存です。ただし、通常はおよそ10
    進数で14桁の精度があり、最大値は ~1.8e308 (これは 64ビット IEEE
    フォーマットです)となります。
   </para>

   <warning id="warn.float-precision">
    <title>浮動小数点数の精度</title>
    <para>
     <literal>0.1</literal>や<literal>0.7</literal>のような
     簡単な小数表現も若干精度を失うことなく内部的な2進表現に変
     換することはできません。これにより、混乱する結果を生じることがあ
     ります。つまり、<literal>floor((0.1+0.7)*10)</literal> は
     予想される <literal>8</literal>の代わりに実際の内部表現の結果とし
     て<literal>7.9999999999...</literal>のようなものを結果として返し
     ます。
    </para>
    <para>
     これは、いくつかの分数は有限の桁数の小数点表記で正確に表現できな
     いという事実に関係しています。例えば、<literal>1/3</literal>の小
     数点表記は、<literal>0.3333333. . .</literal>となります。
    </para>
    <para>
     よって、小数の最後の桁を信用してはいかませんし、小数が等しいとい
     う比較を行ってはいけません。より高い精度が必要な場合には、
     <link linkend="ref.bc">任意精度数学関数</link>または
     <link linkend="ref.gmp">gmp</link>関数を代わりに使用してください。
    </para>
   </warning>

   <sect2 id="language.types.float.casting">
    <title>floatへの変換</title>
    <para>
     文字列型がどのようにして浮動小数点数に変換されるかに関する
     詳細な情報は<link linkend="language.types.string.conversion">文字列の
     数値型への変換</link>のセクションをご覧ください。
     そのほかの型の浮動小数点数への変換については、整数型への変換と同様です。
     詳細は<link linkend="language.types.integer.casting">整数型への変換</link>
     のセクションをご覧ください。
     PHP 5以降、オブジェクトをフロートに変換しようとした場合には、
     通知がスローされます。
    </para>
   </sect2>
  </sect1>
  
  <sect1 id="language.types.string">
   <title>文字列</title>
   <para>
    <type>string</type> は一連の文字です。PHPでは、文字は1バイトと同じ
    です。つまり、256個の異なる文字を使用可能です。これは、PHPは、
    Unicodeをネーティブにサポートしていないことも意味します。
    いくつかのUnicodeサポートについては<function>utf8_encode</function>
    および <function>utf8_decode</function>を参照してください。
   </para>
   <note>
    <simpara>
     文字列が非常に大きくなっても問題ありません。PHPに課せられる文字列
     のサイズの実用上の制限はありません。このため、長い文字列に関して
     恐れる必要は全くありません。
    </simpara>
   </note>
   <sect2 id="language.types.string.syntax">
    <title>構文</title>
    <para>
     文字列リテラルは、3つの異なる方法で指定することが可能です。
     <itemizedlist>

      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.single">引用符</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.double">二重引用符</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.heredoc">ヒアドキュ
        メント構文</link>
       </simpara>
      </listitem>

     </itemizedlist>
    </para>
    <sect3 id="language.types.string.syntax.single">
     <title>引用符</title>
     <para>
      文字列を指定する最も簡単な方法は、引用符(文字
      <literal>'</literal>)で括ることです。
     </para>
     <para>
      引用符をリテラルとして指定するには、多くの他の言語と同様にバック
      スラッシュ(<literal>\</literal>)でエスケープする必要があります。
      バックスラッシュを引用符の前または文字列の最後に置きたい場合は、
      2重にする必要があります。この他の文字をエスケープする場合には、
      バックスラッシュも出力されることに注意してください! このため、通常、
      バックスラッシュ自体をエスケープする必要はありません。
      <note>
       <simpara>
        PHP 3では、この場合、<literal>E_NOTICE</literal>レベルの警告が
    出力されます。
       </simpara>
      </note>
      <note>
       <simpara>
    他の二つの構文と異なり、
        <link linkend="language.variables">変数</link>と特殊文字のエス
        ケープシーケンスは、引用符(シングルクオート)で括られた文字列に
        ある場合には展開<emphasis>されません</emphasis>。
       </simpara>
      </note>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
echo 'this is a simple string';

echo 'You can also have embedded newlines in 
strings this way as it is
okay to do';

// Outputs: Arnold once said: "I'll be back"
echo 'Arnold once said: "I\'ll be back"';

// Outputs: You deleted C:\*.*?
echo 'You deleted C:\\*.*?';

// Outputs: You deleted C:\*.*?
echo 'You deleted C:\*.*?';

// Outputs: This will not expand: \n a newline
echo 'This will not expand: \n a newline';

// Outputs: Variables do not $expand $either
echo 'Variables do not $expand $either';
?>
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect3>
    <sect3 id="language.types.string.syntax.double">
     <title>2重引用符</title>
     <para>
      文字列が2重引用符(")で括られた場合, PHPはより多くの特殊文字のエ
      スケープシーケンスを理解します。
     </para>
     <table>
      <title>エスケープされた文字</title>
      <tgroup cols="2">
       <thead>
    <row>
     <entry>記述</entry>
     <entry>意味</entry>
    </row>
       </thead>
       <tbody>
    <row>
     <entry><literal>\n</literal></entry>
     <entry>ラインフィード(LFまたはアスキーの0x0A (10))</entry>
    </row>
    <row>
     <entry><literal>\r</literal></entry>
     <entry>キャリッジリターン (CRまたはアスキーの0x0D (13))</entry>
    </row>
    <row>
     <entry><literal>\t</literal></entry>
     <entry>水平タブ(HTまたはアスキーの0x09 (9))</entry>
    </row>
    <row>
     <entry><literal>\\</literal></entry>
     <entry>バックスラッシュ</entry>
    </row>
    <row>
     <entry><literal>\$</literal></entry>
     <entry>ドル記号</entry>
    </row>
    <row>
     <entry><literal>\"</literal></entry>
        <entry>2重引用符</entry>
    </row>
    <row>
     <entry><literal>\[0-7]{1,3}</literal></entry>
     <entry>
      正規表現にマッチする文字シーケンスは、8進数表記の1文字です。
        </entry>
    </row>
    <row>
     <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
     <entry>
      正規表現にマッチする文字シーケンスは、16進数表記の1文字です。
     </entry>
    </row>
       </tbody>
      </tgroup>
     </table>
     <para>
      繰り返しますが、この他の文字をエスケープしようとした場合には、
      バックスラッシュも出力されます!
      PHP 5.1.1 より前のバージョンでは、<literal>\{$var}</literal>
      のバックスラッシュは出力されません。
     </para>
     <para>
      しかし、二重引用符で括られた文字列で最も重要なのは、変数名が展開
      されるところです。詳細は、<link
      linkend="language.types.string.parsing">文字列のパース</link>を
      参照ください。
     </para>
    </sect3>

    <sect3 id="language.types.string.syntax.heredoc">
     <title>ヒアドキュメント</title>
     <simpara>
      文字列を区切る別の方法としてヒアドキュメント構文("&lt;&lt;&lt;")
      があります。この場合、あるIDを<literal>&lt;&lt;&lt;</literal>の後
      に指定し、文字列を置いた後で、同じIDを括りを閉じるために置きます。
     </simpara>
     <simpara>
      終端IDは、その行の最初のカラムから始める必要があります。使用するラ
      ベルは、PHPの他のラベルと同様の名前に関する規則に従う必要がありま
      す。つまり、英数字およびアンダースコアのみを含み、数字でない文字ま
      たはアンダースコアで始まる必要があります。
     </simpara>
     
     <warning>
      <simpara>
       非常に重要なことですが、終端IDがある行には、セミコロン
       (<literal>;</literal>)以外の他の文字が含まれていてはならないこ
       とに注意してください。これは、特にIDはインデントしてはならないと
       いうことと、セミコロンの前に空白やタブを付けてはいけないことを
       意味します。
       終端IDの前の最初の文字は、使用するオペレーティングシステ
       ムで定義された改行である必要があることにも注意を要します。
       これは、例えば、Macintoshでは <literal>\r</literal>となります。
      </simpara>
      <simpara>
       この規則が破られ、終端IDが"clean"でない場合、
       終端IDと認識されず、PHPは探し続けます。
       適当な終了IDがみつからない場合、スクリプトの最終行を発生
       行とするパースエラーが発生します。
      </simpara>
      <para>
       ヒアドキュメント構文を、クラスのメンバの初期化に用いることはできません。
       他の文字列構文を利用してください。
       <example>
        <title>間違った例</title>
        <programlisting role="php">
<![CDATA[
<?php
class foo {
    public $bar = <<<EOT
bar
EOT;
}
?>
]]>
        </programlisting>
       </example>
      </para>
     </warning>

     <para>
      ヒアドキュメントは、2重引用符を使用しませんが、2重引用符で括られた
      文字列と全く同様に動作します。しかし、この場合でも上記のリストでエ
      スケープされたコードを使用することも可能です。変数は展開されますが、
      文字列の場合と同様にヒアドキュメントの内部で複雑な変数を表わす場合
      には注意が必要です。
      <example> 
       <title>ヒアドキュメントで文字列を括る例</title>
       <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
Example of string
spanning multiple lines
using heredoc syntax.
EOD;

/* 変数を使用するより複雑な例 */
class foo
{
    var $foo;
    var $bar;

    function foo() {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo <<<EOT
My name is "$name". I am printing some $foo->foo.
Now, I am printing some {$foo->bar[1]}.
This should print a capital 'A': \x41
EOT;
?>
]]>
       </programlisting>
      </example>
     </para>
     
     <note>
      <para>
       ヒアドキュメントはPHP4で追加されました。
      </para>
     </note>

    </sect3>

    <sect3 id="language.types.string.parsing">
     <title>変数のパース</title>
     <simpara>
      スクリプトが2重引用符で括られるかヒアドキュメントで指定された場
      合、その中の変数はパースされます。
     </simpara>
     <simpara>
      構文の型には、<link
      linkend="language.types.string.parsing.simple">単純な</link>構文と
      <link linkend="language.types.string.parsing.complex">複雑な
      </link>構文の2種類があります。簡単な構文は、最も一般的で便利です。
      この構文では、変数、配列値やオブジェクトのプロパティをパースする
      ことが可能です。
     </simpara>
     <simpara>
      複雑な構文は、PHP 4で導入されました。
      この構文は、式を波括弧で括ることにより認識されます。
     </simpara>
     <sect4 id="language.types.string.parsing.simple">
      <title>簡単な構文</title>
      <simpara>
       ドル記号(<literal>$</literal>)を見付けるとパーサは、有効な変数
       名を形成することが可能な最長のトークンを取得します。変数名の終
       りを明示的に指定したい場合は、変数名を波括弧で括ってください。
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
$beer = 'Heineken';
echo "$beer's taste is great"; // 動作します。"'" は変数名として無効な文字です。
echo "He drunk some $beers"; // 動作しません。's' は、変数名として有効な文字です。
echo "He drunk some ${beer}s"; // 動作します。
echo "He drank some {$beer}s"; // 動作します。
]]>
       </programlisting>
      </informalexample>
      <simpara>
       同様に、配列添字とオブジェクトのプロパティをパースすることも可
       能です。配列添字の場合、閉じ角括弧(']')は添字の終りを意味し、
       オブジェクトのプロパティの場合、同じ規則が簡単な変数として適用
       されます。しかし、オブジェクトプロパティには、変数の場合のよう
       な手法はありません。
       
       <!-- XXX isn't &true; :(, this would be the trick
       Also, the same trick with curly-braces works if you
       want to limit the greediness of parsers.
       -->

      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// These examples are specific to using arrays inside of strings.
// When outside of a string, always quote your array string keys 
// and do not use {braces} when outside of strings either.

// Let's show all errors
error_reporting(E_ALL);

$fruits = array('strawberry' => 'red' , 'banana' => 'yellow');

// シングルクオートの外では動作が異なることに注意してください。
echo "A banana is $fruits[banana].";

// 動作します。
echo "A banana is {$fruits['banana']}.";

// Works but PHP looks for a constant named banana first
// as described below.
echo "A banana is {$fruits[banana]}.";

// Won't work, use braces.  This results in a parse error.
echo "A banana is $fruits['banana'].";

// Works
echo "A banana is " . $fruits['banana'] . ".";

// Works
echo "This square is $square->width meters broad.";

// 動作しません。解決策については、複雑な構文を参照ください。
echo "This square is $square->width00 centimeters broad.";
?>
]]>
<!-- XXX this won't work:
echo "This square is $square->{width}00 centimeters broad."; 
// XXX: php developers: it would be consequent to make this work.
// XXX: like the $obj->{expr} syntax outside a string works, 
// XXX: analogously to the ${expr} syntax for variable var's.
-->
       </programlisting>
      </informalexample>
      <simpara>
       より複雑な場合は、複雑な構文を使用する必要があります。
      </simpara>
     </sect4>

     <sect4 id="language.types.string.parsing.complex">
      <title>複雑な(波括弧)構文</title>
      <simpara>
       この構文は、構文が複雑であるからではなく、この方法では複雑な式を
       含めることができるために複雑(complex)と呼ばれています。
      </simpara>
      <simpara>
       事実、この構文により文字列の中に名前空間にあるあらゆる値を含める
       ことが可能です。文字列の外側に置く場合と同様に式を書き、これを
       { と } の間に含めてください。'{' はエスケープすることができない
       ため、この構文は $ が { のすぐ後に続く場合にのみ認識されます
       (リテラル "{$" を指定するには、"{\$" を使用してください)。
       以下のいくつかの例を見ると理解しやすくなるでしょう。
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Let's show all errors
error_reporting(E_ALL);

$great = 'fantastic';

// Won't work, outputs: This is { fantastic}
echo "This is { $great}";

// Works, outputs: This is fantastic
echo "This is {$great}";
echo "This is ${great}";

// Works
echo "This square is {$square->width}00 centimeters broad."; 

// Works
echo "This works: {$arr[4][3]}";

// This is wrong for the same reason as $foo[bar] is wrong 
// outside a string.  In otherwords, it will still work but
// because PHP first looks for a constant named foo, it will
// throw an error of level E_NOTICE (undefined constant).
echo "This is wrong: {$arr[foo][3]}"; 

// Works.  When using multi-dimensional arrays, always use
// braces around arrays when inside of strings
echo "This works: {$arr['foo'][3]}";

// Works.
echo "This works: " . $arr['foo'][3];

echo "You can even write {$obj->values[3]->name}";

echo "This is the value of the var named $name: {${$name}}";
?>
]]>
<!-- maybe it's better to leave this out?? 
// this works, but i disencourage its use, since this is NOT 
// involving functions, rather than mere variables, arrays and objects.
$beer = 'Heineken';
echo "I'd like to have another {${ strrev('reeb') }}, hips";
 -->
       </programlisting>
      </informalexample>
     </sect4>
    </sect3>
    
    <sect3 id="language.types.string.substr">
     <title>文字列への文字単位のアクセスと修正</title>
     <para>
      波括弧の後に任意の文字をゼロから始まるオフセットで指定することに
      より、文字列内の文字にアクセス/修正することが可能です。
     </para>
     <note>
      <simpara>
       過去の互換性のため、配列括弧を使用することが可能です。しかし、
       この構文はPHP 4に依存しています。
      </simpara>
     </note>
     <para>
      <example>
       <title>いくつかのstringの例</title>
       <programlisting role="php">
<![CDATA[
<?php
// Get the first character of a string
$str = 'This is a test.';
$first = $str{0};

// Get the third character of a string
$third = $str{2};

// Get the last character of a string.
$str = 'This is still a test.';
$last = $str{strlen($str)-1};

// Modify the last character of a string
$str = 'Look at the sea';
$str{strlen($str)-1} = 'e';
           
?>
]]>
       </programlisting>
      </example>
     </para>
    </sect3>

   </sect2><!-- end syntax -->

   <sect2 id="language.types.string.useful-funcs">
    <title>便利な関数</title><!-- and operators -->
    <para>
     文字列は、'.' (ドット)結合演算子で結合することが可能です。'+'(付
     加)演算子はこの例では出てこないことに注意してください。詳細について
     は <link linkend="language.operators.string">文字列演算子</link>
     を参照ください。
    </para>
    <para>
     文字列の修正を行う場合に便利な関数がたくさんあります。
    </para>
    <simpara>
     一般的な関数については、<link linkend="ref.strings">文字列関数の
     節</link> を参照ください。高度な検索/置換を行う正規表現関数について
     は、<link linkend="ref.pcre">Perl</link> および
     <link linkend="ref.regex">POSIX 拡張</link>の2種類ありますが、そ
     れぞれの節を参照ください。
    </simpara>
    <simpara>
     <link linkend="ref.url">URL文字列用関数</link>や文字列の暗号化/
     復号化用関数(<link linkend="ref.mcrypt">mcrypt</link> および
     <link linkend="ref.mhash">mhash</link>)もあります。
    </simpara>
    <simpara>
     最後に、探しているものがまだ見付からない場合には、
     <link linkend="ref.ctype">文字型の関数</link>も参照ください。
    </simpara>
   </sect2>

   <sect2 id="language.types.string.casting">
    <title>文字列への変換</title>
    
    <para>
     <literal>(string)</literal>キャストや<function>strval</function>関数を
     使って変数を文字列へ変換することができます。文字列型を必要とする
     式のスコープにおいて文字列への変換は自動的に行われます。
     <function>echo</function>や<function>print</function>関数を使うとき、
     あるいは可変変数を文字列を比較するときにこの自動変換が行われます。
     マニュアルの<link linkend="language.types">型</link> と 
     <link linkend="language.types.type-juggling">型の相互変換</link>の項を
     読むとわかりやすいでしょう。
     <function>settype</function>も参照してください。
    </para>
    
    <para>
     <type>boolean</type>の &true; は文字列の<literal>"1"</literal>に、
     &false; は<literal>""</literal>(空文字列)に変換されます。
     これによりbooleanと文字列の値を相互に変換することができます。
    </para>
    <para> 
     <type>integer</type>(整数)や浮動小数点数(<type>float</type>)は
     その数値の数字として文字列に変換されます(指数の表記や浮動小数点数を含めて)。
    </para>
    <para>
     配列は常に<literal>"Array"</literal>という文字列に変換されるので、
     <type>array</type>の中を見るために<function>echo</function>や
     <function>print</function>を使ってダンプさせることはできません。
     一つの要素を見るためには、<literal>echo $arr['foo']</literal>のように
     してください。内容の全てをダンプ/見るためには以降のTIPをご覧ください。
    </para>
    <para>
     オブジェクトは常に<literal>"Object"</literal>という文字列に変換されます。
     デバッグ等のために<type>object</type>の内部の変数を出力するような
     場合には、以下をご覧ください。オブジェクトがなんという名前のクラスの
     インスタンスなのかを知るには<function>get_class</function>をご覧ください。
    </para>
    <para>
     リソースは常に<literal>"Resource id #1"</literal>という文字列に
     変換されます。<literal>1</literal>は実行中のPHPによって割り当てられる
     <type>resource</type>のユニークな番号です。
     リソースの型を知るためには<function>get_resource_type</function>を
     使用してください。
    </para>
    <para>
     &null; は常に空文字列に変換されます。
    </para>
    
    <para>
     以上に述べたように、配列、オブジェクト、リソースをプリントアウトしても
     その値に関する有益な情報を得られるわけではありません。デバッグのために
     値を出力するのにベターな方法が<function>print_r</function>や
     <function>var_dump</function>等にあります。
    </para>
    
    <para>
     PHP変数を恒久的に保存するための文字列に変換することもできます。
     この方法はシリアライゼーションと呼ばれ、
     <function>serialize</function>関数によって実現できます。
     <link linkend="ref.wddx">WDDX</link>サポートを有効にしてPHPを
     セットアップすれば、PHP変数をXML構造にシリアライズすることもできます。
    </para>
   </sect2>

   <sect2 id="language.types.string.conversion">
    <title>文字列の変換</title>

    <simpara>
     数値として文字列が評価された時、結果の値と型は次のように
     定義されます。
    </simpara>
    <simpara>
     文字列は、'.'、'e'、'E' のどれかが含まれている場合は
     <type>float</type>、それ以外は整数として評価されます。
    </simpara>
    <para>
     文字列の最初の部分により値が決まります。文字列が、有効な数値デー
     タから始まる場合、この値が使用されます。その他の場合、値は 0 (ゼ
     ロ) となります。有効な数値データは符号(オプション)の後に、1つ以上
     の数字(オプションとして小数点を一つ含む)、オプションとして指数部
     が続きます。指数部は 'e' または 'E' の後に一つ以上の数字が続く形
     式です。
    </para>
    <simpara>
     最初の式が文字列の場合、変数の型は2番目の式に依存します。
    </simpara>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = 1 + "10.5";              // $foo は float です (11.5)
$foo = 1 + "-1.3e3";            // $foo は float です (-1299)
$foo = 1 + "bob-1.3e3";         // $foo は integer です (1)
$foo = 1 + "bob3";              // $foo は integer です (1)
$foo = 1 + "10 Small Pigs";     // $foo は integer です (11)
$foo = 1 + "10 Little Piggies"; // $foo は integer です (11)
$foo = "10.0 pigs " + 1;        // $foo は integer です (11)
$foo = "10.0 pigs " + 1.0;      // $foo は float です (11)     
?>
]]>
     </programlisting>
    </informalexample>
    <simpara>
     この変換に関する詳細は、UNIXマニュアルstrtod(3) を参照ください。
    </simpara>
    <para>
     本節の例を試したい場合、その例をカットアンドペーストしてから
     動作を確認するために次の行を挿入してください。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
echo "\$foo==$foo; type is " . gettype ($foo) . "<br>\n";
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     （C言語で行われるように）数値に変換することで一つの文字のコードを
     取得できると期待してはいけません。文字と文字コードを相互に変換
     するには<function>ord</function>と<function>chr</function>関数を
     使用してください。
    </para>

   </sect2>
  </sect1><!-- end string -->

  <sect1 id="language.types.array">
   <title>配列</title>

   <para>
    PHPの配列は、実際には順番付けられたマップです。マップは型の一種で、
    <emphasis>値</emphasis>を<emphasis>キー</emphasis>にマップします。
    この型は、いくつかの手法で最適化されます。このため、実際の配列
    またはリスト(ベクトル)、(あるマップの実装である)ハッシュテーブル、
    ディレクトリ、コレクション、スタック、キュー等として使用することが
    可能です。PHPの配列には他のPHP配列を値として保持することができるた
    め、非常に簡単にツリー構造を表現することが可能です。
   </para>
   <para>
    これらの構造に関する説明は、本マニュアルの範囲外ですが、これらの構
    造に各々に関する例を少なくとも一つ見付けることが可能です。これらの
    構造に関するより詳細な情報については、データ構造に関する良書を購入
    してください。
   </para>
   
   <sect2 id="language.types.array.syntax">
    <title>構文</title>
    
    <sect3 id="language.types.array.syntax.array-func">
     <title><function>array</function>で指定</title>
     <para>
      <type>配列</type> は、言語に組み込まれた
      <function>array</function> で作成することが可能です。この構造は、
      特定の数のカンマで区切られた
      <literal><replaceable>key</replaceable> =&gt; <replaceable
      >value</replaceable></literal>の組を引数とします。
     </para>
     <para>
      <synopsis>
array( <optional> <replaceable>key</replaceable> =&gt; </optional> <replaceable
>value</replaceable>
     , ...
     )
// <replaceable>key</replaceable>は、<type>文字列</type>または非負の
// <type>整数</type>です。
// <replaceable>value</replaceable>に制約はありません.
      </synopsis>
     </para>
     <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array("foo" => "bar", 12 => true);

echo $arr["foo"]; // bar
echo $arr[12];    // 1
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      <varname>key</varname> は、<type>整数</type> または
      <type>文字列</type>です。
      あるキーが、<type>整数</type>の標準的な表現形式である場合、
      そのように解釈されます(つまり、<literal>"8"</literal>は
      <literal>8</literal>として解釈されます。一方、
      <literal>"08"</literal>は<literal>"08"</literal>として解釈されま
      す)。<varname>key</varname> に浮動小数点数値を指定すると、
      その値は <type>integer</type> に切り詰められます。
      PHPにおいては添字配列と連想配列の間に違いはなく、配列型は１つだ
      けで、整数または文字列のインデックスを使用することができます。
     </para>
     <para>
      値には、PHPの全ての型を使用することができます。
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array("somearray" => array(6 => 5, 13 => 9, "a" => 42));

echo $arr["somearray"][6];    // 5
echo $arr["somearray"][13];   // 9
echo $arr["somearray"]["a"];  // 42
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      キーを省略した場合、整数添字の最大値が使用され、新しいキーはそ
      の最大値+1となります。整数値は負の数とすることができ、負の添字に
      ついても同様となります。例えば、最高時の添字が<literal>-6</literal>
      の場合、次のキーは<literal>-5</literal>となります。
      整数添字がまだ存在しない場合、キーは<literal>0</literal>(ゼロ)となります。
      値が既に代入されているキーを指定した場合、元の値は上書きされます。
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// この配列は以下の配列と同じです ...
array(5 => 43, 32, 56, "b" => 12);

// この配列は上の配列と同じです
array(5 => 43, 6 => 32, 7 => 56, "b" => 12);
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <warning>
      <simpara>
       PHP4.3.0以降、上記のような添字生成動作は変更されました。
       現在では、配列に追加する際に、その配列の最大添字が負である
       場合は次の添え字はゼロ(<literal>0</literal>)となります。
       以前は、正の添字の場合と同様に新しい添字は最大添字に+1した
       ものにセットされていました。
      </simpara>
     </warning>
     <para>
      キーとして &true; を使用した場合、
      <type>整数</type>型の<literal>1</literal>がキーとして解釈されます。
      キーとして &false; を使用した場合、
      <type>整数</type>型の<literal>0</literal>がキーとして解釈されます。
      キーとして<literal>NULL</literal>を使用した場合、空の文字列として評価
      されます。キーとして空の文字列を使用すると、空の文字列のキーとその値を
      作成(または上書き)します。空の括弧を用いた場合と同じではありません。
     </para>
     <para>
      配列またはオブジェクトをキーとして使用することはできません。
      これを行なうと、warning: <literal>Illegal offset type</literal>
      を発生します。
     </para>
    </sect3>
    
    <sect3 id="language.types.array.syntax.modifying">
     <title>角括弧構文で作成/修正</title>
     <para>
      明示的に値を設定することにより、既存の配列を修正することも可能で
      す。
     </para>
     <para>
      これは、角括弧の中にキーを指定し、配列に値を代入することにより行
      います。キーを省略することも可能です。この場合、空の角括弧
      ("<literal>[]</literal>")の変数名として追加してください。
      <synopsis>
$arr[<replaceable>key</replaceable>] = <replaceable>value</replaceable>;
$arr[] = <replaceable>value</replaceable>;
// <replaceable>key</replaceable> は <type>文字列</type> または非負の
// <type>整数</type>のどちらかです。

// <replaceable>value</replaceable> は何でもかまいません
      </synopsis>
      <varname>$arr</varname> がまだ存在しない場合、作成されます。
      配列を指定する別の手段でもあります。ある値を変更するには、新し
      い値に値を代入します。特定のキー/値の組を削除したい場合には、
      <function>unset</function> を使用する必要があります。
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array(5 => 1, 12 => 2);

$arr[] = 56;    // このスクリプトのこの位置に記述した場合、
                // $arr[13] = 56; と同じです

$arr["x"] = 42; // キー"x"の新しい要素を配列に追加します
                
unset($arr[5]); // 配列から要素を削除します

unset($arr);    // 配列全体を削除します
?>
]]> 
       </programlisting>
      </informalexample>
     </para>
     <note>
      <para>
       上記のように、キーを省略して新規要素を追加する場合、
       追加される数値添字は、使用されている添字の最大値+1になります。
       既に値が割り当てられているキーを指定した場合には、
       値は上書きされます。
      </para>
      <para>
       <warning>
        <simpara>
         PHP4.3.0以降、上記のような添字生成動作は変更されました。
         現在では、配列に追加する際に、その配列の最大添字が負である
         場合は次の添え字はゼロ(<literal>0</literal>)となります。
         以前は、正の添字の場合と同様に新しい添字は最大添字に+1した
         ものがセットされました。
        </simpara>
       </warning>
      </para>
      <para>
       次のキー生成において、オフセットとして使われる
       整数値(添え字の最大値)に対応するエントリーが必ずしも配列内に
       存在するわけではないことに注意してください。
       しかし、その値は、多くの場合、配列にある
       整数のキー値の最大値と等しいはずです。以下に例を示します。
      </para>

      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// 簡単な配列を生成します。
$array = array(1, 2, 3, 4, 5);
print_r($array);

// 全てのアイテムを削除しますが、配列自体は削除しないでおきます。
foreach ($array as $i => $value) {
    unset($array[$i]);
}
print_r($array);

// アイテムを追加します(新しい添え字は0ではなく
// 5となることに注意)
$array[] = 6;
print_r($array);

// 添え字を振りなおします。
$array = array_values($array);
$array[] = 7;
print_r($array);
?>
]]> 
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
Array
(
    [0] => 1
    [1] => 2
    [2] => 3
    [3] => 4
    [4] => 5
)
Array
(
)
Array
(
    [5] => 6
)
Array
(
    [0] => 6
    [1] => 7
)
]]>
       </screen>
      </informalexample>       

     </note>
    </sect3>

   </sect2><!-- end syntax -->

   <sect2 id="language.types.array.useful-funcs">
    <title>有用な関数</title>
    <para>
     配列で使用する便利な関数がたくさんあります。
     <link linkend="ref.array">配列関数</link> の節を参照ください。
    </para>
    <note>
     <para>
      <function>unset</function>関数は配列のキーを削除することが出来ます。
      ただし、これによってインデックスの再構築が行われるわけではないことに
      注意してください。
      "通常の整数添字"(0から始まり、1つずつ増加)のみを使用している場合、
      <function>array_values</function>を用いてインデックスを再構築す
      ることができます。
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$a = array(1 => 'one', 2 => 'two', 3 => 'three');
unset($a[2]);
/* これにより配列は以下の様に定義されます。
   $a = array( 1 => 'one', 3 => 'three');
   以下ではありません：
   $a = array( 1 => 'one', 2 => 'three');
*/

$b = array_values($a);
// bは、array(0 => 'one', 1 =>'three')となります
?>
]]>
       </programlisting>
      </informalexample>

     </para>
    </note>
    <para>
     配列専用の制御構造として<link
     linkend="control-structures.foreach">foreach</link>があります。こ
     の構造は、配列の要素に簡単に連続的にアクセスする手段を提供します。
    </para>
   </sect2>
   
   <sect2 id="language.types.array.donts">
    <title>配列ですべきこととしてはならないこと</title>

    <sect3 id="language.types.array.foo-bar">
     <title>なぜ、<literal>$foo[bar]</literal> は使用できないのか?</title>
     <para>
      連想配列の添字の前後は常に引用符で括る必要があります。
      例えば、$foo[bar]ではなく$foo['bar']を使用してください。
      しかし、 $foo[bar]はなぜ誤りなのでしょうか?
      古いスクリプトで次のような構文を見たことがあるかもしれません。
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$foo[bar] = 'enemy';
echo $foo[bar];
// etc
?>
]]>
       </programlisting>
      </informalexample>
      これは間違っていますが、動作します。では、なぜ間違っているのでしょ
      う? その理由は、このコードには文字列('bar' - 引用符で括られてい
      る)ではなく未定義の定数(bar)が使用されており、PHPが同じ名前の定
      数を不幸にして同じコードの中に定義する可能性があるためです。
      下位互換性の維持のために未定義の定数は同じ名前の文字列に自動的に
      変換されるため、このコードは動作します。
      例えば、<constant>bar</constant>という名前の、定義されていない定数
      があるとすると、PHPは<literal>'bar'</literal>という文字列でそれを
      置換して使用します。
     </para>
     <note>
      <simpara>
       これは、添字を<emphasis>常に</emphasis>クォートするという
       意味ではありません。<link linkend="language.constants">定数</link>や
       <link linkend="language.variables">変数</link>を添字として
       使う際には、クォートしてしまうとPHPはそれを解釈できなくなって
       しまいます。
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
error_reporting(E_ALL);
ini_set('display_errors', true);
ini_set('html_errors', false);
// Simple array:
$array = array(1, 2);
$count = count($array);
for ($i = 0; $i < $count; $i++) {
    echo "\nChecking $i: \n";
    echo "Bad: " . $array['$i'] . "\n";
    echo "Good: " . $array[$i] . "\n";
    echo "Bad: {$array['$i']}\n";
    echo "Good: {$array[$i]}\n";
}
?>
]]>
       </programlisting>
      </informalexample>
      &example.outputs;
      <screen>
<![CDATA[
Checking 0: 
Notice: Undefined index:  $i in /path/to/script.html on line 9
Bad: 
Good: 1
Notice: Undefined index:  $i in /path/to/script.html on line 11
Bad: 
Good: 1

Checking 1: 
Notice: Undefined index:  $i in /path/to/script.html on line 9
Bad: 
Good: 2
Notice: Undefined index:  $i in /path/to/script.html on line 11
Bad: 
Good: 2
]]>        
      </screen>
     </note>
     <para>
      この具体例を以下に示します。
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// エラーを全て表示するよう設定
error_reporting(E_ALL);

$arr = array('fruit' => 'apple', 'veggie' => 'carrot');

// 正しい
print $arr['fruit'];  // apple
print $arr['veggie']; // carrot

// 間違い。これは動作しますが、未定義の定数fruitを使用しているため、
// 同時にE_NOTICEレベルのPHPエラーを発生します
// 
// Notice: Use of undefined constant fruit - assumed 'fruit' in...
print $arr[fruit];    // apple

// 検証のため、定数を定義してみましょう。
// fruitという名前の定数に値'veggie'を代入します。
define('fruit','veggie');

// ここでは、出力が異なることに注意してください。
print $arr['fruit'];  // apple
print $arr[fruit];    // carrot

// 以下は文字列の中であるためOKです。定数は、文字列の中では解釈されな
// いため、E_NOTICEエラーはここでは発生しません。
print "Hello $arr[fruit]";      // Hello apple

// 例外が１つあり、文字列の中で波括弧で配列を括った場合には、
// 定数が解釈されます
print "Hello {$arr[fruit]}";    // Hello carrot
print "Hello {$arr['fruit']}";  // Hello apple

// これは動作せず、以下のようなパースエラーを発生します:
// Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING'
// 文字列の中でオートグローバルを使用した場合も無論同様です。
print "Hello $arr['fruit']";
print "Hello $_GET['foo']";

// 文字列結合で同じことをすることもできます。
print "Hello " . $arr['fruit']; // Hello apple
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      <function>error_reporting</function>で
      (<constant>E_ALL</constant>を指定する等により)
      <literal>E_NOTICE</literal> レベルのエラー出力を有効にした場合、
      上記のエラーが出力されます。
      デフォルトでは、<link linkend="ini.error-reporting">
      error_reporting</link>はこれらを表示しない設定になっています。
     </para>
     <para>
      <link linkend="language.types.array.syntax"
      >構文</link>の節に記述したように、角括弧の間
      ('<literal>[</literal>'および'<literal>]</literal>')には、式がなけれ
      ばなりません。これは、次のように書くことが可能であることを
      意味します。
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
echo $arr[somefunc($bar)];
?>
]]>
       </programlisting>
      </informalexample>
      これは、関数の戻り値を配列の添字として使用する例です。PHPは定数に
      ついても認識し、以下のような<literal>E_*</literal>の使用例を見た
      ことがあるかもしれません。
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[E_ERROR]   = "A fatal error has occured";
$error_descriptions[E_WARNING] = "PHP issued a warning";
$error_descriptions[E_NOTICE]  = "This is just an informal notice";
?>
]]>
       </programlisting>
      </informalexample>
      最初の例の<literal>bar</literal>と全く同様に
      <literal>E_ERROR</literal> も有効な添字であることに注意して下さ
      い。しかし、実際には最後の例は次のように書くことと同じです。
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[1] = "A fatal error has occured";
$error_descriptions[2] = "PHP issued a warning";
$error_descriptions[8] = "This is just an informal notice";
?>
]]>
       </programlisting>
      </informalexample>
      これは、<literal>E_ERROR</literal> が <literal>1</literal>と等し
      いこと等によります。
     </para>
     <para>
      では、なぜ <literal>$foo[bar]</literal> は動作することが可能なの
      でしょう? それは、<literal>bar</literal> が定数式であることを
      期待される構文で使用されているためです。しかし、この場合、
      <literal>bar</literal> という名前の定数は存在しません。PHPは、
      この場合、あなたが文字列<literal>"bar"</literal>のようにリテラル
      <literal>bar</literal> を指定したが引用符を忘れたと仮定します。
     </para>
     <sect4>
      <title>では、なぜ間違っているのでしょう?</title>
      <para>
       将来的に、PHPは他の定数またはキーワードを追加したいと思うかもし
       れず、問題となる可能性があります。例えば、現在でも、
       単語 <literal>empty</literal> および
       <literal>default</literal>を使用することはできません。 
       これは、これらが、特別な
       <link linkend="reserved">予約済みのキーワード</link>である
       ためです。
      </para>
      <note>
       <simpara>
        二重引用符で括られた<type>文字列</type>の中では、
        引用符で配列の添字を括らないことができ、このため、
        <literal>"$foo[bar]"</literal>は有効です。
        この理由の詳細については、上記の例や
        <link linkend="language.types.string.parsing">文字列中での変数
        のパース</link>を参照してください。
       </simpara>
      </note>
      <note>
       <simpara>
    2重引用符で括られた<type>string</type>の中で他の構文が有効です。
    より詳細については、<link
    linkend="language.types.string.parsing">文字列の中の変数
    </link> を参照ください。
       </simpara>
      </note>
     </sect4>
    </sect3>
   </sect2>

   <sect2 id="language.types.array.casting">
    <title>配列への変換</title>
    
    <para>
     <type>integer</type>, <type>float</type>, <type>string</type>, 
     <type>boolean</type>, <type>resource</type>のいずれの型においても、
     <type>array</type>に変換する場合、最初のスカラー値が割り当てら
     れている一つの要素（添字は0）を持つ配列を得ることになります。
    </para>
    
    <para>
     <type>object</type>を配列にする場合には、配列の要素として
     オブジェクトの属性（メンバー変数）を持つ配列を得ることになります。
     添字はメンバー変数名となります。
    </para>
    
    <para>
     &null; を配列に変換すると、空の配列を得ます。
    </para>
   </sect2>

   <sect2 id="language.types.array.comparing">
    <title>比較</title>
    <para>
     <function>array_diff</function> と 
     <link linkend="language.operators.array">配列演算子</link>
     を用いると、配列を比較することができます。
    </para>
   </sect2>

   <sect2 id="language.types.array.examples">
    <title>例</title>
    <para>
     PHP の配列型は、いろいろな使い方ができます。配列の強力な機能を示すため、
     ここでいくつかの例を紹介します。
    </para>
    <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// this
$a = array( 'color' => 'red',
            'taste' => 'sweet',
            'shape' => 'round',
            'name'  => 'apple',
                       4        // キーは0になります
          );

// これは以下と完全に同じです。
$a['color'] = 'red';
$a['taste'] = 'sweet';
$a['shape'] = 'round';
$a['name'] = 'apple';
$a[]        = 4;        // キーは0になります

$b[] = 'a';
$b[] = 'b';
$b[] = 'c';
// この結果は配列 array(0 => 'a' , 1 => 'b' , 2 => 'c'),
// または単に array('a', 'b', 'c') となります
?>
]]>
       </programlisting>
      </informalexample>
     </para>
    
    <example>
     <title>array()の使用例</title>
     <programlisting role="php">
<![CDATA[
// マップを行う配列
$map = array( 'version'    => 4
            , 'OS'         => 'Linux'
            , 'lang'       => 'english'
            , 'short_tags' => true
            );
            
// 数値キーのみを有する
$array = array( 7
              , 8
              , 0
              , 156
              , -10
              );
// これは、array( 0 => 7, 1 => 8, ...) と同じです

$switching = array(         10 // key = 0
                  , 5    =>  6
                  , 3    =>  7 
                  , 'a'  =>  4
                  ,         11 // key = 6 (最大の添字は5です)
                  , '8'  =>  2 // key = 8 (整数!)
                  , '02' => 77 // key = '02'
                  , 0    => 12 // 値10は12で上書きされます
                  );
                  
// empty array
$empty = array();           
]]>
<!-- TODO example of
- mixed keys
- overwriting keys
- integer keys as string
- using vars/functions as key/values
- mixed skipping
-->
     </programlisting>
    </example>

    <example id="language.types.array.examples.loop">
     <title>コレクション</title>
     <programlisting role="php">
<![CDATA[
<?php
$colors = array('red','blue','green','yellow');

foreach ( $colors as $color ) {
    echo "Do you like $color?\n";
}

?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Do you like red?
Do you like blue?
Do you like green?
Do you like yellow?
]]>
     </screen>
    </example>
    
    <para>
     PHP 5 以降では、配列を参照渡しすることでその値を直接変更できるように
     なりました。それ以前のバージョンでは、以下のような回避策が必要です。
     <example id="language.types.array.examples.changeloop">
      <title>コレクション</title>
      <programlisting role="php">
<![CDATA[
<?php
// PHP 5
foreach ($colors as &$color) {
    $color = strtoupper($color);
}
unset($color); /* これ以降の $color への書き込みが
配列の要素を書き換えてしまわないことを保証する */

// 旧バージョンでの回避策
foreach ( $colors as $key => $color ) {
    $colors[$key] = strtoupper($color);
}

print_r($colors);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Array
(
    [0] => RED
    [1] => BLUE
    [2] => GREEN
    [3] => YELLOW
)
]]>
      </screen>
     </example>
    </para>
    <para>
     この例は、1から始まる配列を作成します。
     <example>
      <title>1から始まる添字</title>
      <programlisting role="php">
<![CDATA[
<?php
$firstquarter  = array(1 => 'January', 'February', 'March');
print_r($firstquarter);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Array 
(
    [1] => 'January'
    [2] => 'February'
    [3] => 'March'
)
]]>   
      </screen>
     </example>
    </para>
    <example>
     <title>配列に代入する</title>
     <programlisting role="php">
<![CDATA[
<?php
// ディレクトリから全てのアイテムを配列に代入する
$handle = opendir('.');
while ($file = readdir($handle)) 
{
    $files[] = $file;
}
closedir($handle); 
?>
]]>
     </programlisting>
    </example>
    <para>
     配列には順番が付けられます。異なったソート関数を用いて順番を変更
     することも可能です。より詳細な情報については、<link
     linkend="ref.array">配列関数</link> を参照ください。
     You can count
     the number of items in an array using the
     <function>count</function> function.
    </para>
    <example>
     <title>配列のソート</title>
     <programlisting role="php">
<![CDATA[
<?php
sort($files);
print_r($files);
?>
]]>
     </programlisting>
    </example>
    <para>
     配列の値は何でも良いため、その値を他の配列とすることも可能です。
     これにより、再帰的な配列や多次元の配列を作成することが可能です。
    </para>
    <example>
     <title>再帰および多次元配列</title>
     <programlisting role="php">
<![CDATA[
<?php
$fruits = array ( "fruits"  => array ( "a" => "orange",
                                       "b" => "banana",
                                       "c" => "apple"
                                     ),
                  "numbers" => array ( 1,
                                       2,
                                       3,
                                       4,
                                       5,
                                       6
                                     ),
                  "holes"   => array (      "first",
                                       5 => "second",
                                            "third"
                                     )
                );

// Some examples to address values in the array above 
echo $fruits["holes"][5];    // prints "second"
echo $fruits["fruits"]["a"]; // prints "orange"
unset($fruits["holes"][0]);  // remove "first"

// Create a new multi-dimensional array
$juices["apple"]["green"] = "good"; 
?>
]]>
     </programlisting>
    </example>
    <para>
     配列の割り当てにおいて常に値がコピーされることに注意してください。
     配列をリファレンスでコピーする場合にはリファレンス演算子を
     使う必要があります。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$arr1 = array(2, 3);
$arr2 = $arr1;
$arr2[] = 4; // $arr2 is changed,
             // $arr1 is still array(2,3)
             
$arr3 = &$arr1;
$arr3[] = 4; // now $arr1 and $arr3 are the same
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.types.object">
   <title>オブジェクト</title>
   
   <sect2 id="language.types.object.init">
    <title>オブジェクトの初期化</title>

    <para>
     オブジェクトを初期化するためには、<literal>new</literal>命令
     によりオブジェクトのインスタンスを変数に作成します。

     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class foo
{
    function do_foo()
    { 
        echo "Doing foo."; 
    }
}

$bar = new foo;
$bar -> do_foo ();
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     詳細な事項については、
     <link linkend="language.oop">クラスおよびオブジェクト</link>に
     関するセクションを参照ください。
    </simpara>

   </sect2>

   <sect2 id="language.types.object.casting">
    <title>オブジェクトへの変換</title>
    
    <para>
     オブジェクトがオブジェクトに変換される場合、それは修正されません。
     他の型の値がオブジェクトに変換される場合、ビルトインクラスである
     <literal>stdClass</literal>の新しいインスタンスが生成されます。
     値がnullの場合、新しいインスタンスは空となります。配列がオブジェクトに
     変換される場合、配列のキーがプロパティ名となり、配列の値が
     プロパティの値となります。他の値の場合、
     <literal>scalar</literal>という名前のメンバ変数が値を格納します。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$obj = (object) 'ciao';
echo $obj->scalar;  // outputs 'ciao'
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>

  </sect1>

  <sect1 id="language.types.resource">
   <title>リソース</title>
    
   <para>
    リソースは特別な変数であり、外部リソースへのリファレンスを保持して
     います。リソースは、特別な関数により作成され、使用されます。
    これらの関数および対応する全てのリソース型の一覧については、
    <link linkend="resource">付録</link> を参照ください。
   </para>
   
   <note>
    <simpara>
     リソース型は、PHP 4で導入されました。
    </simpara>
   </note>
   
    <para>
     <function>get_resource_type</function> も参照ください。
    </para>

   <sect2 id="language.types.resource.casting">
    <title>リソースへの変換</title>
    
    <para>
     リソース型は、オープンされたファイル、データベース接続、
     イメージキャンバスエリアのような特殊なハンドルを保持するため、
     他の値をリソースに変換することはできません。
    </para>
   </sect2>

   <sect2 id="language.types.resource.self-destruct">
    <title>リソースの開放</title>
    
    <para>
     PHP4のZendエンジンに導入されたリファレンスカウンティングシステム
     のおかげで、あるリソースがもう参照されなくなった場合に(Javaと全く
     同様に)、そのリソースは自動的に削除されます。この場合、このリソー
     スが作成した全てのリソースはガーベッジコレクタにより開放されます。
     このため、free_result 関数を用いて手動でメモリを開放する必要が生
     じるのはまれです。
     <note>
      <simpara>
       持続的データベース接続は特別で、ガーベッジコレクタにより破棄さ
       れません。<link 
       linkend="features.persistent-connections">持続的接続</link>も参
       照ください。
      </simpara>
     </note>
    </para>
    
   </sect2>
  </sect1>
    
  <sect1 id="language.types.null">
   <title>NULL</title>
    
   <para>
    特別な &null; 値は、ある変数が値を持たないことを表します。&null;
    は、<type>NULL</type>型の唯一の値です。
   </para>
   <note>
    <simpara>
     NULL型は、PHP 4で導入されました。
    </simpara>
   </note>
   <para>
    ある変数は以下の場合に &null; とみなされます。
    <itemizedlist>
     <listitem>
      <para>
       定数 &null; が代入されている場合。
      </para>
     </listitem>
     <listitem>
      <para>
       何らかの値が代入されていない場合。
      </para>
     </listitem>
     <listitem>
      <para>
       <function>unset</function>されている場合。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <sect2 id="language.types.null.syntax">
    <title>構文</title>
    <para>
     ヌル型の値は一つだけで、大文字小文字を区別しないキーワード
     &null;です。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$var = NULL;       
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     <function>is_null</function> および <function>unset</function>も
     参照してください。
    </para>
   </sect2>
  
  </sect1>

  <sect1 id="language.pseudo-types">
   <title>本ドキュメントにおける疑似的な型</title> 

   <sect2 id="language.types.mixed">
    <title>mixed</title>
    <para>
     <literal>mixed</literal>は引数に多様な型(全てである必要はない)を
     使うことができることを示します。
    </para>
    <para>
     例えば<function>gettype</function>関数は全てのPHPの型を受け入れるのに対し
     <function>str_replace</function>は文字列と配列のみを受け入れます。
    </para>
   </sect2>
  
   <sect2 id="language.types.number">
    <title>number</title>
    <para>
     <literal>number</literal>は引数が<type>integer</type>または<type>float</type>
     のどちらでもよいことを示します。
    </para>
   </sect2>

   <sect2 id="language.types.callback">
    <title>callback</title>
    <para>
     <function>call_user_func</function>や<function>usort</function>等の
     関数はユーザーが定義するコールバック関数を引数として
     受け入れます。コールバック関数はシンプルな関数だけでなく、
     静的なクラスのメソッドを含めてオブジェクトのメソッドであっても
     かまいません。
    </para>
    <para>
     PHP関数はその名前を単に文字列として渡されます。
     どのようなビルトインまたはユーザー定義の関数も渡すことができます。
     ただし下記を除きます。
     <function>array</function>, 
     <function>echo</function>, 
     <function>empty</function>, 
     <function>eval</function>, 
     <function>exit</function>, 
     <function>isset</function>, 
     <function>list</function>, 
     <function>print</function> 
     <function>unset</function>.
    </para>
    <para>
     オブジェクトのインスタンスを作成するための方法の 1 つは、
     オブジェクトを 0 番目の要素、メソッド名を 1 番目の要素として含む配列
     を渡す方法です。
    </para>
    <para>
     スタティッククラスメソッドの場合、0 番目の要素としてオブジェクトを
     渡す代わりにクラス名を渡すことにより、オブジェクトのインスタンスを
     作成せずに渡すことができます。
    </para>

    <para>
     <example>
      <title>
       コールバック関数の例
      </title>
      <programlisting role="php">
<![CDATA[
<?php 
// コールバック関数の例
function my_callback_function() {
    echo 'hello world!';
}

// コールバックメソッドの例
class MyClass {
    function myCallbackMethod() {
        echo 'Hello World!';
    }
}

// タイプ 1: 単純なコールバック
call_user_func('my_callback_function'); 

// タイプ 2: スタティッククラスメソッドのコール
call_user_func(array('MyClass', 'myCallbackMethod')); 

// タイプ 3: オブジェクトメソッドのコール
$obj = new MyClass();
call_user_func(array($obj, 'myCallbackMethod'));
?>
]]>
      </programlisting>
     </example>
    </para>  
   
   </sect2>
  </sect1>

  <sect1 id="language.types.type-juggling">
   <title>型の相互変換</title>

   <simpara>
    PHP は、変数定義時に明示的な型定義を必要と(または、サポート)しませ
    ん。ある変数の型は、その変数が使用される文により定義されます。これ
    は、ある文字列を変数 <parameter>var</parameter> に代入した場合には、
    <parameter>var</parameter> は文字列になることを意味しています。あ
    る整数値を <parameter>var</parameter> に代入した場合には、その変数
    は整数になります。
   </simpara>
   <para>
    PHP の自動型変換の例の一つは、加算演算子 '+' です。
    オペランドのどれかがfloatの場合、全てのオペランドはfloatとして評価
    され、結果はfloatになります。
    その他の場合、オペランドは整数として解釈され、結果も整数になります。
    この自動型変換はオペランド自体の型を変更するものではないということに
    注意してください。
    変わるのは、オペランドがどのように評価されるかだけです。
    <informalexample>
     <programlisting role="php">
$foo = "0";  // $foo は文字列です (ASCII 48)
$foo += 2;   // ここでは、$foo は整数です (2)
$foo = $foo + 1.3;  // ここでは、$foo はfloatです (3.3)
$foo = 5 + "10 Little Piggies";    // $foo は整数です (15)
$foo = 5 + "10 Small Pigs";   // $foo は整数です (15)
<!-- bad example, no real operator (must be used with variable, modifies it too)
$foo++;      // $foo は文字列 "1" (ASCII 49)

TODO: explain ++/- - behaviour with strings

examples:

++'001' = '002'
++'abc' = 'abd'
++'xyz' = 'xza'
++'9.9' = '9.0'
++'-3'  = '-4'
- -'9'   = 8 (integer!)
- -'5.5' = '5.5'
- -'-9'  = -10 (integer)
- -'09'  = 8 (integer)
- -'abc' = 'abc'

-->
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    最後の二つの例が奇妙に思える場合には、
    <link linkend="language.types.string.conversion">文字列変換</link>を
    参照ください。
   </simpara>
   <simpara>
    ある変数を強制的にある特定の型として評価させたい場合には、
    <link linkend="language.types.typecasting">型キャスト</link> の
    セクションを参照ください。ある変数の型を変更したい場合には、
    <function>settype</function> を参照してください。
   </simpara>
   <para>
    本節の例をテストしたい場合には、
    <function>var_dump</function> を使用することが可能です。
   </para>
   <note>
    <para>
     配列への自動変換の動作は現時点で定義されていません。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$a = 1;       // $a は整数です
$a[0] = "f";  // $a は配列になり、$a[0] には "f" が入ります
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     上の例で明らかに $a は配列になりますが、最初の要素は 'f' になります。
     次の例を見てみましょう。
     <informalexample>
      <programlisting role="php">
$a = "1";     // $a は文字列です。
$a[0] = "f";  // 文字列オフセットは何ですか? どうなりますか?
      </programlisting>
     </informalexample>
    </para>
    <para>
     (歴史的な経緯により)
     PHPは文字列への添字を配列への添字と同じ構文を使用してサポートして
     いるため、上の例は、$a は最初の要素が "f" の配列となるのか
     "f" が文字列 $a の最初の文字になるのかが不明であるという問題を生じます。
    </para>
    <para>
     上の例の2番目のケースは、現在の PHP では、文字列オフセットの指定と
     解釈されるので、$a は "f" となります。しかし、この自動変換機能は
     未定義の動作と見なされるべきです。PHP 4 からは、中カッコ ({}) が
     文字列内の文字を取得 / 更新するために利用できますので、これを、
     代わりに使った方がよいでしょう。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$a    = "abc"; // $a は文字列
$a{1} = "f";   // $a は"afc"
?>
]]>
      </programlisting>
     </informalexample>
     詳細は、<link linkend="language.types.string.substr">文字として文
     字列をアクセスする</link>というセクションを参照してください。
    </para>
   </note>

   <sect2 id="language.types.typecasting">
    <title>型キャスト</title>

    <para>
     PHP の型キャストは、C 言語と同様に動作します。つまり、
     変換しようとする型を括弧で括り、キャストする変数の前に置きます。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = 10;   // $foo は整数です
$bar = (boolean) $foo;   // $bar はbooleanです
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     使用可能なキャストを以下に示します。
     <itemizedlist>
      <listitem>
       <simpara>(int), (integer) - 整数へのキャスト</simpara>
      </listitem>
      <listitem>
       <simpara>(bool), (boolean) - 論理値へのキャスト</simpara>
      </listitem>
      <listitem>
       <simpara>(float), (double), (real) - floatへのキャスト</simpara>
      </listitem>
      <listitem>
       <simpara>(string) - 文字列へのキャスト</simpara>
      </listitem>
      <listitem>
       <simpara>(array) - 配列へのキャスト</simpara>
      </listitem>
      <listitem>
       <simpara>(object) - オブジェクトへのキャスト</simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     括弧の中でタブとスペースを使用することができることに注意してくだ
     さい。従って、次の文は、機能的に等価です。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = (int) $bar;
$foo = ( int ) $bar;
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <note>
     <para>
      ある変数を文字列にキャストする代わりに、
      二重引用符で括ることもできます。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = 10;            // $foo は整数です
$str = "$foo";        // $str は文字列です
$fst = (string) $foo; // $fst も文字列です

// 以下は、"they are the same"を出力します
if ($fst === $str) {
    echo "they are the same";
}
?>
]]>
      </programlisting>
     </informalexample>
     </para>
    </note>

    <para>
     型の間でキャストを行う際の動作は、必ずしも明確ではありません。詳
     細については、以下の節を参照ください。

     <itemizedlist>
      <listitem>
       <simpara>
    <link linkend="language.types.boolean.casting">論理値への変換
    </link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
    <link linkend="language.types.integer.casting">整数への変換
    </link>
       </simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.float.casting">浮動小数点数への変換
         </link>
       </simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.string.casting">文字列への変換
         </link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.array.casting">配列への変換
         </link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.object.casting">オブジェクトへの変換 
         </link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.resource.casting">リソース型への変換
         </link></simpara>
      </listitem>
     <!-- don't exist yet
      <listitem>
       <simpara><link linkend="language.types.null.casting">Converting to 
         &null;</link></simpara>
      </listitem>
      -->
      <listitem>
       <simpara>
        <link linkend="types.comparisons">型の比較表</link>
       </simpara>
      </listitem>
     </itemizedlist>    
    </para>
   </sect2>
  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
