 <chapter id="language.types">
  <title>型</title>
  
  <para>
   PHP は以下の型をサポートします。
   <itemizedlist>
    <listitem>
     <simpara>
      <link linkend="language.types.array">配列</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.double">浮動小数</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.integer">整数</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.object">オブジェクト</link>
     </simpara>
    </listitem>
    <listitem>
      <simpara>
      <link linkend="language.types.string">文字列</link>
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <simpara>
   変数の型は、一般にプログラマによりセットされません。むしろ、
   その変数が使用される文の内容に応じて PHP により実行時に決定されます。
  </simpara>
  <simpara>
   ある変数の型を強制的に他の型に変換したい場合、変数を
   <link linkend="language.types.typecasting">キャスト</link> するか、
   <function>settype</function> 関数を使用します。
  </simpara>
  <simpara>
   変数は、その型に依存して異なった動作をする場合があることに
   注意してください。詳細な情報については、
   <link linkend="language.types.type-juggling">型の変換</link> のセクションを
   参照下さい。
  </simpara>
  
  <sect1 id="language.types.integer">
   <title>整数</title>
   <para>
    整数は、次の構文により指定できます。
    <informalexample>
     <programlisting role="php">
$a = 1234; # 10進数
$a = -123; # 負の数
$a = 0123; # 8進数 (10進数の 83 と等価)
$a = 0x12; # 16進数 (10進数の18と等価)
     </programlisting>
    </informalexample>
    最大値が約20億である(32ビット符号付)というのが一般的な値ですが、
    整数のサイズはプラットフォーム依存です。
   </para>
  </sect1>
  
  <sect1 id="language.types.double">
   <title>倍精度実数</title>
   <para>
    倍精度実数 ("double") は、次の構文により指定できます。
    <informalexample>
     <programlisting role="php">
$a = 1.234; $a = 1.2e3;
     </programlisting>
    </informalexample>
    浮動小数の大きさはプラットフォーム依存です。ただし、通常はおよそ10
    進数で14桁の精度があり、最大値は ~1.8e308 (これは 64ビット IEEE
    フォーマットです)となります。
   </para>
   <warning id="warn.float-precision">
    <para>
     <literal>0.1</literal>や<literal>0.7</literal>のような
     簡単な小数表現も若干精度を失うことなく内部2進表現に変
     換することはできません。これにより、混乱する結果を生じることがあ
     ります。つまり、<literal>floor((0.1+0.7)*10)</literal> は
     予想される <literal>8</literal>の代わりに実際の内部表現の結果とし
     て<literal>7.9999999999...</literal>のようなものを結果として返し
     ます。
    </para>
    <para>
     これは、いくつかの分数は有限の桁数の小数点表記で正確に表現できな
     いという事実に関係しています。例えば、<literal>1/3</literal>の小
     数点表記は、<literal>0.3333333. . .</literal>となります。
    </para>
    <para>
     よって、小数の最後の桁を信用してはいかませんし、小数が等しいとい
     う比較を行ってはいけません。より高い精度が必要な場合には、
     <link linkend="ref.bc">任意精度数学関数</link>を代わりに使用して
     下さい。
    </para>
   </warning>
  </sect1>
  
  <sect1 id="language.types.string">
   <title>文字列</title>
   <para>
    文字列は、2組のデリミタの1つを用いて指定できます。
   </para>
   <para>
    文字列が2重引用符(")で括られた場合, 文字列の中の変数は展開されます。
    (ただし、いくつかの解釈時の制約を受けます)
    C や Perl と同じく以下のようにバックスラッシュ文字 ("\")
    を特別な文字を指定するために使用することができます。
    <table>
     <title>エスケープされた文字</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>記述</entry>
        <entry>意味</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>\n</literal></entry>
        <entry>ラインフィード(LFまたはアスキーの0x0A)</entry>
       </row>
       <row>
        <entry><literal>\r</literal></entry>
        <entry>キャリッジリターン (CRまたはアスキーの0x0D)</entry>
       </row>
       <row>
        <entry><literal>\t</literal></entry>
        <entry>水平タブ(HTまたはアスキーの0x09)</entry>
       </row>
       <row>
        <entry><literal>\\</literal></entry>
        <entry>バックスラッシュ</entry>
       </row>
       <row>
        <entry><literal>\$</literal></entry>
        <entry>ドル記号</entry>
       </row>
       <row>
        <entry><literal>\"</literal></entry>
        <entry>2重引用符</entry>
       </row>
       <row>
        <entry><literal>\[0-7]{1,3}</literal></entry>
        <entry>
	正規表現にマッチする文字シーケンスは、8進数表記の1文字です。
        </entry>
       </row>
       <row>
        <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
        <entry>
	 正規表現にマッチする文字シーケンスは、16進数表記の1文字です。
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <para>
    他の文字をエスケープすることも可能ですが、
    警告レベルを最高にした場合には警告が発生します。
   </para>
   <para>
    文字列を区切る2番目の方法はシングルクオート文字("'")を使う方法です。
    ある文字列が引用符で括られている場合、
    理解されるエスケープ文字は、"\\" および "\'" のみです。
    引用符とバックスラッシュを引用符で括られた文字列で
    使用可能とする際に便利なようになっています。
    変数は、引用符で括られた文字列の中では展開されません。
   </para>
   <simpara>
    文字列を区切る別の方法としてヒアドキュメント構文("&lt;&lt;&lt;")  
    があります。この場合、あるIDを<literal>&lt;&lt;&lt;</literal>の後
    に指定し、文字列を置いた後で、同じIDを括りを閉じるために置きます。
    終端IDは、その行の最初のカラムから始める必要があります。使用するラ
    ベルは、PHPの他のラベルと同様の名前に関する規則に従う必要がありま
    す。つまり、英数字およびアンダースコアのみを含み、数字でない文字ま
    たはアンダースコアで始まる必要があります。
   </simpara>
   <para>
    ヒアドキュメントは、2重引用符を使用せませんが、2重引用符で括られた
    文字列と全く同様に動作します。しかし、この場合でも上記のリストでエ
    スケープされたコードを使用することも可能です。変数は展開されますが、
    文字列の場合と同様にヒアドキュメントの内部で複雑な変数を表わす場合
    には注意が必要です。
    <example> 
     <title>ヒアドキュメントによる文字列括りの例</title>
     <programlisting>
&lt;?php
$str = &lt;&lt;&lt;EOD
Example of string
spanning multiple lines
using heredoc syntax.
EOD;

/* 変数を使用するより複雑な例 */
class foo {
    var $foo;
    var $bar;

    function foo() {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo &lt;&lt;&lt;EOT
My name is "$name". I am printing some $foo->foo.
Now, I am printing some {$foo->bar[1]}.
This should print a capital 'A': \x41
EOT;
?>
     </programlisting>
    </example>
   </para>
   <note>
    <para>
    ヒアドキュメントはPHP4で追加されました。
    </para>
   </note>
   <para>
    文字列は、'.' (ドット)結合演算子で結合することが可能です。
    '+'(付加)演算子はこの例では出てこないことに注意して下さい。詳細については
    <link linkend="language.operators.string">文字列演算子</link>を参照下さい。
   </para>
   <para>
    文字列の中の各文字には、C言語の構文のように数字を添字とした文字の配列
    として文字列を取り扱うことによりアクセス可能です。以下の例を参照下さい。
   </para>
   <para>
    <example>
     <title>文字列の例</title>
     <programlisting role="php">
&lt;?php
/* 文字列を代入する */
$str = "This is a string";
 
/* 文字列に追加する */
$str = $str . " with some more text";
 
/* エスケープされた改行を有する別の追加の方法。 */
$str .= " and a newline at the end.\n";
 
/* この文字列は'&lt;p&gt;Number: 9&lt;/p&gt;' となります */
$num = 9;
$str = "&lt;p&gt;Number: $num&lt;/p&gt;";
 
/* この文字列は、'&lt;p&gt;Number: $num&lt;/p&gt;' となります */
$num = 9;
$str = '&lt;p&gt;Number: $num&lt;/p&gt;';
?&gt;	  

/* 文字列の最初の文字を得ます。  */
$str = 'This is a test.';
$first = $str[0];

/* 文字列の最後の文字を得ます。 */
$str = 'This is still a test.';
$last = $str[strlen($str)-1];
?&gt;	  
     </programlisting>
    </example>
   </para>

   <sect2 id="language.types.string.conversion">
    <title>文字列の変換</title>

    <simpara>
     数値として文字列が評価された時、結果の値と型は次のように
     定義されます。
    </simpara>
    <simpara>
     文字列は、'.'、'e'、'E' のどれかが含まれている場合は double、
     それ以外は整数として評価されます。
    </simpara>
    <para>
     文字列の最初の部分により値が決まります。
     文字列が、有効な数値データから始まる場合、この値が使用されます。
     その他の場合、値は 0 (ゼロ) となります。
     有効な数値データは符号(オプション)の後に、1つ以上の
     数字(オプションとして小数点を一つ含む)、オプションとして
     指数部が続きます。
     指数部は 'e' または 'E' の後に一つ以上の数字が続く形式です。
    </para>
    <simpara>
     最初の式が文字列の場合、変数の型は2番目の式に依存します。
    </simpara>
    <informalexample>
     <programlisting role="php">
$foo = 1 + "10.5";              // $foo は double です (11.5)
$foo = 1 + "-1.3e3";            // $foo は double です (-1299)
$foo = 1 + "bob-1.3e3";         // $foo は integer です (1)
$foo = 1 + "bob3";              // $foo は integer です (1)
$foo = 1 + "10 Small Pigs";     // $foo は integer です (11)
$foo = 1 + "10 Little Piggies"; // $foo は integer です (11)
$foo = "10.0 pigs " + 1;        // $foo は integer です (11)
$foo = "10.0 pigs " + 1.0;      // $foo は double です (11)     
     </programlisting>
    </informalexample>
    <simpara>
     この変換に関する詳細は、UNIXマニュアルstrtod(3) を参照下さい。
    </simpara>
    <para>
     本節の例を試したい場合、その例をカットアンドペーストしてから
     動作を確認するために次の行を挿入して下さい。
     <informalexample>
      <programlisting role="php">
echo "\$foo==$foo; type is " . gettype ( $foo ) . "&lt;br&gt;\n";
      </programlisting>
     </informalexample>
    </para>

   </sect2>
  </sect1>

  <sect1 id="language.types.array">
   <title>配列</title>

   <para>
    配列はハッシュテーブル(連想配列)、スカラー配列(ベクトル)の
    どちらとしても動作します。
   </para>
   
   <sect2 id="language.types.array.single-dim">
    <title>1次元の配列</title>
    
    <para>
     PHP は、スカラーおよび連想配列を共にサポートします。
     実際、両者の間に違いはありません。
     配列は、<function>list</function> または<function>array</function>
     で作成することもできますし、
     配列の各要素の値を明示的にセットすることにより作成することもできます。
     <informalexample>
      <programlisting role="php"> 
$a[0] = "abc"; 
$a[1] = "def"; 
$b["foo"] = 13;
      </programlisting>
     </informalexample>
    </para>
    <para>
     配列に値を加える操作だけでも配列を作成することができます。
     空の角括弧で配列変数に値を代入した場合、その値は配列の最後の要素として
     追加されます。
     <informalexample>
      <programlisting role="php"> 
$a[] = "hello"; // $a[2] == "hello"
$a[] = "world"; // $a[3] == "world" 
      </programlisting>
     </informalexample>
    </para>
    <para>
     配列はソートしたい型に応じて <function>asort</function>、
     <function>arsort</function>、 <function>ksort</function>、
     <function>rsort</function>、<function>sort</function>、
     <function>uasort</function>、 <function>usort</function>、
     <function>uksort</function> 関数によりソートすることが可能です。
    </para>
    <para>
     <function>count</function> 関数を用いて、ある配列の
     要素数をカウントすることができます。
    </para>
    <para>
     <function>next</function>と<function>prev</function>関数を
     用いて配列の中で移動することができます。他に配列の中での移動法
     として一般的なのは、<function>each</function>関数です。
    </para>
   </sect2>

   <sect2 id="language.types.array.multi-dim">
    <title>多次元配列</title>

    <para>
     多次元配列の指定は簡単です。
     配列の各次元毎に後ろに他の[キー]を付加します。
     <informalexample>
      <programlisting role="php"> 
$a[1]      = $f;               # 1次元の配列の例
$a["foo"]  = $f;   

$a[1][0]     = $f;             # 2次元
$a["foo"][2] = $f;             # (数値添字と連想添字を混用できます)
$a[3]["bar"] = $f;             # (数値添字と連想添字を混用できます)

$a["foo"][4]["bar"][0] = $f;   # 4次元!
      </programlisting>
     </informalexample>
    </para>
    <para>
     PHP3 では、直接文字列の中で多次元配列を参照することができませんでした。
     例えば、次の例では望む結果を得られません。
     <informalexample>
      <programlisting role="php"> 
$a[3]['bar'] = 'Bob';
echo "これは動作しません: $a[3][bar]";
      </programlisting>
     </informalexample>
     PHP3 では、上の例は、<computeroutput>これは動作しません: Array[bar]
     </computeroutput> を出力します。しかし、文字列結合演算子を使用して、
     これを解決することができます。
     <informalexample>
      <programlisting role="php">
$a[3]['bar'] = 'Bob';
echo "これは動作します: " . $a[3][bar];
      </programlisting>
     </informalexample>
    </para>
    <para>
     しかし、PHP4では(文字列の中で)配列参照を波括弧で囲むことにより
     この問題は回避されました。
     <informalexample>
      <programlisting role="php">
$a[3]['bar'] = 'Bob';
echo "これは動作します: {$a[3][bar]}";
      </programlisting>
     </informalexample>
    </para>
    <para>
     多次元配列にいろいろな手法で値を入れることができます。
     最も技巧的なのは、連想配列に関する <function>array</function> コマンドの
     の使用法です。
     2つのコードは、1次元配列に同じ手法で代入しています。
     <informalexample>
      <programlisting role="php"> 
# 例 1:

$a["color"]	= "red";
$a["taste"]	= "sweet";
$a["shape"]	= "round";
$a["name"]	= "apple";
$a[3]		= 4;


# 例 2:
$a = array(
     "color" => "red",
     "taste" => "sweet",
     "shape" => "round",
     "name"  => "apple",
     3       => 4
);
      </programlisting>
     </informalexample>
    </para>
    <para>
     <function>array</function> 関数は多次元配列に関してネストして
     使用することができます。
     <informalexample>
      <programlisting role="php"> 
&lt;?php
$a = array(
     "apple"  => array(
          "color"  => "red",
          "taste"  => "sweet",
          "shape"  => "round"
     ),
     "orange"  => array(
          "color"  => "orange",
          "taste"  => "tart",
          "shape"  => "round"
     ),
     "banana"  => array(
          "color"  => "yellow",
          "taste"  => "paste-y",
          "shape"  => "banana-shaped"
     )
);

echo $a["apple"]["taste"];    # "sweet" を出力します
?>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.types.object">
   <title>オブジェクト</title>
   
   <sect2 id="language.types.object.init">
    <title>オブジェクトの初期化</title>

    <para>
     オブジェクトを初期化するためには、<literal>new</literal>命令
     によりオブジェクトのインスタンスを変数に作成します。

     <informalexample>
      <programlisting role="php">
&lt;?php
class foo {
    function do_foo () { 
        echo "Doing foo."; 
    }
}

$bar = new foo;
$bar -> do_foo ();
?>
      </programlisting>
     </informalexample>
    </para>

    <simpara>
     詳細な事項については、
     <link linkend="language.oop">クラスおよびオブジェクト</link>に
     関するセクションを参照下さい。
    </simpara>

   </sect2>
  </sect1>

  <sect1 id="language.types.type-juggling">
   <title>型の相互変換</title>

   <simpara>
    PHP は、変数定義時に明示的な型定義を必要としません
    (または、サポートしません。)。
    ある変数の型は、その変数が使用される文により定義されます。
    これは、ある文字列を変数 <parameter>var</parameter> に代入した場合には、
    <parameter>var</parameter> は文字列になることを意味しています。
    ある整数値を <parameter>var</parameter> に代入した場合には、
    その変数は整数になります。
   </simpara>

   <para>
    PHP の自動型変換の例の一つは、加算演算子 '+' です。
    オペランドのどれかが倍精度実数の場合、全てのオペランドは倍精度実数として
    評価され、結果は倍精度実数になります。
    その他の場合、オペランドは整数として解釈され、結果も整数になります。
    この自動型変換はオペラóド自体の型を変更するものではないということに
    注意してください。
    変わるのは、オペランドがどのように評価されるかだけです。

    <informalexample>
     <programlisting role="php">
$foo = "0";  // $foo は文字列です (ASCII 48)
$foo++;      // $foo は文字列 "1" です (ASCII 49)
$foo += 1;   // ここでは、$foo は整数です (2)
$foo = $foo + 1.3;  // ここでは、$foo は倍精度実数です (3.3)
$foo = 5 + "10 Little Piggies";    // $foo は整数です (15)
$foo = 5 + "10 Small Pigs";   // $foo は整数です (15)
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    最後の二つの例が奇妙に思える場合には、
    <link linkend="language.types.string.conversion">文字列変換</link>を
    参照ください。
   </simpara>
   <simpara>
    ある変数を強制的にある特定の型として評価させたい場合には、
    <link linkend="language.types.typecasting">型キャスト</link> の
    セクションを参照ください。
    ある変数の型を変更したい場合には、<function>settype</function> 
    を参照してください。
   </simpara>
   <para>
    本節の例をテストしたい場合には、例をカットアンドペーストし、
    次の行を挿入して動作を自分で確認下さい。
    <informalexample>
     <programlisting role="php">
echo "\$foo==$foo; type is " . gettype( $foo ) . "&lt;br&gt;\n";
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     配列への自動変換の動作は、現在、未定義です。
     <informalexample>
      <programlisting role="php">
$a = 1;       // $a は整数です。
$a[0] = "f";  // $a は配列になります。$a[0] には "f" が入ります。
      </programlisting>
     </informalexample>
    </para>
    <para>
     上の例で明らかに $a は配列になりますが、最初の要素は 'f' になります。
     次の例を見てみましょう。
     <informalexample>
      <programlisting role="php">
$a = "1";     // $a は文字列です。
$a[0] = "f";  // 文字列オフセットは何ですか? どうなりますか?
      </programlisting>
     </informalexample>
    </para>
    <para>
     PHPは文字列への添字を配列への添字と同じ構文を使用してサポートして
     いるため、上の例は、$a は最初の要素が "f" の配列となるのか
     "f" が文字列 $a の最初の文字になるのかが不明であるという問題を生じます。
    </para>
    <para>
     このため、最新バージョンの PHP 3.0.12 および PHP 4.0b3-RC4 では、
     この自動変換の結果は未定義(undefined)とみなします。
     しかし、修正方法が議論されています。
    </para>
   </note>

   <sect2 id="language.types.typecasting">
    <title>型キャスト</title>

    <para>
     PHP の型キャストは、C 言語と同様に動作します。つまり、
     変換しようとする型の?前をキャストする変数の前に括弧に入れて
     置きます。
     <informalexample>
      <programlisting role="php">
$foo = 10;   // $foo は整数です
$bar = (double) $foo;   // $bar は倍精度実数です
      </programlisting>
     </informalexample>
    </para>
    <para>
     ȩ用可能なキャストを以下に示します。
     <itemizedlist>
      <listitem>
       <simpara>(int), (integer) - 整数へのキャスト</simpara>
      </listitem>
      <listitem>
       <simpara>(real), (double), (float) - 倍精度実数へのキャスト</simpara>
      </listitem>
      <listitem>
       <simpara>(string) - 文字列へのキャスト</simpara>
      </listitem>
      <listitem>
       <simpara>(array) - 配列へのキャスト</simpara>
      </listitem>
      <listitem>
       <simpara>(object) - オブジェクトへのキャスト</simpara>
      </listitem>
      </itemizedlist>
     </para>
     <para>
     括弧の中でタブとスペースを使用することができることに注意してください。
     従って、次の文は、機能的に等価です。
     <informalexample>
      <programlisting role="php">
$foo = (int) $bar;
$foo = ( int ) $bar;
      </programlisting>
     </informalexample>
    </para>
    <para>
     型の間でキャストを行う際の動作は、必ずしも明確ではありません。
     例えば、次の例を見てましょう。
    </para>
    <para>
     スカラーまたは文字列変数から配列にキャストを行う時、
     変数は配列の最初の要素になります。
     <informalexample>
      <programlisting role="php">
$var = 'ciao';
$arr = (array) $var;
echo $arr[0];  // 'ciao' を出力します。
      </programlisting>
     </informalexample>
    </para>
  
    <para>
     スカラーまたは文字列変数からオブジェクトにキャストを行う時、
     変数はオブジェ¯トの属性の一つになります。
     その属性の名前は 'scalar' になります。
     <informalexample>
      <programlisting role="php">
$var = 'ciao';
$obj = (object) $var;
echo $obj-&gt;scalar;  // 'ciao' を出力します。
      </programlisting>
     </informalexample>
    </para>

   </sect2>
  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
