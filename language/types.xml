<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.73 $ -->
<!-- EN-Revision: 1.186 Maintainer: hirokawa Status: ready -->
<!-- CREDITS: takagi, shimooka -->
 <chapter xml:id="language.types" xmlns="http://docbook.org/ns/docbook">
  <title>型</title>

  <sect1 xml:id="language.types.intro">
   <title>導入</title>

   <simpara>
    PHP は、8 種類の基本型をサポートします。
   </simpara>

   <para>
    4 種類のスカラー型:

    <itemizedlist>

     <listitem>
      <simpara>
       <type>論理値 (boolean)</type>
      </simpara>
     </listitem>

     <listitem>
      <simpara>
       <type>整数 (integer)</type>
      </simpara>
     </listitem>

     <listitem>
      <simpara>
       <type>float</type> (浮動小数点数, '<type>double</type>' も同じ)
      </simpara>
     </listitem>

     <listitem>
      <simpara>
       <type>文字列 (string)</type>
      </simpara>
     </listitem>

    </itemizedlist>

    2 種類の複合型:

    <itemizedlist>

     <listitem>
      <simpara>
       <type>配列 (array)</type>
      </simpara>
     </listitem>

     <listitem>
      <simpara>
       <type>オブジェクト (object)</type>
      </simpara>
     </listitem>

    </itemizedlist>

    そして、最後に 2 種類の特別な型:

    <itemizedlist>

     <listitem>
      <simpara>
       <type>リソース (resource)</type>
      </simpara>
     </listitem>

     <listitem>
      <simpara>
       <type>ヌル (NULL)</type>
      </simpara>
     </listitem>

    </itemizedlist>

    本マニュアルでは、可読性を向上させるため、以下のような<link
    linkend="language.pseudo-types">擬似的な型</link>も使用します。

    <itemizedlist>

     <listitem>
      <simpara>
       <type>mixed</type>
      </simpara>
     </listitem>

     <listitem>
      <simpara>
       <type>number</type>
      </simpara>
     </listitem>

     <listitem>
      <simpara>
       <type>callback</type>
      </simpara>
     </listitem>

    </itemizedlist>
   そして擬似変数 <parameter>$...</parameter>。
  </para>
  <simpara>
    いくつかの場所で "double" 型を使用していることに気付くかもしれません。
    double は float と同じものだと考えてください。2 種類の名前が存在するのは、
    歴史的な理由によるものです。
  </simpara>

   <simpara>
    変数の型は、基本的にプログラマが設定するものではありません。
    その変数が使用される文脈に応じ、PHP が実行時に決定します。
   </simpara>
   <note>
    <simpara>
     もし<link linkend="language.expressions">式</link>の型と値を正確に知りたい場合は、
     <function>var_dump</function> 関数を使用してください。
    </simpara>
    <para>
     デバッグのために、単純に人間が読みやすい形で型を表示したい場合には
     <function>gettype</function> を使用してください。型をチェックする場合には
     <function>gettype</function> を使用しては<emphasis>いけません
     </emphasis>。<literal>is_<replaceable>type</replaceable></literal>
     関数を使用してください。いくつかの例を以下に示します。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$a_bool = TRUE;   // a boolean
$a_str  = "foo";  // a string
$a_str2 = 'foo';  // a string
$an_int = 12;     // an integer

echo gettype($a_bool); // prints out:  boolean
echo gettype($a_str);  // prints out:  string

// 数値であれば、4を足す
if (is_int($an_int)) {
    $an_int += 4;
}

// $bool が文字列であれば, それをprintする
// (そうでなければ何も出力されない)
if (is_string($a_bool)) {
    echo "String: $a_bool";
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </note>
   <simpara>
    ある変数の型を強制的に他の型に変換したい場合、変数を
    <link linkend="language.types.typecasting">キャスト</link> するか、
    <function>settype</function> 関数を使用します。
   </simpara>
   <simpara>
    変数は、その型に依存して異なった動作をする場合があることに注意してください。
    詳細な情報については、
    <link linkend="language.types.type-juggling">型の変換</link>
    のセクションを参照ください。
    また<link linkend="types.comparisons">PHP 型の比較表</link>
    もご覧ください。さまざまな型の変数の比較に関する例があります。
   </simpara>
  </sect1>

  <sect1 xml:id="language.types.boolean">
   <title>論理型 (boolean) </title>

   <simpara>
    論理型は、最も簡単な型です。<type>boolean</type> は、真偽の値を表します。
    この値は、&true; または &false; のどちらかになります。
   </simpara>

   <note>
    <simpara>
     論理型は、PHP 4 で導入されました。
    </simpara>
   </note>

   <sect2 xml:id="language.types.boolean.syntax">
    <title>構文</title>
    <para>
     boolean リテラルを指定するには、キーワード &true;
     または &false; を指定してください。
     両方とも大文字小文字に依存しません。
     <!-- technically they are just constants -->
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = True; // 値TRUEを$fooに代入する
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     通常、<type>boolean</type> 型の値を返す<link
     linkend="language.operators">演算子</link>を使用してから、
     <link linkend="language.control-structures">制御構造</link>にその結果を渡します。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
// == は、boolean型を返す演算子
if ($action == "show_version") {
    echo "バージョンは1.23です。";
}

// これは冗長
if ($show_separators == TRUE) {
    echo "<hr>\n";
}

// 上の例は次のように簡単に書くことができます。
if ($show_separators) {
    echo "<hr>\n";
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>

   <sect2 xml:id="language.types.boolean.casting">
    <title>boolean への変換</title>
    <simpara>
     <type>boolean</type> に明示的に変換を行うには、キャスト
     <literal>(bool)</literal> または <literal>(boolean)</literal>
     を使用します。しかし、演算子、関数、制御構造が <type>boolean</type>
     型の引数を必要とする場合には、値は自動的に変換されるため、
     多くの場合はキャストは不要です。
    </simpara>
    <simpara>
     <link linkend="language.types.type-juggling">型の相互変換</link>
     も参照ください。
    </simpara>

    <para>
     <type>boolean</type> に変換する場合、次の値は &false; とみなされます。

     <itemizedlist>
      <listitem>
       <simpara>
    <link linkend="language.types.boolean">boolean</link> の
    &false;
       </simpara>
      </listitem>
      <listitem>
       <simpara>
    <link linkend="language.types.integer">integer</link> の 0 (ゼロ)
       </simpara>

      </listitem>
      <listitem>
       <simpara>
    <link linkend="language.types.float">float</link> の
    0.0 (ゼロ)
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        空の<link linkend="language.types.string">文字列</link>、
        および<link linkend="language.types.string">文字列</link>の
        "0"
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        要素の数がゼロである <link linkend="language.types.array">配列
        </link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        ゼロを要素とする <link linkend="language.types.object">オブジェクト</link> (PHP 4のみ)
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        特別な値 <link linkend="language.types.null">NULL</link>
        (値がセットされていない変数を含む)
       </simpara>
      </listitem>
        <listitem>
         <simpara>空のタグから作成された <link linkend="ref.simplexml">SimpleXML</link>
         オブジェクト
         </simpara>
        </listitem>
     </itemizedlist>

     その他の値は全て &true; とみなされます (全ての
     <link linkend="language.types.resource">resource</link>を含みます)。
     <warning>
      <simpara>
         <literal>-1</literal> は、他のゼロでない数と同様に (正負によらず)
         &true; とみなされます。
      </simpara>
     </warning>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
var_dump((bool) "");        // bool(false)
var_dump((bool) 1);         // bool(true)
var_dump((bool) -2);        // bool(true)
var_dump((bool) "foo");     // bool(true)
var_dump((bool) 2.3e5);     // bool(true)
var_dump((bool) array(12)); // bool(true)
var_dump((bool) array());   // bool(false)
var_dump((bool) "false");   // bool(true)
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.types.integer">
   <title>整数</title>

   <simpara>
    <type>integer</type> は、Z = {..., -2, -1, 0, 1, 2, ...}という集合
    です。
   </simpara>

   <para>
    <link linkend="ref.gmp">任意精度整数 / GMP</link> および
    <link linkend="language.types.float">float</link>、
    <link linkend="ref.bc">任意精度整数 / BCMath</link> も参照ください。
   </para>

   <sect2 xml:id="language.types.integer.syntax">
    <title>構文</title>
    <simpara>
     整数 (integer) は、10 進数(基数 10)、16 進数 (基数 16)、8 進数 (基数 8)
     表記で指定可能です。オプションで、符号(-または+)を前に付けることが可能です。
    </simpara>
    <para>
     8 進数表記を使用する場合、数の前に <literal>0</literal> (ゼロ)
     を付ける必要があります。また、16 進数表記を使用するには、数の前に
     <literal>0x</literal> を付ける必要があります。
     <example>
      <title>整数リテラル</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = 1234; // 10進整数
$a = -123; // 負の数
$a = 0123; // 8進数 (10進数の83と等価)
$a = 0x1A; // 16進数 (10進数の26と等価)
?>
]]>
      </programlisting>
     </example>
     使用可能な整数リテラルの形式は以下のように定義されています。
     <informalexample>
      <programlisting>
<![CDATA[
decimal     : [1-9][0-9]*
            | 0

hexadecimal : 0[xX][0-9a-fA-F]+

octal       : 0[0-7]+

integer     : [+-]?decimal
            | [+-]?hexadecimal
            | [+-]?octal
]]>
      </programlisting>
     </informalexample>
     整数のサイズはプラットフォームに依存しますが、
     約 20 億 (32 ビット符号付) が一般的な値です。
     PHP は符号無し整数をサポートしていません。
     整数のサイズは <constant>PHP_INT_SIZE</constant> で決まります。
     最大値は、PHP 4.4.0 から PHP 5.0.5 までは <constant>PHP_INT_MAX</constant>
     でした。
    </para>
    <warning>
     <para>
       8 進数の整数値として不正な数字（例: 8 または 9）が渡された場合、
       数値の残りの部分は無視されます。
      <example>
       <title>おかしな 8 進数</title>
       <programlisting role="php">
<![CDATA[
<?php
var_dump(01090); // 010（8 進数）= 8（10 進数）
?>
]]>
       </programlisting>
      </example>
     </para>
    </warning>
   </sect2>

   <sect2 xml:id="language.types.integer.overflow">
    <title>整数のオーバーフロー</title>
    <para>
     <type>integer</type>型の範囲外の数を指定した場合、かわりに
     <type>float</type>として解釈されます。また、結果が
     <type>integer</type>型の範囲外の数となるような計算を行うと
     <type>float</type>が代わりに返されます。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$large_number =  2147483647;
var_dump($large_number);
// 出力: int(2147483647)

$large_number =  2147483648;
var_dump($large_number);
// 出力: float(2147483648)

// 2^31 から 2^32-1 までの値については、指定した 16 進表現整数を出力できる
var_dump( 0xffffffff );
// output: float(4294967295)

// 2^32-1 を超える値については、指定した 16 進表現整数を出力できない
var_dump( 0x100000000 );
// 出力: int(2147483647)

$million = 1000000;
$large_number =  50000 * $million;
var_dump($large_number);
// 出力: float(50000000000)
?>
]]>
      </programlisting>
     </informalexample>
     <warning>
      <simpara>
       不幸にして、過去のスクリプトエンジンにはバグがあり、
       負の数が含まれている場合に、常に正しく動作するわけではありませんでした。例えば、
       <literal>-50000 * $million</literal> を実行した場合、結果は、
       <literal>-429496728</literal> となりました。
       しかし、オペランドが共に正の場合は問題ありませんでした。
      </simpara>
      <simpara>
       この問題は PHP 4.1.0 で解決されました。
      </simpara>
     </warning>
    </para>
    <para>
     PHP には整数の割り算はありません。<literal>1/2</literal> は <type>
      float </type> 型の <literal>0.5</literal> になります。
     下方向の整数値に値を丸めるためにキャストを使用することができ、
     また、<function>round</function> 関数を使用することもできます。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
var_dump(25/7);         // float(3.5714285714286)
var_dump((int) (25/7)); // int(3)
var_dump(round(25/7));  // float(4)
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>

   <sect2 xml:id="language.types.integer.casting">
    <title>整数への変換</title>
    <simpara>
     <type>integer</type> に値を明示的に変換するには、キャスト
     <literal>(int)</literal> または <literal>(integer)</literal>
     のどちらかを使用してください。しかし、多くの場合、演算子、関数、制御構造が
     <type>integer</type> 引数を必要とする場合、値は自動的に変換されるため、
     キャストを使用する必要はありません。
     関数 <function>intval</function> を用いて値を整数に変換することも可能です。
    </simpara>
    <simpara>
     <link linkend="language.types.type-juggling">型の相互変換</link>
     を参照ください。
    </simpara>

    <sect3 xml:id="language.types.integer.casting.from-boolean">
     <title>
      <link linkend="language.types.boolean">booleans</link> から
     </title>
     <simpara>
      &false; は、<literal>0</literal> (ゼロ) となり、
      &true; は、<literal>1</literal> となります。
       </simpara>
    </sect3>

    <sect3 xml:id="language.types.integer.casting.from-float">
     <title>
      <link linkend="language.types.float">浮動小数点数</link>から
     </title>
     <simpara>
      float から整数に変換する場合、その数はゼロの方に丸められます。
     </simpara>

     <para>
      float が整数の範囲 (通常は <literal>+/- 2.15e+9 =
      2^31</literal>) を越える場合、結果は undefined となります。これは、
      その float が正しい整数の結果を得るために十分な精度を得られなかったからです。
      この場合、警告も通知も発生しません!
     </para>

     <warning>
      <para>
       未知の端数を <type>integer</type> にキャストしないでください。
       この場合、予期しない結果となることがあります。
       <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo (int) ( (0.1+0.7) * 10 ); // 7が出力されます!
?>
]]>
    </programlisting>
       </informalexample>
       より詳細な情報については、<link linkend="warn.float-precision">
        float の精度に関する注意</link>を参照ください。
      </para>
     </warning>
    </sect3>

    <sect3 xml:id="language.types.integer.casting.from-string">
     <title>文字列から</title>
     <simpara>
      <link linkend="language.types.string.conversion">文字列変換
      </link>を参照ください。
     </simpara>
    </sect3>

    <sect3 xml:id="language.types.integer.casting.from-other">
     <title>他の型から</title>
     <para>
      <caution>
       <simpara>
    整数への変換の動作は、他の型については定義されません。
    現在の動作は、その値がまず
    <link linkend="language.types.boolean.casting">論理値に変換された</link>
    場合と同じです。しかし、この動作は予告なく変更されることがありえるので、
    これを前提にしていはいけません。
       </simpara>
      </caution>
     </para>
    </sect3>
   </sect2>
  </sect1>

  <sect1 xml:id="language.types.float">
   <title>浮動小数点数</title>
   <para>
    ("float", "double", "実数" のような) 浮動小数点数は、次の構文により指定できます。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1.234;
$b = 1.2e3;
$c = 7E-10;
?>
]]>
     </programlisting>
    </informalexample>
    規約:
    <informalexample>
     <programlisting role="php">
<![CDATA[
LNUM          [0-9]+
DNUM          ([0-9]*[\.]{LNUM}) | ({LNUM}[\.][0-9]*)
EXPONENT_DNUM ( ({LNUM} | {DNUM}) [eE][+-]? {LNUM})
]]>
     </programlisting>
    </informalexample>
    float の大きさはプラットフォーム依存です。ただし、通常はおよそ 10
    進数で 14 桁の精度があり、最大値は ~1.8e308 (これは 64ビット IEEE
    フォーマットです) となります。
   </para>

   <warning xml:id="warn.float-precision">
    <title>浮動小数点数の精度</title>
    <para>
     <literal>0.1</literal> や <literal>0.7</literal> のようなシンプルな小数であっても、
     それを内部的な二進数表現に変換する際には、どうしても多少精度が落ちてしまいます。
     その結果、不思議な結果を引き起こすことがあります。たとえば、
     <literal>floor((0.1+0.7)*10)</literal> の結果はたいてい
     <literal>7</literal> となるでしょう。おそらくは
     <literal>8</literal> を想定していらっしゃるでしょうが、そのようにはなりません。
     これは、(この計算結果の) 内部的な値が
     <literal>7.9999999999...</literal> のようになっているからです。
    </para>
    <para>
     こうなる理由のひとつとして、「有限小数に変換できない分数がある」
     という事実があります。たとえば <literal>1/3</literal> を小数で表そうとすると
     <literal>0.3333333. . .</literal> となります。
    </para>
    <para>
     よって、小数の最後の桁を信用してはいけませんし、
     小数が等しいという比較を行ってはいけません。より高い精度が必要な場合には、
     <link linkend="ref.bc">任意精度数学関数</link>または
     <link linkend="ref.gmp">gmp</link> 関数を代わりに使用してください。
    </para>
   </warning>

   <sect2 xml:id="language.types.float.casting">
    <title>float への変換</title>
    <para>
     文字列型がどのようにして浮動小数点数に変換されるかに関する詳細な情報は、
     <link linkend="language.types.string.conversion">文字列の数値型への変換</link>
     のセクションをご覧ください。
     そのほかの型の浮動小数点数への変換については、整数型への変換と同様です。
     詳細は<link linkend="language.types.integer.casting">整数型への変換</link>
     のセクションをご覧ください。
     PHP 5 以降、オブジェクトを不動小数点数に変換しようとした場合には、
     通知がスローされます。
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.types.string">
   <title>文字列</title>
   <para>
    <type>string</type> は、文字が連結されたものです。PHP では、
    文字は 1 バイトと同じです。つまり、256 個の異なる文字を使用可能です。
    これは、PHP が Unicode をネイティブにサポートしていないことも意味します。
    いくつかの Unicode サポートについては<function>utf8_encode</function>
    および <function>utf8_decode</function> を参照してください。
   </para>
   <note>
    <simpara>
     文字列が非常に大きくなっても問題ありません。
     PHP に課せられる文字列のサイズの実用上の制限はありません。
     このため、長い文字列に関して恐れる必要は全くありません。
    </simpara>
   </note>
   <sect2 xml:id="language.types.string.syntax">
    <title>構文</title>
    <para>
     文字列リテラルは、3 つの異なる方法で指定することが可能です。
     <itemizedlist>

      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.single">引用符</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.double">二重引用符</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.heredoc">ヒアドキュメント構文</link>
       </simpara>
      </listitem>

     </itemizedlist>
    </para>
    <sect3 xml:id="language.types.string.syntax.single">
     <title>引用符</title>
     <para>
      文字列を指定する最も簡単な方法は、引用符 (文字
      <literal>'</literal>) で括ることです。
     </para>
     <para>
      引用符をリテラルとして指定するには、多くの他の言語と同様にバックスラッシュ
      (<literal>\</literal>) でエスケープする必要があります。
      バックスラッシュを引用符の前または文字列の最後に置きたい場合は、
      二重にする必要があります。この他の文字をエスケープする場合には、
      バックスラッシュも出力されることに注意してください! このため、
      通常はバックスラッシュ自体をエスケープする必要はありません。
      <note>
       <simpara>
        PHP 3 では、この場合、<literal>E_NOTICE</literal> レベルの警告が出力されます。
       </simpara>
      </note>
      <note>
       <simpara>
    他の二つの構文と異なり、
        <link linkend="language.variables">変数</link>と特殊文字のエスケープシーケンスは、
        引用符 (シングルクオート) で括られた文字列にある場合には展開<emphasis>されません</emphasis>。
       </simpara>
      </note>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
echo 'this is a simple string';

echo 'You can also have embedded newlines in
strings this way as it is
okay to do';

// 出力: Arnold once said: "I'll be back"
echo 'Arnold once said: "I\'ll be back"';

// 出力: You deleted C:\*.*?
echo 'You deleted C:\\*.*?';

// 出力: You deleted C:\*.*?
echo 'You deleted C:\*.*?';

// 出力: This will not expand: \n a newline
echo 'This will not expand: \n a newline';

// 出力: Variables do not $expand $either
echo 'Variables do not $expand $either';
?>
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect3>
    <sect3 xml:id="language.types.string.syntax.double">
     <title>二重引用符</title>
     <para>
      文字列が二重引用符 (") で括られた場合、
      PHP は、より多くの特殊文字のエスケープシーケンスを理解します。
     </para>
     <table>
      <title>エスケープされた文字</title>
      <tgroup cols="2">
       <thead>
    <row>
     <entry>記述</entry>
     <entry>意味</entry>
    </row>
       </thead>
       <tbody>
    <row>
     <entry><literal>\n</literal></entry>
     <entry>ラインフィード (LF またはアスキーの 0x0A (10))</entry>
    </row>
    <row>
     <entry><literal>\r</literal></entry>
     <entry>キャリッジリターン (CR またはアスキーの 0x0D (13))</entry>
    </row>
    <row>
     <entry><literal>\t</literal></entry>
     <entry>水平タブ (HT またはアスキーの 0x09 (9))</entry>
    </row>
    <row>
     <entry><literal>\\</literal></entry>
     <entry>バックスラッシュ</entry>
    </row>
    <row>
     <entry><literal>\$</literal></entry>
     <entry>ドル記号</entry>
    </row>
    <row>
     <entry><literal>\"</literal></entry>
        <entry>二重引用符</entry>
    </row>
    <row>
     <entry><literal>\[0-7]{1,3}</literal></entry>
     <entry>
      正規表現にマッチする文字シーケンスは、8 進数表記の 1 文字です。
        </entry>
    </row>
    <row>
     <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
     <entry>
      正規表現にマッチする文字シーケンスは、16 進数表記の 1 文字です。
     </entry>
    </row>
       </tbody>
      </tgroup>
     </table>
     <para>
      繰り返しますが、この他の文字をエスケープしようとした場合には、
      バックスラッシュも出力されます!
      PHP 5.1.1 より前のバージョンでは、<literal>\{$var}</literal>
      のバックスラッシュは出力されません。
     </para>
     <para>
      しかし、二重引用符で括られた文字列で最も重要なのは、
      変数名が展開されるところです。詳細は、<link
      linkend="language.types.string.parsing">文字列のパース</link>を参照ください。
     </para>
    </sect3>

    <sect3 xml:id="language.types.string.syntax.heredoc">
     <title>ヒアドキュメント</title>
     <simpara>
      文字列を区切る別の方法としてヒアドキュメント構文 ("&lt;&lt;&lt;")
      があります。この場合、ある ID (と、それに続けて改行文字)
      を <literal>&lt;&lt;&lt;</literal>
      の後に指定し、文字列を置いた後で、同じ ID を括りを閉じるために置きます。
     </simpara>
     <simpara>
      終端 ID は、その行の最初のカラムから始める必要があります。
      使用するラベルは、PHP の他のラベルと同様の命名規則に従う必要があります。
      つまり、英数字およびアンダースコアのみを含み、
      数字でない文字またはアンダースコアで始まる必要があります。
     </simpara>

     <warning>
      <simpara>
       非常に重要なことですが、終端 ID がある行には、セミコロン
       (<literal>;</literal>) 以外の他の文字が含まれていてはならないことに注意しましょう。
       これは、特に ID はインデントしてはならないということ、
       セミコロンの前に空白やタブを付けてはいけないことを意味します。
       終端 ID の前の最初の文字は、使用するオペレーティングシステムで定義された
       改行である必要があることにも注意を要します。
       これは、例えば、Macintoshでは <literal>\r</literal> となります。
       最後の区切り文字 (たいていはその後にセミコロンが続きます)
       の後にもまた、改行を入れる必要があります。
      </simpara>
      <simpara>
       この規則が破られて終端 ID が "clean" でない場合、
       終端 ID と認識されず、PHP はさらに終端 ID を探し続けます。
       適当な終了 ID がみつからない場合、
       スクリプトの最終行でパースエラーが発生します。
      </simpara>
      <para>
       ヒアドキュメント構文を、クラスのメンバの初期化に用いることはできません。
       他の文字列構文を利用してください。
       <example>
        <title>間違った例</title>
        <programlisting role="php">
<![CDATA[
<?php
class foo {
    public $bar = <<<EOT
bar
EOT;
}
?>
]]>
        </programlisting>
       </example>
      </para>
     </warning>

     <para>
      ヒアドキュメントは二重引用符を使用しませんが、
      二重引用符で括られた文字列と全く同様に動作します。
      しかし、この場合でも上記のリストでエスケープされたコードを使用することも可能です。
      変数は展開されますが、文字列の場合と同様に
      ヒアドキュメントの内部で複雑な変数を表わす場合には注意が必要です。
      <example>
       <title>ヒアドキュメントで文字列を括る例</title>
       <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
Example of string
spanning multiple lines
using heredoc syntax.
EOD;

/* 変数を使用するより複雑な例 */
class foo
{
    var $foo;
    var $bar;

    function foo() {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo <<<EOT
My name is "$name". I am printing some $foo->foo.
Now, I am printing some {$foo->bar[1]}.
This should print a capital 'A': \x41
EOT;
?>
]]>
       </programlisting>
      </example>
     </para>

     <note>
      <para>
       ヒアドキュメントは PHP 4 で追加されました。
      </para>
     </note>

    </sect3>

    <sect3 xml:id="language.types.string.parsing">
     <title>変数のパース</title>
     <simpara>
      スクリプトが二重引用符で括られるかヒアドキュメントで指定された場合、
      その中の変数はパースされます。
     </simpara>
     <simpara>
      構文の型には、<link
      linkend="language.types.string.parsing.simple">単純な</link>構文と
      <link linkend="language.types.string.parsing.complex">複雑な
      </link>構文の 2 種類があります。簡単な構文は、最も一般的で便利です。
      この構文では、変数、配列値やオブジェクトのプロパティをパースすることが可能です。
     </simpara>
     <simpara>
      複雑な構文は、PHP 4 で導入されました。
      この構文は、式を波括弧で括ることにより認識されます。
     </simpara>
     <sect4 xml:id="language.types.string.parsing.simple">
      <title>簡単な構文</title>
      <simpara>
       ドル記号 (<literal>$</literal>) を見付けると、
       パーサは、有効な変数名を形成することが可能な最長のトークンを取得します。
       変数名の終りを明示的に指定したい場合は、変数名を波括弧で括ってください。
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
$beer = 'Heineken';
echo "$beer's taste is great"; // 動作します。"'" は変数名として無効な文字です。
echo "He drunk some $beers"; // 動作しません。's' は、変数名として有効な文字です。
echo "He drunk some ${beer}s"; // 動作します。
echo "He drank some {$beer}s"; // 動作します。
]]>
       </programlisting>
      </informalexample>
      <simpara>
       同様に、配列添字とオブジェクトのプロパティをパースすることも可能です。
       配列添字の場合、閉じ角括弧 (']') は添字の終りを意味し、
       オブジェクトのプロパティの場合、同じ規則が簡単な変数として適用されます。
       しかし、オブジェクトプロパティには、変数の場合のような手法はありません。

       <!-- XXX isn't &true; :(, this would be the trick
       Also, the same trick with curly-braces works if you
       want to limit the greediness of parsers.
       -->

      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// これらの例は、文字列の内部で配列を使用する際のものです。
// 文字列の外部で使用する場合は、配列の文字列キーは常にクオート
// しましょう。また、{波括弧} も使用しないようにしましょう。

// すべてのエラーを表示するようにします。
error_reporting(E_ALL);

$fruits = array('strawberry' => 'red' , 'banana' => 'yellow');

// シングルクオートの外では動作が異なることに注意してください。
echo "A banana is $fruits[banana].";

// 動作します。
echo "A banana is {$fruits['banana']}.";

// 動作しますが、以下に説明するように
// PHP はまず banana という名前の定数を探します。
echo "A banana is {$fruits[banana]}.";

// 動作しません。波括弧を使用しましょう。これはパースエラーとなります。
echo "A banana is $fruits['banana'].";

// 動作します。
echo "A banana is " . $fruits['banana'] . ".";

// 動作します。
echo "This square is $square->width meters broad.";

// 動作しません。解決策については、複雑な構文を参照ください。
echo "This square is $square->width00 centimeters broad.";
?>
]]>
<!-- XXX this won't work:
echo "This square is $square->{width}00 centimeters broad.";
// XXX: php developers: it would be consequent to make this work.
// XXX: like the $obj->{expr} syntax outside a string works,
// XXX: analogously to the ${expr} syntax for variable var's.
-->
       </programlisting>
      </informalexample>
      <simpara>
       より複雑な場合は、複雑な構文を使用する必要があります。
      </simpara>
     </sect4>

     <sect4 xml:id="language.types.string.parsing.complex">
      <title>複雑な (波括弧) 構文</title>
      <simpara>
       この構文が「複雑(complex)な構文」と呼ばれているのは、
       構文が複雑であるからではなく、
       この方法では複雑な式を含めることができるからです。
      </simpara>
      <simpara>
       事実、この構文により、文字列の中に名前空間内のあらゆる値を含めることが可能です。
       文字列の外側に置く場合と同様に式を書き、これを
       { と } の間に含めてください。'{' はエスケープすることができないため、
       この構文は $ が { のすぐ後に続く場合にのみ認識されます
       (リテラル "{$" を指定するには、"{\$" を使用してください)。
       以下のいくつかの例を見ると理解しやすくなるでしょう。
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// すべてのエラーを表示します
error_reporting(E_ALL);

$great = 'fantastic';

// うまく動作しません。出力: This is { fantastic}
echo "This is { $great}";

// うまく動作します。出力: This is fantastic
echo "This is {$great}";
echo "This is ${great}";

// 動作します
echo "This square is {$square->width}00 centimeters broad.";

// 動作します
echo "This works: {$arr[4][3]}";

// これが動作しない理由は、文字列の外で $foo[bar]
// が動作しない理由と同じです。
// 言い換えると、これは動作するともいえます。しかし、
// PHP はまず最初に foo という名前の定数を探すため、
// E_NOTICE レベルのエラー(未定義の定数) となります。
echo "This is wrong: {$arr[foo][3]}";

// 動作します。多次元配列を使用する際は、
// 文字列の中では必ず配列を波括弧で囲むようにします。
echo "This works: {$arr['foo'][3]}";

// 動作します
echo "This works: " . $arr['foo'][3];

echo "You can even write {$obj->values[3]->name}";

echo "This is the value of the var named $name: {${$name}}";
?>
]]>
<!-- maybe it's better to leave this out??
// this works, but i disencourage its use, since this is NOT
// involving functions, rather than mere variables, arrays and objects.
$beer = 'Heineken';
echo "I'd like to have another {${ strrev('reeb') }}, hips";
 -->
       </programlisting>
      </informalexample>

      <note>
       <para>
        関数とメソッドコールは PHP 5 から動作します。
       </para>
      </note>
      <note>
       <para>
        文字列内での変数のパースは、文字列の連結に比べてよりメモリを消費します。
        メモリの使用量をできるだけ抑えた PHP スクリプトを書きたいのなら、
        変数のパースを用いるのではなく、連結演算子 (.) を使用しましょう。
       </para>
      </note>
     </sect4>
    </sect3>

    <sect3 xml:id="language.types.string.substr">
     <title>文字列への文字単位のアクセスと修正</title>
     <para>
      <varname>$str[42]</varname> のように、
      角括弧を使用してゼロから始まるオフセットを指定すると、
      文字列内の任意の文字にアクセスし、修正することが可能です。
      つまり、文字列を文字の配列として考えるわけです。
      波括弧の後に任意の文字をゼロから始まるオフセットで指定することにより、
      文字列内の文字にアクセス/修正することが可能です。
     </para>
     <note>
      <simpara>
       <varname>$str{42}</varname> のように波括弧を使用してアクセスすることも可能です。
       しかし、角括弧を使用する方法のほうが推奨されます。
       なぜなら、{波括弧} 形式は PHP 6 で廃止される予定だからです。
      </simpara>
     </note>
     <para>
      <example>
       <title>文字列の例</title>
       <programlisting role="php">
<![CDATA[
<?php
// 文字列の最初の文字を取得します
$str = 'This is a test.';
$first = $str[0];

// 文字列の 3 番目の文字を取得します
$third = $str[2];

// 文字列の最後の文字を取得します
$str = 'This is still a test.';
$last = $str[strlen($str)-1];

// 文字列の最後の文字を変更します
$str = 'Look at the sea';
$str[strlen($str)-1] = 'e';

// {} を使用した、もうひとつの方法 (PHP 6 で廃止予定) です
$third = $str{2};
?>
]]>
       </programlisting>
      </example>
     </para>
     <note>
      <para>
       その他の型の変数に対して <literal>[]</literal> や <literal>{}</literal>
       でアクセスすると、何もメッセージを出さずに単に &null; を返します。
      </para>
     </note>
    </sect3>

   </sect2><!-- end syntax -->

   <sect2 xml:id="language.types.string.useful-funcs">
    <title>便利な関数および演算子</title>
    <para>
     文字列は、'.' (ドット) 結合演算子で結合することが可能です。'+'
     (付加) 演算子はこの例では出てこないことに注意してください。詳細については
     <link linkend="language.operators.string">文字列演算子</link>
     を参照ください。
    </para>
    <para>
     文字列の修正を行う場合には、便利な関数がたくさん用意されています。
    </para>
    <simpara>
     一般的な関数については、<link linkend="ref.strings">文字列関数の節</link>
     を参照ください。高度な検索/置換を行う正規表現関数については
     <link linkend="ref.pcre">Perl</link> および
     <link linkend="ref.regex">POSIX 拡張</link> の 2 種類がありますが、
     それぞれの節を参照ください。
    </simpara>
    <simpara>
     <link linkend="ref.url">URL 文字列用関数</link>や文字列の暗号化/
     復号用の関数 (<link linkend="ref.mcrypt">mcrypt</link> および
     <link linkend="ref.mhash">mhash</link>) もあります。
    </simpara>
    <simpara>
     最後に、探しているものがまだ見付からない場合には、
     <link linkend="ref.ctype">文字型の関数</link>も参照ください。
    </simpara>
   </sect2>

   <sect2 xml:id="language.types.string.casting">
    <title>文字列への変換</title>

    <para>
     <literal>(string)</literal> キャストや <function>strval</function>
     関数を使って変数を文字列へ変換することができます。
     文字列型を必要とする式のスコープにおいて、文字列への変換は自動的に行われます。
     <function>echo</function> や <function>print</function> 関数を使うとき、
     あるいは可変変数を文字列を比較するときにこの自動変換が行われます。
     マニュアルの<link linkend="language.types">型</link> と
     <link linkend="language.types.type-juggling">型の相互変換</link>
     の項を読むとわかりやすいでしょう。
     <function>settype</function>も参照してください。
    </para>

    <para>
     <type>boolean</type> の &true; は文字列の <literal>"1"</literal> に、
     &false; は <literal>""</literal> (空文字列) に変換されます。
     これにより boolean と文字列の値を相互に変換することができます。
    </para>
    <para>
     <type>integer</type> (整数) や浮動小数点数 (<type>float</type>) は
     その数値の数字として文字列に変換されます (指数の表記や浮動小数点数を含めて)。
    </para>
    <note>
     <para>
      小数点を表す文字は、スクリプトのロケール (LC_NUMERIC カテゴリ)
      によって決まります。
      <function>setlocale</function> を参照ください。
     </para>
    </note>
    <para>
     配列は常に <literal>"Array"</literal> という文字列に変換されるので、
     <type>array</type> の中を見るために <function>echo</function> や
     <function>print</function> を使ってダンプさせることはできません。
     一つの要素を見るためには、<literal>echo $arr['foo']</literal>
     のようにしてください。内容の全てをダンプ/見るためには以降の TIP をご覧ください。
    </para>
    <para>
     PHP 4 のオブジェクトは、常に <literal>"Object"</literal> という文字列に変換されます。
     デバッグ等のために <type>object</type> の内部の変数を出力するような場合には、
     以下をご覧ください。オブジェクトがなんという名前のクラスの
     インスタンスなのかを知るには <function>get_class</function> をご覧ください。
    </para>
    <para>
     リソースは常に <literal>"Resource id #1"</literal>
     という文字列に変換されます。<literal>1</literal> は実行中の
     PHP によって割り当てられる
     <type>resource</type> のユニークな番号です。
     リソースの型を知るためには <function>get_resource_type</function>
     を使用してください。
    </para>
    <para>
     &null; は常に空文字列に変換されます。
    </para>

    <para>
     以上に述べたように、配列、オブジェクト、リソースをプリントアウトしても
     その値に関する有益な情報を得られるわけではありません。
     デバッグのために値を出力するのによりよい方法が知りたければ、
     <function>print_r</function> や
     <function>var_dump</function> を参照ください。
    </para>

    <para>
     PHP 変数を恒久的に保存するための文字列に変換することもできます。
     この方法はシリアライゼーションと呼ばれ、
     <function>serialize</function> 関数によって実現できます。
     <link linkend="ref.wddx">WDDX</link> サポートを有効にして PHP
     をセットアップすれば、PHP 変数を XML 構造にシリアライズすることもできます。
    </para>
   </sect2>

   <sect2 xml:id="language.types.string.conversion">
    <title>文字列の変換</title>

    <simpara>
     数値として文字列が評価された時、結果の値と型は次のように定義されます。
    </simpara>
    <simpara>
     文字列は、'.'、'e'、'E' のどれかが含まれている場合は
     <type>float</type>、それ以外は整数として評価されます。
    </simpara>
    <para>
     文字列の最初の部分により値が決まります。文字列が、
     有効な数値データから始まる場合、この値が使用されます。その他の場合、
     値は 0 (ゼロ) となります。有効な数値データは符号(オプション)の後に、
     1 つ以上の数字 (オプションとして小数点を 1 つ含む)、
     オプションとして指数部が続きます。指数部は 'e' または 'E' の後に
     1 つ以上の数字が続く形式です。
    </para>
    <simpara>
     最初の式が文字列の場合、変数の型は 2 番目の式に依存します。
    </simpara>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = 1 + "10.5";              // $foo は float です (11.5)
$foo = 1 + "-1.3e3";            // $foo は float です (-1299)
$foo = 1 + "bob-1.3e3";         // $foo は integer です (1)
$foo = 1 + "bob3";              // $foo は integer です (1)
$foo = 1 + "10 Small Pigs";     // $foo は integer です (11)
$foo = 1 + "10 Little Piggies"; // $foo は integer です (11)
$foo = "10.0 pigs " + 1;        // $foo は integer です (11)
$foo = "10.0 pigs " + 1.0;      // $foo は float です (11)
?>
]]>
     </programlisting>
    </informalexample>
    <simpara>
     この変換に関する詳細は、Unix のマニュアルページで
     strtod(3) を参照ください。
    </simpara>
    <para>
     本節の例を試したい場合、その例をカットアンドペーストしてから
     動作を確認するために次の行を挿入してください。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
echo "\$foo==$foo; type is " . gettype ($foo) . "<br>\n";
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     (C 言語で行われるように) 数値に変換することで
     一つの文字のコードを取得できると期待してはいけません。
     文字と文字コードを相互に変換するには <function>ord</function>
     および <function>chr</function> 関数を使用してください。
    </para>

   </sect2>
  </sect1><!-- end string -->

  <sect1 xml:id="language.types.array">
   <title>配列</title>

   <para>
    PHP の配列は、実際には順番付けられたマップです。マップは型の一種で、
    <emphasis>値</emphasis>を<emphasis>キー</emphasis>に関連付けます。
    この型は、いくつかの手法で最適化されます。このため、
    実際の配列またはリスト (ベクトル)、(あるマップの実装である)
    ハッシュテーブル、ディレクトリ、コレクション、スタック、
    キュー等として使用することが可能です。
    PHP の配列には他の PHP 配列を値として保持することができるため、
    非常に簡単にツリー構造を表現することが可能です。
   </para>
   <para>
    これらのデータ構造に関する説明は本マニュアルの範囲外ですが、
    これらの構造に各々に関する例を少なくとも一つ見付けることが可能です。
    この分野は広範囲にまたがるので、
    より詳細な情報については他の書籍を参照ください。
   </para>

   <sect2 xml:id="language.types.array.syntax">
    <title>構文</title>

    <sect3 xml:id="language.types.array.syntax.array-func">
     <title><function>array</function> で指定</title>
     <para>
      <type>配列</type> は、言語に組み込まれた
      <function>array</function> で作成することが可能です。この構造は、
      特定の数のカンマで区切られた
      <literal><replaceable>key</replaceable> =&gt; <replaceable
      >value</replaceable></literal> の組を引数とします。
     </para>
     <para>
      <synopsis>
array( <optional> <replaceable>key</replaceable> =&gt; </optional> <replaceable
>value</replaceable>
     , ...
     )
// <replaceable>key</replaceable> は、<type>文字列</type>または
// 非負の<type>整数</type>です。
// <replaceable>value</replaceable> に制約はありません.
      </synopsis>
     </para>
     <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array("foo" => "bar", 12 => true);

echo $arr["foo"]; // bar
echo $arr[12];    // 1
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      <varname>key</varname> は、<type>整数</type> または
      <type>文字列</type>です。
      あるキーが、<type>整数</type>の標準的な表現形式である場合、
      そのように解釈されます (つまり、<literal>"8"</literal> は
      <literal>8</literal> として解釈されます。一方、
      <literal>"08"</literal> は <literal>"08"</literal> として解釈されます)。
      <varname>key</varname> に浮動小数点数値を指定すると、
      その値は <type>integer</type> に切り詰められます。
      PHP においては添字配列と連想配列の間に違いはなく、配列型は 1 つだけで、
      整数または文字列のインデックスを使用することができます。
     </para>
     <para>
      値には、PHP の全ての型を使用することができます。
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array("somearray" => array(6 => 5, 13 => 9, "a" => 42));

echo $arr["somearray"][6];    // 5
echo $arr["somearray"][13];   // 9
echo $arr["somearray"]["a"];  // 42
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      キーを省略した場合、整数添字の最大値が使用され、
      新しいキーはその最大値 +1 となります。整数値は負の数とすることができ、
      負の添字についても同様となります。例えば、最高時の添字が <literal>-6</literal>
      の場合、次のキーは <literal>-5</literal> となります。
      整数添字がまだ存在しない場合、キーは <literal>0</literal> (ゼロ) となります。
      値が既に代入されているキーを指定した場合、元の値は上書きされます。
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// この配列は以下の配列と同じです ...
array(5 => 43, 32, 56, "b" => 12);

// この配列は上の配列と同じです
array(5 => 43, 6 => 32, 7 => 56, "b" => 12);
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <warning>
      <simpara>
       PHP 4.3.0 以降、上記のような添字生成動作は変更されました。
       現在では、配列に追加する際に、その配列の最大添字が負である場合は
       次の添字はゼロ (<literal>0</literal>) となります。
       以前は、正の添字の場合と同様に新しい添字は最大添字に +1
       したものにセットされていました。
      </simpara>
     </warning>
     <para>
      キーとして &true; を使用した場合、
      <type>整数</type>型の <literal>1</literal> がキーとして解釈されます。
      キーとして &false; を使用した場合、
      <type>整数</type>型の <literal>0</literal> がキーとして解釈されます。
      キーとして <literal>NULL</literal> を使用した場合、
      空の文字列として評価されます。キーとして空の文字列を使用すると、
      空の文字列のキーとその値を作成 (または上書き) します。
      空の括弧を用いた場合と同じではありません。
     </para>
     <para>
      配列またはオブジェクトをキーとして使用することはできません。
      これを行なうと、warning: <literal>Illegal offset type</literal>
      を発生します。
     </para>
    </sect3>

    <sect3 xml:id="language.types.array.syntax.modifying">
     <title>角括弧構文で作成/修正</title>
     <para>
      明示的に値を設定することにより、既存の配列を修正することも可能です。
     </para>
     <para>
      これは、角括弧の中にキーを指定し、配列に値を代入することにより行います。
      キーを省略することも可能です。この場合、空の角括弧
      ("<literal>[]</literal>") の変数名として追加してください。
      <synopsis>
$arr[<replaceable>key</replaceable>] = <replaceable>value</replaceable>;
$arr[] = <replaceable>value</replaceable>;
// <replaceable>key</replaceable> は <type>文字列</type> または
// 非負の<type>整数</type>のどちらかです。

// <replaceable>value</replaceable> は何でもかまいません
      </synopsis>
      <varname>$arr</varname> がまだ存在しない場合、作成されます。
      配列を指定する別の手段でもあります。ある値を変更するには、
      新しい値に値を代入します。特定のキー/値の組を削除したい場合には、
      <function>unset</function> を使用する必要があります。
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array(5 => 1, 12 => 2);

$arr[] = 56;    // このスクリプトのこの位置に記述した場合、
                // $arr[13] = 56; と同じです

$arr["x"] = 42; // キー"x"の新しい要素を配列に追加します

unset($arr[5]); // 配列から要素を削除します

unset($arr);    // 配列全体を削除します
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <note>
      <para>
       上記のように、キーを省略して新規要素を追加する場合、
       追加される数値添字は、使用されている添字の最大値 +1 になります。
       既に値が割り当てられているキーを指定した場合には、
       値は上書きされます。
      </para>
      <para>
       <warning>
        <simpara>
         PHP 4.3.0 以降、上記のような添字生成動作は変更されました。
         現在では、配列に追加する際に、
         その配列の最大添字が負である場合は次の添え字はゼロ
         (<literal>0</literal>) となります。
         以前は、正の添字の場合と同様に新しい添字は最大添字に +1
         したものがセットされました。
        </simpara>
       </warning>
      </para>
      <para>
       次のキー生成において、オフセットとして使われる整数値
       (添字の最大値) に対応するエントリーが、
       必ずしも配列内に存在するわけではないことに注意してください。
       しかし、その値は、多くの場合、
       配列にある整数のキー値の最大値と等しいはずです。以下に例を示します。
      </para>

      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// 簡単な配列を生成します。
$array = array(1, 2, 3, 4, 5);
print_r($array);

// 全てのアイテムを削除しますが、配列自体は削除しないでおきます。
foreach ($array as $i => $value) {
    unset($array[$i]);
}
print_r($array);

// アイテムを追加します(新しい添え字は0ではなく
// 5となることに注意)
$array[] = 6;
print_r($array);

// 添え字を振りなおします。
$array = array_values($array);
$array[] = 7;
print_r($array);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
Array
(
    [0] => 1
    [1] => 2
    [2] => 3
    [3] => 4
    [4] => 5
)
Array
(
)
Array
(
    [5] => 6
)
Array
(
    [0] => 6
    [1] => 7
)
]]>
       </screen>
      </informalexample>

     </note>
    </sect3>

   </sect2><!-- end syntax -->

   <sect2 xml:id="language.types.array.useful-funcs">
    <title>有用な関数</title>
    <para>
     配列で使用する便利な関数がたくさんあります。
     <link linkend="ref.array">配列関数</link> の節を参照ください。
    </para>
    <note>
     <para>
      <function>unset</function>関数は配列のキーを削除することが出来ます。
      ただし、これによってインデックスの再構築が行われるわけではないことに
      注意してください。
      "通常の整数添字" (0 から始まり、1 つずつ増加) のみを使用している場合、
      <function>array_values</function>
      を用いてインデックスを再構築することができます。
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$a = array(1 => 'one', 2 => 'two', 3 => 'three');
unset($a[2]);
/* これにより配列は以下の様に定義されます。
   $a = array( 1 => 'one', 3 => 'three');
   以下ではありません：
   $a = array( 1 => 'one', 2 => 'three');
*/

$b = array_values($a);
// bは、array(0 => 'one', 1 =>'three')となります
?>
]]>
       </programlisting>
      </informalexample>

     </para>
    </note>
    <para>
     配列専用の制御構造として<link
     linkend="control-structures.foreach">foreach</link> があります。
     この構造は、配列の要素に簡単に連続的にアクセスする手段を提供します。
    </para>
   </sect2>

   <sect2 xml:id="language.types.array.donts">
    <title>配列ですべきこととしてはならないこと</title>

    <sect3 xml:id="language.types.array.foo-bar">
     <title>なぜ、<literal>$foo[bar]</literal> は使用できないのか?</title>
     <para>
      連想配列の添字の前後は常に引用符で括る必要があります。
      例えば、$foo[bar] ではなく $foo['bar'] を使用してください。
      しかし、$foo[bar] はなぜ誤りなのでしょうか?
      古いスクリプトで次のような構文を見たことがあるかもしれません。
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$foo[bar] = 'enemy';
echo $foo[bar];
// etc
?>
]]>
       </programlisting>
      </informalexample>
      これは間違っていますが、動作します。では、なぜ間違っているのでしょう?
      その理由は、このコードには文字列 ('bar' - 引用符で括られている)
      ではなく未定義の定数 (bar) が使用されており、PHP
      が同じ名前の定数を不幸にして同じコードの中に定義する可能性があるためです。
      下位互換性の維持のため、未定義の定数は同じ名前の文字列に自動的に変換されます。
      そのため、このコードは動作します。
      例えば、<constant>bar</constant> という名前の定義されていない定数があるとすると、
      PHP は <literal>'bar'</literal> という文字列でそれを置換して使用します。
     </para>
     <note>
      <simpara>
       これは、添字を<emphasis>常に</emphasis>クォートするという意味ではありません。
       <link linkend="language.constants">定数</link>や
       <link linkend="language.variables">変数</link>
       を添字として使う際には、クォートしてしまうと PHP
       はそれを解釈できなくなってしまいます。
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
error_reporting(E_ALL);
ini_set('display_errors', true);
ini_set('html_errors', false);
// 単純な配列
$array = array(1, 2);
$count = count($array);
for ($i = 0; $i < $count; $i++) {
    echo "\nChecking $i: \n";
    echo "Bad: " . $array['$i'] . "\n";
    echo "Good: " . $array[$i] . "\n";
    echo "Bad: {$array['$i']}\n";
    echo "Good: {$array[$i]}\n";
}
?>
]]>
       </programlisting>
      </informalexample>
      &example.outputs;
      <screen>
<![CDATA[
Checking 0:
Notice: Undefined index:  $i in /path/to/script.html on line 9
Bad:
Good: 1
Notice: Undefined index:  $i in /path/to/script.html on line 11
Bad:
Good: 1

Checking 1:
Notice: Undefined index:  $i in /path/to/script.html on line 9
Bad:
Good: 2
Notice: Undefined index:  $i in /path/to/script.html on line 11
Bad:
Good: 2
]]>
      </screen>
     </note>
     <para>
      この具体例を以下に示します。
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// エラーを全て表示するよう設定
error_reporting(E_ALL);

$arr = array('fruit' => 'apple', 'veggie' => 'carrot');

// 正しい
print $arr['fruit'];  // apple
print $arr['veggie']; // carrot

// 間違い。これは動作しますが、未定義の定数fruitを使用しているため、
// 同時にE_NOTICEレベルのPHPエラーを発生します
//
// Notice: Use of undefined constant fruit - assumed 'fruit' in...
print $arr[fruit];    // apple

// 検証のため、定数を定義してみましょう。
// fruitという名前の定数に値'veggie'を代入します。
define('fruit','veggie');

// ここでは、出力が異なることに注意してください。
print $arr['fruit'];  // apple
print $arr[fruit];    // carrot

// 以下は文字列の中であるためOKです。定数は、文字列の中では解釈されな
// いため、E_NOTICEエラーはここでは発生しません。
print "Hello $arr[fruit]";      // Hello apple

// 例外が１つあり、文字列の中で波括弧で配列を括った場合には、
// 定数が解釈されます
print "Hello {$arr[fruit]}";    // Hello carrot
print "Hello {$arr['fruit']}";  // Hello apple

// これは動作せず、以下のようなパースエラーを発生します:
// Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING'
// 文字列の中でスーパーグローバルを使用した場合も無論同様です。
print "Hello $arr['fruit']";
print "Hello $_GET['foo']";

// 文字列結合で同じことをすることもできます。
print "Hello " . $arr['fruit']; // Hello apple
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      <function>error_reporting</function> で
      (<constant>E_ALL</constant> を指定する等により)
      <literal>E_NOTICE</literal> レベルのエラー出力を有効にした場合、
      上記のエラーが出力されます。
      デフォルトでは、<link linkend="ini.error-reporting">
      error_reporting</link> はこれらを表示しない設定になっています。
     </para>
     <para>
      <link linkend="language.types.array.syntax"
      >構文</link>の節に記述したように、角括弧
      ('<literal>[</literal>' および '<literal>]</literal>')
      の間には、式がなければなりません。これは、
      次のように書くことが可能であることを意味します。
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
echo $arr[somefunc($bar)];
?>
]]>
       </programlisting>
      </informalexample>
      これは、関数の戻り値を配列の添字として使用する例です。PHP
      は定数についても認識します。以下のような <literal>E_*</literal>
      の使用例を見たことがあるかもしれません。
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[E_ERROR]   = "A fatal error has occured";
$error_descriptions[E_WARNING] = "PHP issued a warning";
$error_descriptions[E_NOTICE]  = "This is just an informal notice";
?>
]]>
       </programlisting>
      </informalexample>
      最初の例の <literal>bar</literal> と全く同様に
      <literal>E_ERROR</literal> も有効な添字であることに注意してください。
      しかし、実際には最後の例は次のように書くことと同じです。
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[1] = "A fatal error has occured";
$error_descriptions[2] = "PHP issued a warning";
$error_descriptions[8] = "This is just an informal notice";
?>
]]>
       </programlisting>
      </informalexample>
      これは、<literal>E_ERROR</literal> が <literal>1</literal>
      と等しいこと等によります。
     </para>
     <para>
      では、なぜ <literal>$foo[bar]</literal> は動作することが可能なのでしょう?
      それは、<literal>bar</literal> が定数式であることを
      期待される構文で使用されているためです。しかし、この場合、
      <literal>bar</literal> という名前の定数は存在しません。PHP は、
      この場合、あなたが文字列<literal>"bar"</literal> のようにリテラル
      <literal>bar</literal> を指定したが引用符を忘れたと仮定します。
     </para>
     <sect4 xml:id="language.types.array.foo-bar.why">
      <title>では、なぜ間違っているのでしょう?</title>
      <para>
       将来的に、PHP は他の定数またはキーワードを追加したいと思うかもしれず、
       問題となる可能性があります。例えば、現在でも、
       単語 <literal>empty</literal> および
       <literal>default</literal>を使用することはできません。
       これは、これらが特別な
       <link linkend="reserved">予約済みのキーワード</link>であるためです。
      </para>
      <note>
       <simpara>
        二重引用符で括られた<type>文字列</type>の中では
        引用符で配列の添字を括らないことができ、このため、
        <literal>"$foo[bar]"</literal> は有効です。
        この理由の詳細については、上記の例や
        <link linkend="language.types.string.parsing">
        文字列中での変数のパース</link>を参照してください。
       </simpara>
      </note>
      <note>
       <simpara>
    二重引用符で括られた <type>string</type> の中で他の構文が有効です。
    より詳細な情報については、<link
    linkend="language.types.string.parsing">文字列の中の変数
    </link> を参照ください。
       </simpara>
      </note>
     </sect4>
    </sect3>
   </sect2>

   <sect2 xml:id="language.types.array.casting">
    <title>配列への変換</title>

    <para>
     <type>integer</type>, <type>float</type>, <type>string</type>,
     <type>boolean</type>, <type>resource</type>のいずれの型においても、
     <type>array</type> に変換する場合、
     最初のスカラー値が割り当てられている一つの要素 (添字は 0)
     を持つ配列を得ることになります。
    </para>

    <para>
     <type>object</type>を配列にする場合には、配列の要素として
     オブジェクトの属性 (メンバ変数) を持つ配列を得ることになります。
     添字はメンバ変数名となりますが、いくつか注意すべき例外があります。
     private 変数の場合、変数名の頭にクラス名がつきます。また、
     protected 変数の場合は、変数名の頭に '*' がつきます。
     このとき、頭に追加される値の前後に null バイトがついてきます。
     その結果、予期せぬ振る舞いをすることがあります。
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php

class A {
  private $A; // これは '\0A\0A' となります
}

class B extends A {
  private $A; // これは '\0B\0A' となります
  public $AA; // これは 'AA' となります
}

var_dump((array) new B());
?>
]]>
       </programlisting>
      </informalexample>

     上の例では 'AA' というキーがふたつあるように見えますが、
     そのうちひとつは、実際は '\0A\0A' ということになります。
    </para>

    <para>
     &null; を配列に変換すると、空の配列を得ます。
    </para>
   </sect2>

   <sect2 xml:id="language.types.array.comparing">
    <title>比較</title>
    <para>
     <function>array_diff</function> と
     <link linkend="language.operators.array">配列演算子</link>
     を用いると、配列を比較することができます。
    </para>
   </sect2>

   <sect2 xml:id="language.types.array.examples">
    <title>例</title>
    <para>
     PHP の配列型は、いろいろな使い方ができます。配列の強力な機能を示すため、
     ここでいくつかの例を紹介します。
    </para>
    <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// this
$a = array( 'color' => 'red',
            'taste' => 'sweet',
            'shape' => 'round',
            'name'  => 'apple',
                       4        // キーは0になります
          );

// これは以下と完全に同じです。
$a['color'] = 'red';
$a['taste'] = 'sweet';
$a['shape'] = 'round';
$a['name'] = 'apple';
$a[]        = 4;        // キーは0になります

$b[] = 'a';
$b[] = 'b';
$b[] = 'c';
// この結果は配列 array(0 => 'a' , 1 => 'b' , 2 => 'c'),
// または単に array('a', 'b', 'c') となります
?>
]]>
       </programlisting>
      </informalexample>
     </para>

    <example>
     <title>array() の使用例</title>
     <programlisting role="php">
<![CDATA[
// マップを行う配列
$map = array( 'version'    => 4
            , 'OS'         => 'Linux'
            , 'lang'       => 'english'
            , 'short_tags' => true
            );

// 数値キーのみを有する
$array = array( 7
              , 8
              , 0
              , 156
              , -10
              );
// これは、array( 0 => 7, 1 => 8, ...) と同じです

$switching = array(         10 // key = 0
                  , 5    =>  6
                  , 3    =>  7
                  , 'a'  =>  4
                  ,         11 // key = 6 (最大の添字は5です)
                  , '8'  =>  2 // key = 8 (整数!)
                  , '02' => 77 // key = '02'
                  , 0    => 12 // 値10は12で上書きされます
                  );

// empty array
$empty = array();
]]>
<!-- TODO example of
- mixed keys
- overwriting keys
- integer keys as string
- using vars/functions as key/values
- mixed skipping
-->
     </programlisting>
    </example>

    <example xml:id="language.types.array.examples.loop">
     <title>コレクション</title>
     <programlisting role="php">
<![CDATA[
<?php
$colors = array('red','blue','green','yellow');

foreach ( $colors as $color ) {
    echo "Do you like $color?\n";
}

?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Do you like red?
Do you like blue?
Do you like green?
Do you like yellow?
]]>
     </screen>
    </example>

    <para>
     PHP 5 以降では、配列を参照渡しすることでその値を直接変更できるようになりました。
     それ以前のバージョンでは、以下のような回避策が必要です。
     <example xml:id="language.types.array.examples.changeloop">
      <title>コレクション</title>
      <programlisting role="php">
<![CDATA[
<?php
// PHP 5
foreach ($colors as &$color) {
    $color = strtoupper($color);
}
unset($color); /* これ以降の $color への書き込みが
配列の要素を書き換えてしまわないことを保証する */

// 旧バージョンでの回避策
foreach ( $colors as $key => $color ) {
    $colors[$key] = strtoupper($color);
}

print_r($colors);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Array
(
    [0] => RED
    [1] => BLUE
    [2] => GREEN
    [3] => YELLOW
)
]]>
      </screen>
     </example>
    </para>
    <para>
     この例は、1 から始まる配列を作成します。
     <example>
      <title>1 から始まる添字</title>
      <programlisting role="php">
<![CDATA[
<?php
$firstquarter  = array(1 => 'January', 'February', 'March');
print_r($firstquarter);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Array
(
    [1] => 'January'
    [2] => 'February'
    [3] => 'March'
)
]]>
      </screen>
     </example>
    </para>
    <example>
     <title>配列に代入する</title>
     <programlisting role="php">
<![CDATA[
<?php
// ディレクトリから全てのアイテムを配列に代入する
$handle = opendir('.');
while ($file = readdir($handle))
{
    $files[] = $file;
}
closedir($handle);
?>
]]>
     </programlisting>
    </example>
    <para>
     配列には順番が付けられます。異なったソート関数を用いて順番を変更することも可能です。
     より詳細な情報については、<link linkend="ref.array">配列関数</link> を参照ください。
     <function>count</function> 関数を使用することで、
     配列の要素数を数えることが可能です。
    </para>
    <example>
     <title>配列のソート</title>
     <programlisting role="php">
<![CDATA[
<?php
sort($files);
print_r($files);
?>
]]>
     </programlisting>
    </example>
    <para>
     配列の値は何でも良いため、その値を他の配列とすることも可能です。
     これにより、再帰的な配列や多次元の配列を作成することが可能です。
    </para>
    <example>
     <title>再帰および多次元配列</title>
     <programlisting role="php">
<![CDATA[
<?php
$fruits = array ( "fruits"  => array ( "a" => "orange",
                                       "b" => "banana",
                                       "c" => "apple"
                                     ),
                  "numbers" => array ( 1,
                                       2,
                                       3,
                                       4,
                                       5,
                                       6
                                     ),
                  "holes"   => array (      "first",
                                       5 => "second",
                                            "third"
                                     )
                );

// 上の配列の内容を取得するための例
echo $fruits["holes"][5];    // "second" を表示します
echo $fruits["fruits"]["a"]; // "orange" を表示します
unset($fruits["holes"][0]);  // "first"  を削除します

// 新しい多次元配列を作成します
$juices["apple"]["green"] = "good";
?>
]]>
     </programlisting>
    </example>
    <para>
     配列の割り当てにおいては、常に値がコピーされることに注意してください。
     これは、<function>current</function> および類似の関数が使用する
     内部配列ポインタの値がリセットされるということを意味します。
     配列をリファレンスでコピーする場合には、
     リファレンス演算子を使う必要があります。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$arr1 = array(2, 3);
$arr2 = $arr1;
$arr2[] = 4; // $arr2 が変更されます。
             // $arr1 は array(2,3) のままです。

$arr3 = &$arr1;
$arr3[] = 4; // $arr1 と $arr3 は同じ内容になります。
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.types.object">
   <title>オブジェクト</title>

   <sect2 xml:id="language.types.object.init">
    <title>オブジェクトの初期化</title>

    <para>
     オブジェクトを初期化するためには、<literal>new</literal>
     命令によりオブジェクトのインスタンスを変数に作成します。

     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class foo
{
    function do_foo()
    {
        echo "foo を実行します。";
    }
}

$bar = new foo;
$bar -> do_foo ();
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     詳細な事項については、
     <link linkend="language.oop">クラスおよびオブジェクト</link>
     に関するセクションを参照ください。
    </simpara>

   </sect2>

   <sect2 xml:id="language.types.object.casting">
    <title>オブジェクトへの変換</title>

    <para>
     オブジェクトがオブジェクトに変換される場合、それは修正されません。
     他の型の値がオブジェクトに変換される場合、ビルトインクラスである
     <literal>stdClass</literal> の新しいインスタンスが生成されます。
     値が null の場合、新しいインスタンスは空となります。
     配列がオブジェクトに変換される場合、配列のキーがプロパティ名となり、
     配列の値がプロパティの値となります。他の値の場合、
     <literal>scalar</literal> という名前のメンバ変数が値を格納します。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$obj = (object) 'ciao';
echo $obj->scalar;  // 'ciao' を出力します
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>

  </sect1>

  <sect1 xml:id="language.types.resource">
   <title>リソース</title>

   <para>
    リソースは特別な変数であり、外部リソースへのリファレンスを保持しています。
    います。リソースは、特別な関数により作成され、使用されます。
    これらの関数および対応する全てのリソース型の一覧については、
    <link linkend="resource">付録</link> を参照ください。
   </para>

   <note>
    <simpara>
     リソース型は、PHP 4 で導入されました。
    </simpara>
   </note>

    <para>
     <function>get_resource_type</function> も参照ください。
    </para>

   <sect2 xml:id="language.types.resource.casting">
    <title>リソースへの変換</title>

    <para>
     リソース型は、オープンされたファイル、データベース接続、
     イメージキャンバスエリアのような特殊なハンドルを保持するため、
     他の値をリソースに変換することはできません。
    </para>
   </sect2>

   <sect2 xml:id="language.types.resource.self-destruct">
    <title>リソースの開放</title>

    <para>
     PHP 4 の Zend エンジンに導入されたリファレンスカウンティングシステムのおかげで、
     あるリソースがもう参照されなくなった場合に (Java と全く同様に)、
     そのリソースは自動的に削除されます。この場合、このリソースが作成した
     全てのリソースは、ガベージコレクタにより開放されます。
     このため、free_result 関数を用いて手動でメモリを開放する必要が生じるのはまれです。
     <note>
      <simpara>
       持続的データベース接続は特別で、ガベージコレクタにより破棄されません。
       <link linkend="features.persistent-connections">持続的接続</link>
       も参照ください。
      </simpara>
     </note>
    </para>

   </sect2>
  </sect1>

  <sect1 xml:id="language.types.null">
   <title>NULL</title>

   <para>
    特別な &null; 値は、ある変数が値を持たないことを表します。&null;
    は、<type>NULL</type> 型の唯一の値です。
   </para>
   <note>
    <simpara>
     NULL 型は、PHP 4 で導入されました。
    </simpara>
   </note>
   <para>
    変数は、以下の場合に &null; とみなされます。
    <itemizedlist>
     <listitem>
      <para>
       定数 &null; が代入されている場合。
      </para>
     </listitem>
     <listitem>
      <para>
       まだ値が何も代入されていない場合。
      </para>
     </listitem>
     <listitem>
      <para>
       <function>unset</function> されている場合。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <sect2 xml:id="language.types.null.syntax">
    <title>構文</title>
    <para>
     &null; 型の値は一つだけで、
     大文字小文字を区別しないキーワード &null;です。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$var = NULL;
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     <function>is_null</function> および <function>unset</function>
     も参照ください。
    </para>
   </sect2>

  </sect1>

  <sect1 xml:id="language.pseudo-types">
   <title>本ドキュメントにおける疑似的な型および変数</title>

   <sect2 xml:id="language.types.mixed">
    <title>mixed</title>
    <para>
     <literal>mixed</literal> は、引数に多様な型 (全てである必要はない)
     を使うことができることを示します。
    </para>
    <para>
     例えば <function>gettype</function> 関数は全ての PHP の型を受け入れるのに対し、
     <function>str_replace</function> は文字列と配列のみを受け入れます。
    </para>
   </sect2>

   <sect2 xml:id="language.types.number">
    <title>number</title>
    <para>
     <literal>number</literal> は引数が <type>integer</type> または <type>float</type>
     のどちらでもよいことを示します。
    </para>
   </sect2>

   <sect2 xml:id="language.types.callback">
    <title>callback</title>
    <para>
     <function>call_user_func</function> や <function>usort</function>
     等の関数は、ユーザが定義するコールバック関数を引数として受け入れます。
     コールバック関数は、単純な関数だけでなく、オブジェクトのメソッド
     あるいはクラスの静的メソッドであってもかまいません。
    </para>
    <para>
     PHP 関数はその名前を単に文字列として渡されます。
     どのようなビルトインまたはユーザ定義の関数も渡すことができます。
     ただし下記を除きます。
     <function>array</function>,
     <function>echo</function>,
     <function>empty</function>,
     <function>eval</function>,
     <function>exit</function>,
     <function>isset</function>,
     <function>list</function>,
     <function>print</function>
     <function>unset</function>.
    </para>
    <para>
     オブジェクトのインスタンスを作成するための方法の 1 つは、
     オブジェクトを 0 番目の要素、
     メソッド名を 1 番目の要素として含む配列を渡す方法です。
    </para>
    <para>
     静的なクラスメソッドの場合、
     0 番目の要素としてオブジェクトを渡す代わりにクラス名を渡すことにより、
     オブジェクトのインスタンスを作成せずに渡すことができます。
    </para>
    <para>
     一般的なユーザ定義関数とは異なり、<function>create_function</function>
     では無名コールバック関数を作成することができます。
    </para>

    <para>
     <example>
      <title>
       コールバック関数の例
      </title>
      <programlisting role="php">
<![CDATA[
<?php
// コールバック関数の例
function my_callback_function() {
    echo 'hello world!';
}

// コールバックメソッドの例
class MyClass {
    function myCallbackMethod() {
        echo 'Hello World!';
    }
}

// タイプ 1: 単純なコールバック
call_user_func('my_callback_function');

// タイプ 2: スタティッククラスメソッドのコール
call_user_func(array('MyClass', 'myCallbackMethod'));

// タイプ 3: オブジェクトメソッドのコール
$obj = new MyClass();
call_user_func(array($obj, 'myCallbackMethod'));
?>
]]>
      </programlisting>
     </example>
    </para>
    <note>
     <simpara>
      PHP4 では、実際のオブジェクトを指すコールバックを作成するには
      参照を使用する必要があります。そのコピーを使用してはいけません。
      詳細は <link linkend="language.references">参照についての説明</link>
      を参照ください。
     </simpara>
    </note>

   </sect2>

   <sect2 xml:id="language.types.void">
    <title>void</title>
    <para>
     返り値の型が <literal>void</literal> である場合は、
     返り値に意味がないことを表します。パラメータ一覧で
     <literal>void</literal> が使用されている場合は、
     その関数がパラメータを受け付けないことを表します。
    </para>
   </sect2>

   <sect2 xml:id="language.types.dotdotdot">
    <title>...</title>
    <para>
     関数のプロトタイプ宣言における <parameter>$...</parameter> は、
     <literal>…など</literal> を表します。
     この変数名を用いるのは、たとえば任意の数の引数を取りうる関数などです。
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.types.type-juggling">
   <title>型の相互変換</title>

   <simpara>
    PHP は、変数定義時に明示的な型定義を必要と(または、サポート)
    しません。ある変数の型は、その変数が使用される文により定義されます。
    これは、ある文字列を変数 <parameter>var</parameter> に代入した場合には、
    <parameter>var</parameter> は文字列になることを意味しています。
    ある整数値を <parameter>var</parameter> に代入した場合には、
    その変数は整数になります。
   </simpara>
   <para>
    PHP の自動型変換の例の一つは、加算演算子 '+' です。
    オペランドのどれかが float の場合、全てのオペランドは float
    として評価され、結果は float になります。
    その他の場合、オペランドは整数として解釈され、結果も整数になります。
    この自動型変換は、
    オペランド自体の型を変更するものではないということに注意してください。
    変わるのは、オペランドがどのように評価されるかだけです。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = "0";  // $foo は文字列です (ASCII 48)
$foo += 2;   // ここでは、$foo は整数です (2)
$foo = $foo + 1.3;  // ここでは、$foo はfloatです (3.3)
$foo = 5 + "10 Little Piggies"; // $foo は整数です (15)
$foo = 5 + "10 Small Pigs";     // $foo は整数です (15)
?>
]]>
<!-- bad example, no real operator (must be used with variable, modifies it too)
$foo++;      // $foo は文字列 "1" (ASCII 49)

TODO: explain ++/- - behaviour with strings

examples:

++'001' = '002'
++'abc' = 'abd'
++'xyz' = 'xza'
++'9.9' = '9.0'
++'-3'  = '-4'
- -'9'   = 8 (integer!)
- -'5.5' = '5.5'
- -'-9'  = -10 (integer)
- -'09'  = 8 (integer)
- -'abc' = 'abc'

-->
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    最後の二つの例が奇妙に思える場合には、
    <link linkend="language.types.string.conversion">文字列変換</link>
    を参照ください。
   </simpara>
   <simpara>
    ある変数を強制的にある特定の型として評価させたい場合には、
    <link linkend="language.types.typecasting">型キャスト</link>
    のセクションを参照ください。ある変数の型を変更したい場合には、
    <function>settype</function> を参照してください。
   </simpara>
   <para>
    本節の例をテストしたい場合には、
    <function>var_dump</function> を使用することが可能です。
   </para>
   <note>
    <para>
     配列への自動変換の動作は現時点で定義されていません。
    </para>
    <para>
     また、PHP では配列の添字と同じ構文を使用した文字列へのアクセスをサポートしているので、
     次の例はあらゆるバージョンの PHP で成立します。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$a    = 'car'; // $a は文字列です
$a[0] = 'b';   // $a はここでも文字列です
echo $a;       // bar
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     詳細は、<link linkend="language.types.string.substr">
     文字として文字列をアクセスする</link>というセクションを参照してください。
    </para>
   </note>

   <sect2 xml:id="language.types.typecasting">
    <title>型キャスト</title>

    <para>
     PHP の型キャストは、C 言語と同様に動作します。つまり、
     変換しようとする型を括弧で括り、キャストする変数の前に置きます。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = 10;   // $foo は整数です
$bar = (boolean) $foo;   // $bar はbooleanです
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     使用可能なキャストを以下に示します。
     <itemizedlist>
      <listitem>
       <simpara>(int), (integer) - 整数へのキャスト</simpara>
      </listitem>
      <listitem>
       <simpara>(bool), (boolean) - 論理値へのキャスト</simpara>
      </listitem>
      <listitem>
       <simpara>(float), (double), (real) - float へのキャスト</simpara>
      </listitem>
      <listitem>
       <simpara>(string) - 文字列へのキャスト</simpara>
      </listitem>
      <listitem>
       <simpara>(binary) - バイナリ文字列へのキャスト (PHP 6)</simpara>
      </listitem>
      <listitem>
       <simpara>(array) - 配列へのキャスト</simpara>
      </listitem>
      <listitem>
       <simpara>(object) - オブジェクトへのキャスト</simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     (binary) によるキャストや b プレフィックスのサポートは、PHP 5.2.1 で追加されました。
    </para>
    <para>
     括弧の中でタブとスペースを使用することができることに注意してください。
     したがって、次の文は機能的に等価です。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = (int) $bar;
$foo = ( int ) $bar;
?>
]]>
      </programlisting>
      <para>
       リテラル文字列や変数を、バイナリ文字列にキャストします。
      </para>
      <programlisting role="php">
<![CDATA[
<?php
$binary = (binary)$string;
$binary = b"binary string";
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <note>
     <para>
      ある変数を文字列にキャストする代わりに、
      二重引用符で括ることもできます。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = 10;            // $foo は整数です
$str = "$foo";        // $str は文字列です
$fst = (string) $foo; // $fst も文字列です

// 以下は、"they are the same"を出力します
if ($fst === $str) {
    echo "they are the same";
}
?>
]]>
      </programlisting>
     </informalexample>
     </para>
    </note>

    <para>
     型の間でキャストを行う際の動作は、必ずしも明確ではありません。
     詳細については、以下の節を参照ください。

     <itemizedlist>
      <listitem>
       <simpara>
    <link linkend="language.types.boolean.casting">論理値への変換
    </link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
    <link linkend="language.types.integer.casting">整数への変換
    </link>
       </simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.float.casting">浮動小数点数への変換
         </link>
       </simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.string.casting">文字列への変換
         </link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.array.casting">配列への変換
         </link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.object.casting">オブジェクトへの変換
         </link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.resource.casting">リソース型への変換
         </link></simpara>
      </listitem>
     <!-- don't exist yet
      <listitem>
       <simpara><link linkend="language.types.null.casting">Converting to
         &null;</link></simpara>
      </listitem>
      -->
      <listitem>
       <simpara>
        <link linkend="types.comparisons">型の比較表</link>
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
   </sect2>
  </sect1>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
