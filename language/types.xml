 <chapter id="language.types">
  <title>型</title>
  
  <sect1 id="language.types.intro">
   <title>導入</title>
   
   <simpara>
    PHP は、8種類の基本型をサポートします。
   </simpara>

   <para>
    4種類のスカラー型:

    <itemizedlist>
     
     <listitem>
      <simpara>
       <link linkend="language.types.boolean">論理値(boolean)</link>
      </simpara>
     </listitem>
     
     <listitem>
      <simpara>
       <link linkend="language.types.integer">整数(integer)</link>
      </simpara>
     </listitem>
     
     <listitem>
      <simpara>
       <link linkend="language.types.double">浮動小数点数 (float)</link>
      </simpara>
     </listitem>
     
     <listitem>
      <simpara>
       <link linkend="language.types.string">文字列</link>
      </simpara>
     </listitem>
     
    </itemizedlist>
    
    2種類の複合型:

    <itemizedlist>
     
     <listitem>
      <simpara>
       <link linkend="language.types.array">配列</link>
      </simpara>
     </listitem>
     
     <listitem>
      <simpara>
       <link linkend="language.types.object">オブジェクト</link>
      </simpara>
     </listitem>
     
    </itemizedlist>
    
    そして、最後に2種類の特別な型:

    <itemizedlist>
     
     <listitem>
      <simpara>
       <link linkend="language.types.resource">リソース</link>
      </simpara>
     </listitem>
     
     <listitem>
      <simpara>
       <link linkend="language.types.null">ヌル</link>
      </simpara>
     </listitem>
     
    </itemizedlist>
   </para>
  
   <note>
    <simpara>
     このマニュアルには、しばしば <literal>mixed</literal> というパラ
     メータが現れます。この疑似的な型は、そのパラメータに関して複数の
     型が使用可能であることを示します。
    </simpara>
    <!--
    
    Just an idea, maybe useful for some func-defs?
    (at least it is for the operator-defs)
    
   <simpara>
    In parameter definitions you can also encounter the 'number' pseudo-type,
    that indicates a parameter that is either <type>integer</type> or 
   <type>float</type>.
   </simpara>
   -->
   </note>
   
   <simpara>
    変数の型は、一般にプログラマによりセットされません。むしろ、その変
    数が使用される文の内容に応じて PHP により実行時に決定されます。
   </simpara>
   <simpara>
    ある変数の型を強制的に他の型に変換したい場合、変数を
    <link linkend="language.types.typecasting">キャスト</link> するか、
    <function>settype</function> 関数を使用します。
   </simpara>
   <simpara>
    変数は、その型に依存して異なった動作をする場合があることに
    注意してください。詳細な情報については、
    <link linkend="language.types.type-juggling">型の変換</link> のセ
    クションを参照下さい。
   </simpara>
   
  </sect1>

  <sect1 id="language.types.boolean">
   <title>論理型(boolean)</title>
   
   <simpara>
    論理型は、最も簡単な型です。<type>boolean</type> は、真偽の値を表
    します。この値は、&true; または &false;のどちらかになります。
   </simpara>
   
   <note>
    <simpara>
     boolean型は、PHP 4で導入されました。
    </simpara>
   </note>
   
   <sect2 id="language.types.boolean.syntax">
    <title>構文</title>
    <para>
     booleanリテラルを指定するには、キーワード&true;
     または&false;を指定して下さい。両方とも大文字小
     文字に依存しません。
     <!-- technically they are just constants -->
     <informalexample>
      <programlisting role="php">
$foo = True; // 値TRUEを$fooに代入する
      </programlisting>
     </informalexample>
    </para>
    <para>
     通常、<type>boolean</type>型の値を返す<link
     linkend="language.operators">演算子</link>を使用してから、
     <link linkend="control-structures">制御構造</link>にその結果を渡
     します。
     <informalexample>
      <programlisting role="php">
if ($action == "show_version") // == は、<type>boolean</type>型を返す
                               // <link linkend="language.operators">演算子</link>
{
    echo "バージョンは1.23です。";
}

// これは冗長
if ($show_separators == true)
{
    echo "&lt;hr&gt;\n";
}

// 上の例は次のように簡単に書くことができます。
if ($show_separators)
{
    echo "&lt;hr&gt;\n";
}
      </programlisting>
     </informalexample>
    </para>
   </sect2>
   
   <sect2 id="language.types.boolean.casting">
    <title>booleanへの変換</title>
    <simpara>
     <type>boolean</type>に明示的に変換を行うには、キャスト
     <literal>(bool)</literal> または <literal>(boolean)</literal> を
     使用します。しかし、演算子、関数、制御構造が<type>boolean</type>
     型の引数を必要とする場合には、値は自動的に変換されるため、多くの
     場合、キャストは不要です。
    </simpara>
    <simpara>
     <link linkend="language.types.type-juggling">型の相互変換</link>
     も参照下さい。
    </simpara>
    
    <para>
     <type>boolean</type>に変換する場合、次の値は
     &false;とみなされます。
     
     <itemizedlist>
      <listitem>
       <simpara>
	<link linkend="language.types.boolean">boolean</link>の
	&false;<!-- duh... -->
       </simpara>
      </listitem>
      <listitem>
       <simpara>
	<link linkend="language.types.integer">integer</link>の 0 (ゼ
	ロ)
       </simpara>

      </listitem>
      <listitem>
       <simpara>
	<link linkend="language.types.double">float</link>の
	0.0 (ゼロ) 
       </simpara>
      </listitem>
      <listitem>
       <simpara>
	空の<link linkend="language.types.string">文字列</link>、
	および<link linkend="language.types.string">文字列</link>の
	"0"
       </simpara>
      </listitem>
      <listitem>
       <simpara>
	ゼロを要素とする <link linkend="language.types.array">配列
	</link> 
       </simpara>
      </listitem>
      <listitem>
       <simpara>
	ゼロを要素とする <link linkend="language.types.object">オブジェ
	クト</link> 
       </simpara>
      </listitem>
      <listitem>
       <simpara>
	特別な値 <link linkend="language.types.null">&null;</link> 
       </simpara>
      </listitem>
     </itemizedlist>
       
     その他の値は全て&true;とみなされます。 (全ての
     <link linkend="language.types.resource">resource</link>を含みます。)
     <warning>
      <simpara>
         <literal>-1</literal> は、他のゼロでない数を同様に(正負によら
         ず) &true; とみなされます。
      </simpara>
     </warning>
     <!-- TODO: add a few examples, for the people only looking at 
     the examples... -->
    </para>
    
   </sect2>
   
  </sect1>

  <sect1 id="language.types.integer">
   <title>整数</title>
   
   <simpara>
    <type>integer</type> は、Z = {..., -2, -1, 0, 1, 2, ...}という集合
    です。
   </simpara>
     
   <para>
    <link linkend="ref.gmp">任意精度整数</link> および
    <link linkend="language.types.double">double</link>も参照下さい。
   </para>

   <sect2 id="language.types.integer.syntax">
    <title>構文</title>
    <simpara>
     整数(integer)は、10進数(基底10)、16進数(基底16)、8進数(基底8)表記
     で指定可能です。オプションで、符号(-または+)を前に付けることが可
     能です。
    </simpara>
    <para>
     8進数表記を使用する場合、数の前に<literal>0</literal> (ゼロ)を付
     ける必要があります。また、16進数表記を使用するには、数の前に
     <literal>0x</literal>を付ける必要があります。
     <example>
      <title>整数リテラル</title>
      <programlisting role="php">
$a = 1234; # 10進整数
$a = -123; # 負の数
$a = 0123; # 18進数 (10進数の83と等価)
$a = 0x1A; # 16進数 (10進数の26と等価)
      </programlisting>
     </example>
     <!--
     
     decimal     : [1-9][0-9]*
     | 0
     
     hexadecimal : 0[xX][0-9a-fA-F]+
     
     octal       : 0[0-7]+
     
     integer     : [+-]?decimal
     | [+-]?hexadecimal
     | [+-]?octal
     
     -->
     最大値が約20億である(32ビット符号付)というのが一般的な値ですが、
     整数のサイズはプラットフォーム依存です。
    </para>
    <note><!-- or warning? -->
     <simpara>
      PHPでは、整数の割算はありません。<literal>1/2</literal>は、
      <type>double</type>型の<literal>0.5</literal>になります。
      <!-- See ??? for more information. (with the operators, or with
      type-jug) -->
     </simpara>
    </note>
   </sect2>
   
   <sect2 id="language.types.integer.overflow">
    <title>整数のオーバーフロー</title>
    <para>
     <type>integer</type>型の範囲外の数を指定した場合、かわりに
     <type>double</type>として解釈されます。
     <informalexample>
      <programlisting role="php">
$large_number =  2147483647;
var_dump($large_number);
// 出力: int(2147483647)
$large_number =  2147483648;
var_dump($large_number);
// 出力: float(2147483648)

// 指定した16進表現整数も出力

var_dump( 0x80000000 );
// 出力: float(2147483648)
      </programlisting>
     </informalexample>
     更に、関数または演算子が、<type>integer</type>の範囲外の数を生成
     する場合も自動的に<type>float</type>に変換されます。
     <informalexample>
      <programlisting role="php">
$million = 1000000;
$large_number =  50000 * $million;
var_dump($large_number);
// 出力: float(50000000000)
      </programlisting>
     </informalexample>
     <warning>
      <simpara>
       不幸にして、スクリプトエンジンにはバグ(4.0.6にはまだあり、恐らく
       4.0.7では解決されるでしょう)があり、負の数が含まれている場合に、
       常に正しく動作するわけではありません。例えば、
       <literal>-50000 * $million</literal>を実行した場合、結果は、
       <literal>-429496728</literal>となります。しかし、オペランドが共に
       正の場合は問題ありません。
      </simpara>
     </warning>
    </para>
   </sect2>
   
   <sect2 id="language.types.integer.casting">
    <title>整数への変換</title>
    <simpara>
     <type>integer</type>に値を明示的に変換するには、キャスト
     <literal>(int)</literal> または <literal>(integer)</literal>のど
     ちらかを使用して下さい。しかし、多くの場合、演算子、関数、制御構
     造が<type>boolean</type>引数を必要とする場合、値は自動的に変換さ
     れるため、キャストを使用する必要はありません。
    </simpara>
    <simpara>
     <link linkend="language.types.type-juggling">型の相互変換</link>
     を参照下さい。
    </simpara>
    
    <sect3 id="language.types.integer.casting.from-boolean">
     <title>
      <link linkend="language.types.boolean">booleans</link>から
     </title>
     <simpara>
      &false; は、<literal>0</literal> (ゼロ)となり、
      &true; は、<literal>1</literal>となります。
       </simpara>
    </sect3>
    
    <sect3 id="language.types.integer.casting.from-float">
     <title>
      <link linkend="language.types.double">浮動小数点数</link>から
     </title>
     <simpara>
      floatから整数に変換する場合、その数はゼロの方に丸められます。
     </simpara>
       
     <para>
      floatが整数の範囲(通常は <literal>+/- 2.15e+9 =
      2^31</literal>)を越える場合、結果は undefined となります。これは、
      そのfloatが正しい整数の結果を得るために十分な精度を得られなかっ
      たからです。この場合、警告も通知も発生しません!
     </para>
     
     <warning>
      <para>
       未知の端数を<type>integer</type>にキャストしないで下さい。この
       場合、予期しない結果となることがあります。
       <informalexample>
	<programlisting role="php">
echo (int) ( (0.1+0.7) * 10 ); // 7が出力されます!
	</programlisting>
       </informalexample>
       より詳細な情報については、<link linkend="warn.float-precision">
        floatの精度に関する注意</link>を参照下さい。
      </para>
     </warning>
    </sect3>
    
    <sect3 id="language.types.integer.casting.from-string">
     <title>文字列から</title>
     <simpara>
      <link linkend="language.types.string.conversion">文字列変換
      </link>を参照下さい。
     </simpara>
    </sect3>
    
    <sect3 id="language.types.integer.casting.from-other">
     <title>他の型から</title>
     <para>
      <caution>
       <simpara>
	整数への変換の動作は、他の型については定義されません。現在の
	動作は、その値がまず 
	<link linkend="language.types.boolean.casting">論理値に変換
	 された</link>場合と同じです。しかし、この動作は予告なく変更
	されることがありえるので、これを前提にしていはいけません。
       </simpara>
      </caution>
     </para>
     <!--
     
     IMO, it would more sense as (int) $arr returned the 
     number of elements in $arr. This won't break anything,
     since this behaviour was never defined before, and 
     (bool)(int) $arr will still behave the same.
     
     -->
    </sect3>
    
   </sect2>
  </sect1>
  
  <sect1 id="language.types.double">
   <title>浮動小数点数</title>
   <para>
    ("float","double","実数"のような) フロート数は、次の構文により指定
    できます。
    <synopsis>
$a = 1.234; $a = 1.2e3; $a = 7E-10;
    </synopsis>
    <!--  
    
LNUM	[0-9]+
DNUM	([0-9]*[\.][0-9]+)|([0-9]+[\.][0-9]*)
EXPONENT_DNUM	(({LNUM}|{DNUM})[eE][+-]?{LNUM})
    
    -->
    floatの大きさはプラットフォーム依存です。ただし、通常はおよそ10
    進数で14桁の精度があり、最大値は ~1.8e308 (これは 64ビット IEEE
    フォーマットです)となります。
   </para>
   <warning id="warn.float-precision">
    <para>
     <literal>0.1</literal>や<literal>0.7</literal>のような
     簡単な小数表現も若干精度を失うことなく内部的な2進表現に変
     換することはできません。これにより、混乱する結果を生じることがあ
     ります。つまり、<literal>floor((0.1+0.7)*10)</literal> は
     予想される <literal>8</literal>の代わりに実際の内部表現の結果とし
     て<literal>7.9999999999...</literal>のようなものを結果として返し
     ます。
    </para>
    <para>
     これは、いくつかの分数は有限の桁数の小数点表記で正確に表現できな
     いという事実に関係しています。例えば、<literal>1/3</literal>の小
     数点表記は、<literal>0.3333333. . .</literal>となります。
    </para>
    <para>
     よって、小数の最後の桁を信用してはいかませんし、小数が等しいとい
     う比較を行ってはいけません。より高い精度が必要な場合には、
     <link linkend="ref.bc">任意精度数学関数</link>または
     <link linkend="ref.gmp">gmp</link>関数を代わりに使用して下さい。
    </para>
   </warning>
  </sect1>
  
  <sect1 id="language.types.string">
   <title>文字列</title>
   <para>
    <type>string</type> は一連の文字です。PHPでは、文字は1バイトと同じ
    です。つまり、256個の異なる文字を使用可能です。これは、PHPは、
    Unicodeをネーティブにサポートしていないことも意味します。
    <!-- how about unicode? will we support that eventually? Are
    there current any ways to work with unicode?
    -->
   </para>
   <note>
    <simpara>
     文字列が非常に大きくなっても問題ありません。PHPに課せられる文字列
     のサイズの実用上の制限はありません。このため、長い文字列に関して
     恐れる必要は全くありません。
    </simpara>
   </note>
   <sect2 id="language.types.string.syntax">
    <title>構文</title>
    <para>
     文字列リテラルは、3つの異なる方法で指定することが可能です。
     <itemizedlist>

      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.single">引用符</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.double">二重引用符</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.heredoc">ヒアドキュ
        メント構文</link>
       </simpara>
      </listitem>

     </itemizedlist>
    </para>
    <sect3 id="language.types.string.syntax.single">
     <title>引用符</title>
     <para>
      文字列を指定する最も簡単な方法は、引用符(文字
      <literal>'</literal>)で括ることです。
     </para>
     <para>
      リテラルの引用符指定するには、多くの他の言語と同様にバックスラッ
      シュ(<literal>\</literal>)でエスケープする必要があります。
      バックスラッシュを引用符の前または文字列の最後に置きたい場合は、
      2重にする必要があります。この他の文字をエスケープする場合には、
      バックスラッシュも出力されることに注意して下さい! このため、通常、
      バックスラッシュ自体をエスケープする必要はありません。
      <note>
       <simpara>
        PHP 3では、この場合、<literal>E_NOTICE</literal>レベルの警告が
	出力されます。
       </simpara>
      </note>
      <note>
       <simpara>
	他の二つの構文と異なり、引用符で括られた文字列の中にある変数は
        展開されません。
       </simpara>
      </note>
      <informalexample>
       <programlisting role="php">
echo 'this is a simple string';
echo 'You can also have embedded newlines in strings,
like this way.';
echo 'Arnold once said: "I\'ll be back"';
// 出力: ... "I'll be back"
echo 'Are you sure you want to delete C:\\*.*?';
// 出力: ... delete C:\*.*?
echo 'Are you sure you want to delete C:\*.*?';
// 出力: ... delete C:\*.*?
echo 'I am trying to include at this point: \n a newline';
// 出力: ... this point: \n a newline
       </programlisting>
      </informalexample>
     </para>
    </sect3>
    <sect3 id="language.types.string.syntax.double">
     <title>2重引用符</title>
     <para>
      文字列が2重引用符(")で括られた場合, PHPはより多くの特殊文字のエ
      スケープシーケンスを理解します。
     </para>
     <table>
      <title>エスケープされた文字</title>
      <tgroup cols="2">
       <thead>
	<row>
	 <entry>記述</entry>
	 <entry>意味</entry>
	</row>
       </thead>
       <tbody>
	<row>
	 <entry><literal>\n</literal></entry>
	 <entry>ラインフィード(LFまたはアスキーの0x0A (10))</entry>
	</row>
	<row>
	 <entry><literal>\r</literal></entry>
	 <entry>キャリッジリターン (CRまたはアスキーの0x0D (13))</entry>
	</row>
	<row>
	 <entry><literal>\t</literal></entry>
	 <entry>水平タブ(HTまたはアスキーの0x09 (9))</entry>
	</row>
	<row>
	 <entry><literal>\\</literal></entry>
	 <entry>バックスラッシュ</entry>
	</row>
	<row>
	 <entry><literal>\$</literal></entry>
	 <entry>ドル記号</entry>
	</row>
	<row>
	 <entry><literal>\"</literal></entry>
        <entry>2重引用符</entry>
	</row>
	<row>
	 <entry><literal>\[0-7]{1,3}</literal></entry>
	 <entry>
	  正規表現にマッチする文字シーケンスは、8進数表記の1文字です。
        </entry>
	</row>
	<row>
	 <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
	 <entry>
	  正規表現にマッチする文字シーケンスは、16進数表記の1文字です。
	 </entry>
	</row>
       </tbody>
      </tgroup>
     </table>
     <para>
      繰り返しますが、この他の文字をエスケープしようとした場合には、バッ
      クスラッシュも出力されます!
     </para>
     <para>
      しかし、二重引用符で括られた文字列で最も重要なのは、変数名が展開
      されるところです。詳細は、<link
      linkend="language.types.string.parsing">文字列のパース</link>を
      参照下さい。
     </para>
    </sect3>

    <sect3 id="language.types.string.syntax.heredoc">
     <title>ヒアドキュメント</title>
     <simpara>
      文字列を区切る別の方法としてヒアドキュメント構文("&lt;&lt;&lt;")
      があります。この場合、あるIDを<literal>&lt;&lt;&lt;</literal>の後
      に指定し、文字列を置いた後で、同じIDを括りを閉じるために置きます。
     </simpara>
     <simpara>
      終端IDは、その行の最初のカラムから始める必要があります。使用するラ
      ベルは、PHPの他のラベルと同様の名前に関する規則に従う必要がありま
      す。つまり、英数字およびアンダースコアのみを含み、数字でない文字ま
      たはアンダースコアで始まる必要があります。
     </simpara>
     
     <warning>
      <simpara>
       非常に重要なことですが、閉じる側のIDがある行には、セミコロン
       (<literal>;</literal>)以外の他の文字が含まれていてはならないこ
       とに注意して下さい。これは、特にIDはインデントしてはならないと
       いうことと、セミコロンの前に空白やタブを付けてはいけないことを
       意味します。
      </simpara>
      <simpara>
       恐らく、最もやっかいな問題は、行末が復改文字
       (<literal>\r</literal>)でなく、改行(<literal>\n</literal>)とも
       呼ばれるフォームフィードのみであることもあり得ることです。
       マイクロソフト Windows は、行末記号としてシーケンス
       <literal>\r\n</literal>を使用しています。このため、Windowsのエ
       ディタでスクリプトを書いている場合には、ヒアドキュメントが動作
       しない可能性があります。しかし、多くのプログラム用のエディタは、
       ファイルをUNIXの改行文字で保存する機能を有しています。
       <!--
       FTP will sometimes automatically convert \r\n to \n while
       transferring your files to your webserver (which
       is *nix, of course)
       -->
      </simpara>
     </warning>

     <para>
      ヒアドキュメントは、2重引用符を使用しませんが、2重引用符で括られた
      文字列と全く同様に動作します。しかし、この場合でも上記のリストでエ
      スケープされたコードを使用することも可能です。変数は展開されますが、
      文字列の場合と同様にヒアドキュメントの内部で複雑な変数を表わす場合
      には注意が必要です。
      <example> 
       <title>ヒアドキュメントで文字列を括る例</title>
       <programlisting>
&lt;?php
$str = &lt;&lt;&lt;EOD
Example of string
spanning multiple lines
using heredoc syntax.
EOD;

/* 変数を使用するより複雑な例 */
class foo {
    var $foo;
    var $bar;

    function foo() {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo &lt;&lt;&lt;EOT
My name is "$name". I am printing some $foo-&gt;foo.
Now, I am printing some {$foo-&gt;bar[1]}.
This should print a capital 'A': \x41
EOT;
?>
       </programlisting>
      </example>
     </para>
     
     <note>
      <para>
       ヒアドキュメントはPHP4で追加されました。
      </para>
     </note>

    </sect3>

    <sect3 id="language.types.string.parsing">
     <title>変数のパース</title>
     <simpara>
      スクリプトが2重引用符で括られるかヒアドキュメントで指定された場
      合、その中の変数はパースされます。
     </simpara>
     <simpara>
      構文の型には、<link
      linkend="language.types.string.parsing.simple">単純な</link>構文と
      <link linkend="language.types.string.parsing.complex">複雑な
      </link>構文の2種類があります。簡単な構文は、最も一般的で便利です。
      この構文では、変数、配列値やオブジェクトのプロパティをパースする
      ことが可能です。
     </simpara>
     <simpara>
      複雑な構文は、PHP 4で導入されました。
      <!-- XXX was it? and starting with what version exactly? -->
      この構文は、式を波括弧で括ることにより認識されます。
     </simpara>
     <sect4 id="language.types.string.parsing.simple">
      <title>簡単な構文</title>
      <simpara>
       ドル記号(<literal>$</literal>)を見付けるとパーサは、有効な変数
       名を形成することが可能な最長のトークンを取得します。変数名の終
       りを明示的に指定したい場合は、変数名を波括弧で括って下さい。
      </simpara>
      <informalexample>
       <programlisting role="php">
$beer = 'Heineken';
echo "$beer's taste is great"; // 動作します。"'" は変数名として無効な文字です。
echo "He drunk some $beers"; // 動作しません。's' は、変数名として有効な文字です。
echo "He drunk some ${beer}s"; // 動作します。
       </programlisting>
      </informalexample>
      <simpara>
       同様に、配列添字とオブジェクトのプロパティをパースすることも可
       能です。配列添字の場合、閉じ角括弧(']')は添字の終りを意味し、
       オブジェクトのプロパティの場合、同じ規則が簡単な変数として適用
       されます。しかし、オブジェクトプロパティには、変数の場合のよう
       な手法はありません。
       
       <!-- XXX isn't &true; :(, this would be the trick
       Also,
       the same trick with curly-braces works if you
       want to limit the greediness of parsers (aren't they
       paying them enough or something?).
       -->
      
      </simpara>
      <informalexample>
       <programlisting role="php">
$fruits = array( 'strawberry' =&gt; 'red' , 'banana' =&gt; 'yellow' );
echo "A banana is $fruits[banana].";
echo "This square is $square-&gt;width meters broad.";
echo "This square is $square-&gt;width00 centimeters broad."; // 動作しません。
   // 解決策については、<link linkend="language.types.string.parsing.complex">複雑な構文</link>を参照下さい。

<!-- XXX this won't work:
echo "This square is $square->{width}00 centimeters broad."; 
// XXX: php developers: it would be consequent to make this work.
// XXX: like the $obj->{expr} syntax outside a string works, 
// XXX: analogously to the ${expr} syntax for variable var's.
-->

       </programlisting>
      </informalexample>
      <simpara>
       より複雑な場合は、複雑な構文を使用する必要があります。
      </simpara>
     </sect4>
     <sect4 id="language.types.string.parsing.complex">
      <title>複雑な(波括弧)構文</title>
      <simpara>
       この構文は、構文が複雑であるからではなく、この方法では複雑な式
       を含めることができるため、複雑と呼ばれています。
      </simpara>
      <simpara>
       事実、この構文により文字列の中に名前空間にあるあらゆる値を含め
       ることが可能です。文字列の外側に置く場合と同様に式を書き、これ
       を { と } の間に含めて下さい。'{'はエスケープすることができない
       ため、この構文は $が{のすぐ後に続く場合にのみ認識されます。
       (リテラル"{$"を指定するには、"{\$"または"\{$"を使用して下さい)
       以下のいくつかの例を見ると理解しやすくなるでしょう。
      </simpara>
      <informalexample>
       <programlisting role="php">
$great = 'fantastic';
echo "This is { $great}"; // 動作しません。出力は、This is { fantastic}
echo "This is {$great}";  // 動作します。出力は、This is fantastic
echo "This square is {$square-&gt;width}00 centimeters broad."; 
echo "This works: {$arr[4][3]}";     
echo "This is wrong: {$arr[foo][3]}"; // <link linkend="language.types.array.foo-bar">$foo[bar]</link> 
  // が文字列の外では使用できないのと同じ理由で動作せず。
echo "You should do it this way: {$arr['foo'][3]}";
echo "You can even write {$obj-&gt;values[3]-&gt;name}";
echo "This is the value of the var named $name: {${$name}}";
<!-- <xxx> maybe it's better to leave this out?? 
// this works, but i disencourage its use, since this is NOT 
// involving functions, rather than mere variables, arrays and objects.
$beer = 'Heineken';
echo "I'd like to have another {${ strrev('reeb') }}, hips";
 </xxx> -->
       </programlisting>
      </informalexample>
     </sect4>
    </sect3>
    
    <sect3 id="language.types.string.substr">
     <title>文字列への文字単位のアクセス</title>
     <para>
      波括弧の後に任意の文字をゼロから始まるオフセットで指定することに
      より、文字列内の文字にアクセスすることが可能です。
     </para>
     <note>
      <simpara>
       過去の互換性のため、配列括弧を使用することが可能です。しかし、
       この構文はPHP 4に依存しています。
      </simpara>
     </note>
     <para>
      <example>
       <title>複数のstringの例</title>
       <programlisting role="php">
<!-- TODO: either move these examples to a example section,
as with arrays, or distribute them under the applicable
sections. -->
&lt;?php
/* 文字列に代入。 */
$str = "This is a string";

/* 文字列に追加。 */
$str = $str . " with some more text";

/* 追加する別の方法。改行を示すエスケープ文字を含む。 */
$str .= " and a newline at the end.\n";

/* この文字列は、最終的に'&lt;p&gt;Number: 9&lt;/p&gt;'となります */
$num = 9;
$str = "&lt;p&gt;Number: $num&lt;/p&gt;";

/* この文字列は、'&lt;p&gt;Number: $num&lt;/p&gt;'となります。 */
$num = 9;
$str = '&lt;p&gt;Number: $num&lt;/p&gt;';

/* 文字列の最初の文字を得る  */
$str = 'This is a test.';
$first = $str{0};

/* 文字列の最後の文字を得る */
$str = 'This is still a test.';
$last = $str{strlen($str)-1};
?&gt;	  
       </programlisting>
      </example>
     </para>
    </sect3>

   </sect2><!-- end syntax -->

   <sect2 id="language.types.string.useful-funcs">
    <title>便利な関数</title><!-- and operators -->
    <para>
     文字列は、'.' (ドット)結合演算子で結合することが可能です。'+'(付
     加)演算子はこの例では出てこないことに注意して下さい。詳細について
     は <link linkend="language.operators.string">文字列演算子</link>
     を参照下さい。
    </para>
    <para>
     文字列の修正を行う場合に便利な関数がたくさんあります。
    </para>
    <simpara>
     一般的な関数については、<link linkend="ref.strings">文字列関数の
     節</link> を参照下さい。高度な検索/置換を行う正規表現関数について
     は、<link linkend="ref.pcre">Perl</link> および
     <link linkend="ref.regex">POSIX 拡張</link>の2種類ありますが、そ
     れぞれの節を参照下さい。
    </simpara>
    <simpara>
     <link linkend="ref.url">URL文字列用関数</link>や文字列sの暗号化/
     復号化用関数(<link linkend="ref.mcrypt">mcrypt</link> および
     <link linkend="ref.mhash">mhash</link>)もあります。
    </simpara>
    <simpara>
     最後に、探しているものがまだ見付からない場合には、
     <link linkend="ref.ctype">文字型の関数</link>も参照下さい。
    </simpara>
   </sect2>

   <sect2 id="language.types.string.conversion">
    <title>文字列の変換</title>

    <simpara>
     数値として文字列が評価された時、結果の値と型は次のように
     定義されます。
    </simpara>
    <simpara>
     文字列は、'.'、'e'、'E' のどれかが含まれている場合は
     <type>float</type>、それ以外は整数として評価されます。
    </simpara>
    <para>
     文字列の最初の部分により値が決まります。文字列が、有効な数値デー
     タから始まる場合、この値が使用されます。その他の場合、値は 0 (ゼ
     ロ) となります。有効な数値データは符号(オプション)の後に、1つ以上
     の数字(オプションとして小数点を一つ含む)、オプションとして指数部
     が続きます。指数部は 'e' または 'E' の後に一つ以上の数字が続く形
     式です。
    </para>
    <simpara>
     最初の式が文字列の場合、変数の型は2番目の式に依存します。
    </simpara>
    <informalexample>
     <programlisting role="php">
$foo = 1 + "10.5";              // $foo は float です (11.5)
$foo = 1 + "-1.3e3";            // $foo は float です (-1299)
$foo = 1 + "bob-1.3e3";         // $foo は integer です (1)
$foo = 1 + "bob3";              // $foo は integer です (1)
$foo = 1 + "10 Small Pigs";     // $foo は integer です (11)
$foo = 1 + "10 Little Piggies"; // $foo は integer です (11)
$foo = "10.0 pigs " + 1;        // $foo は integer です (11)
$foo = "10.0 pigs " + 1.0;      // $foo は float です (11)     
     </programlisting>
    </informalexample>
    <simpara>
     この変換に関する詳細は、UNIXマニュアルstrtod(3) を参照下さい。
    </simpara>
    <para>
     本節の例を試したい場合、その例をカットアンドペーストしてから
     動作を確認するために次の行を挿入して下さい。
     <informalexample>
      <programlisting role="php">
echo "\$foo==$foo; type is " . gettype ($foo) . "&lt;br&gt;\n";
      </programlisting>
     </informalexample>
    </para>

   </sect2>
  </sect1><!-- end string -->

  <sect1 id="language.types.array">
   <title>配列</title>

   <para>
    PHPの配列は、実際には順番付けられたマップです。マップは、
    <emphasis>値</emphasis>を<emphasis>キー</emphasis>にマップする型で
    す。この型は、いくつかの手法で最適化されます。このため、実際の配列
    またはリスト(ベクトル)、(あるマップの実装である)ハッシュテーブル、
    ディレクトリ、コレクション、スタック、キュー等として使用することが
    可能です。PHPの配列には他のPHP配列を値として保持することができるた
    め、非常に簡単にツリー構造を表現することが可能です。
   </para>
   <para>
    これらの構造に関する説明は、本マニュアルの範囲外ですが、これらの構
    造に各々に関する例を少なくとも一つ見付けることが可能です。これらの
    構造に関するより詳細な情報については、データ構造に関する良書を購入
    して下さい。
    <!-- like goodrich&tamassia: datastructures and algorithmes.
    Only, the subtitle is: in Java, and it's quite academic too -->
   </para>
   
   <sect2 id="language.types.array.syntax">
    <title>構文</title>
    
    <sect3 id="language.types.array.syntax.array-func">
     <title><function>array</function>で指定</title>
     <para>
      <type>配列</type> は、言語構造<function>array</function> で作成
      することが可能です。この構造は、特定の数のカンマで区切られた
      <literal><replaceable>key</replaceable> =&gt; <replaceable
      >value</replaceable></literal>の組みを引数とします。
     </para>
     <para>
      <varname>key</varname> は、非負の <type>整数</type> または
      <!-- 
      
      Negative integers are also allowed, however, IMO it's best to not 
      document that, or even disencourage it. 
      
      Why?
      
      First, because it is very tricky. But the real reason is that the key
      '-1' will be interpreted as a string, and not as a integer. Therefore,
      the usage
      "the -1'st value of \$arr is $arr[-1]" is ambigious. By the way,
      it results in a parse-error anyway, which is another argument for
      not documenting it.
      
      -Jeroen
      
      -->
      <type>文字列</type>です。
      あるキーが、非負の<type>整数</type>の標準的な表現形式である場合、
      そのように解釈されます。(つまり、<literal>'8'</literal>は
      <literal>8</literal>として解釈されます。一方、
      <literal>'08'</literal>は<literal>'08'</literal>として解釈されま
      す。)
     </para>
     <para>
      値は、何でも構いません。
     </para>
     <formalpara id="language.types.array.omit-key">
      <title>キーを省略する</title>
      <para>
       キーを省略した場合、整数添字の最大値が使用され、新しいキーはそ
       の最大値+1となります。整数添字がまだ存在しない場合、そのキーは
       <literal>0</literal> (ゼロ)となります。値を代入済のキーを指定し
       た場合、そのキーは上書きされます。
      </para>
     </formalpara>
     
     <para>
      <synopsis>
array( <optional> <replaceable>key</replaceable> =&gt; </optional> <replaceable
>value</replaceable>
     , ...
     )
// <replaceable>key</replaceable> は <type>string</type> または非負の <type>整数</type>のどちらか
// <replaceable>value</replaceable> は何でも可
      </synopsis>
     </para>
    </sect3>
    
    <sect3 id="language.types.array.syntax.modifying">
     <title>角括弧構文で作成/修正</title>
     <para>
      明示的に値を設定することにより、既存の配列を修正することも可能で
      す。
     </para>
     <para>
      これは、角括弧の中にキーを指定することにより、配列に値を代入する
      ことにより行うことが可能です。キーを省略することも可能です。この
      場合、空の角括弧("<literal>[]</literal>")の変数名として追加して
      下さい。
      <synopsis>
$arr[<replaceable>key</replaceable>] = <replaceable>value</replaceable>;
$arr[] = <replaceable>value</replaceable>;
// <replaceable>key</replaceable> は <type>string</type> または非負の
// <type>整数</type>のどちらかです。

// <replaceable>value</replaceable> は何でもかまいません
      </synopsis>
      <varname>$arr</varname> がまだ存在しない場合、作成されます。
      配列wお指定する別の手段でもあります。ある値を変更するには、新し
      い値に値を代入します。キー/値の組みを削除したい場合には、
      <function>unset</function> を使用する必要があります。

     </para>

    </sect3>
    

   </sect2><!-- end syntax -->
   
   <sect2 id="language.types.array.useful-funcs">
    <title>有用な関数</title>
    <para>
     配列で使用する便利な関数がたくさんあります。
     <link linkend="ref.array">配列関数</link> の節を参照下さい。
    </para>
    <para>
     制御構造<link linkend="control-structures.foreach">foreach</link> 
     が配列用に限定して存在します。この構造は、配列の要素に簡単に連続
     的にアクセスする手段を提供します。
    </para>
   </sect2>
   
   <sect2 id="language.types.array.donts">
    <title>配列ですべきこととしてはならないこと</title>

    <sect3 id="language.types.array.foo-bar">
     <title>なぜ、<literal>$foo[bar]</literal> は使用できないのか?</title>
     <para>
      古いスクリプトで次のような構文を見たことがあるかもしれません。
      <informalexample>
       <programlisting role="php">
$foo[bar] = 'enemy';
echo $foo[bar];
// 等
       </programlisting>
      </informalexample>
      これは間違っていますが、動作します。では、なぜ間違っているのでしょ
      う? その理由は、<link linkend="language.types.array.syntax"
      >構文</link>の節に記述したように、角括弧の間
      ('<literal>[</literal>'および'<literal>]</literal>')に式がなけれ
      ばならないためです。これは、次のように書くことが可能であることを
      意味します。
      <informalexample>
       <programlisting role="php">
echo $arr[ foo(true) ];        
       </programlisting>
      </informalexample>
      これは、関数の出力を配列の添字として使用する例です。PHPは定数に
      ついても認識します。前に<literal>E_*</literal>を見たことがあるか
      もしれません。

      <informalexample>
       <programlisting role="php">
$error_descriptions[E_ERROR] = "A fatal error has occured";
$error_descriptions[E_WARNING] = "PHP issued a warning";
$error_descriptions[E_NOTICE] = "This is just an informal notice";
       </programlisting>
      </informalexample>
      最初の例の<literal>bar</literal>と全く同様に
      <literal>E_ERROR</literal> も有効な添字であることに注意して下さ
      い。しかし、実際には最後の例は次のように書くことと同じです。
      <informalexample>
       <programlisting role="php">
$error_descriptions[1] = "A fatal error has occured";
$error_descriptions[2] = "PHP issued a warning";
$error_descriptions[8] = "This is just an informal notice";
       </programlisting>
      </informalexample>
      これは、<literal>E_ERROR</literal> が <literal>1</literal>と等し
      いこと等によります。
     </para>
     <para>
      では、なぜ <literal>$foo[bar]</literal> は動作することが可能なの
      でしょう? それは、<literal>bar</literal> が定数式であることを
      期待される構文で使用されているためです。しかし、この場合、
      <literal>bar</literal> という名前の定数は存在しません。PHPは、
      この場合、あなたが文字列<literal>"bar"</literal>のようにリテラル
      <literal>bar</literal> を指定したが引用符を忘れたと仮定します。
     </para>
     <sect4>
      <title>では、なぜ間違っているのでしょう?</title>
      <para>
       将来的に、PHPは他の定数またはキーワードを追加したいと思うかもし
       れず、問題となる可能性があります。例えば、現在でも、特別なキー
       ワードであるために単語 <literal>empty</literal> および
       <literal>default</literal>を使用することはできません。 
       <!-- <jeroen>hmm... i'm doubting this myself. Finish it if you like</jeroen>
       But probably 
       the most threatening
       thing is yourself, or whoever will maintain the script. You'll 
       maybe get very strange behaviour, and 
       -->
      </para>
      <para>
       そして、これらの議論が助けにならない場合：この構文は過去のもので
       あり、将来的に動作しなくなる可能性があります。
      </para>
      <tip>
       <simpara>
	<link
	linkend="function.error-reporting">error_reporting</link> を
	<literal>E_ALL</literal> に変えた場合、PHPがこの構造が使用され
	ているところ見付ける度に警告が生成されます。この機能は、他の過
	去の「機能」についても有効です。
        (スクリプトに行 <literal>error_reporting(E_ALL);</literal> を
	置いて下さい)
       </simpara>
      </tip>
      <note>
       <simpara>
	2重引用符で括られた<type>string</type>の中で他の構文が有効です。
	より詳細については、<link
	linkend="language.types.string.parsing">文字列の中の変数
	</link> を参照下さい。
       </simpara>
      </note>
     </sect4>
    </sect3>
   </sect2>

   <sect2 id="language.types.array.examples">
    <title>例</title>
    <para>
     PHPの配列型は非常に解りにくいため、ここで、配列の強力な機能を示す
     いくつかの例を紹介します。
    </para>
    <para>
      <informalexample>
       <programlisting role="php">
// this
$a = array( 'color' => 'red'
          , 'taste' => 'sweet'
          , 'shape' => 'round'
          , 'name'  => 'apple'
          ,            4        // キーは0になります
          );

// これは以下と完全に同じです。
$a['color'] = 'red';
$a['taste'] = 'sweet';
$a['shape'] = 'round';
$a['name'] = 'apple';
$a[]        = 4;        // キーは0になります

$b[] = 'a';
$b[] = 'b';
$b[] = 'c';
// この結果は配列 array( 0 => 'a' , 1 => 'b' , 2 => 'c' )
// または単に array('a', 'b', 'c') となります
       </programlisting>
      </informalexample>
     </para>
    
    <example>
     <title>array()の使用例</title>
     <programlisting role="php">
// マップを行う配列
$map = array( 'version'    =&gt; 4
            , 'OS'         =&gt; 'Linux'
            , 'lang'       =&gt; 'english'
            , 'short_tags' =&gt; true
            );
            
// 数値キーのみを有する
$array = array( 7
              , 8
              , 0
              , 156
              , -10
              );
// これは、array( 0 =&gt; 7, 1 =&gt; 8, ...) と同じです

$switching = array(         10 // key = 0
                  , 5    =&gt;  6
                  , 3    =&gt;  7 
                  , 'a'  =&gt;  4
                  ,         11 // key = 6 (最大の添字は5です)
                  , '8'  =&gt;  2 // key = 8 (整数!)
                  , '02' =&gt; 77 // key = '02'
                  , 0    =&gt; 12 // 値10は12で上書きされます
                  );
                  
<!-- TODO example of
- mixed keys
- overwriting keys
- integer keys as string
- using vars/functions as key/values
- mixed skipping
-->

// empty array
$empty = array();           
     </programlisting>
    </example>

    <example id="language.types.array.examples.loop">
     <title>コレクション</title>
     <programlisting role="php">
$colors = array('red','blue','green','yellow');

foreach ( $colors as $color )
{
    echo "Do you like $color?\n";
}

/* 出力:
Do you like red?
Do you like blue?
Do you like green?
Do you like yellow?
*/
     </programlisting>
    </example>
    
    <para>
     配列の値をこのようなループで直接変更することはできないことに注意
     して下さい。
     <!--
       Should be made possible, if you write:
       foreach ( $colors as &$color )
      
       See bug#3074
      -->
     これを解決するには、次のようにします。
     <example id="language.types.array.examples.changeloop">
      <title>コレクション</title>
      <programlisting role="php">
<link linkend="control-structures.foreach">foreach</link> ( $colors as $key => $color )
{
    // 動作しない:
    //$color = <link linkend="function.strtoupper">strtoupper</link>($color);
    
    // 動作する:
    $colors[$key] = <link linkend="function.strtoupper">strtoupper</link>($color);
}
<link linkend="function.print-r">print_r</link>($colors);

/* 出力:
Array
(
    [0] => RED
    [1] => BLUE
    [2] => GREEN
    [3] => YELLOW
)
*/
      </programlisting>
     </example>
    </para>
    <para>
     この例は、1から始まる配列を作成します。
     <example>
      <title>1から始まる添字</title>
      <programlisting role="php">
$firstquarter  = array(1 => 'January', 'February', 'March');
<link linkend="function.print-r">print_r</link>($firstquarter);

/* 出力:
Array 
(
    [1] => 'January'
    [2] => 'February'
    [3] => 'March'
)
*/        
      </programlisting>
     </example>
    </para>
    <example>
     <title>配列に代入する</title>
     <programlisting role="php">
// <link linkend="ref.dir">ディレクトリ</link>から全てのアイテムを配列に代入する
$handle = <link linkend="function.opendir">opendir</link>('.');
while ( $file = <link linkend="function.readdir">readdir</link>($handle) ) 
{
    $files[] = $file;
}
<link linkend="function.closedir">closedir</link>($handle); 
     </programlisting>
    </example>
    <para>
     配列には順番が付けられます。異なったソート関数を用いて順番を変更
     することも可能です。より詳細な情報については、<link
     linkend="ref.array">配列関数</link> を参照下さい。
    </para>
    <example>
     <title>配列のソート</title>
     <programlisting role="php">
<link linkend="function.sort">sort</link>($files);
<link linkend="function.print-r">print_r</link>($files);
     </programlisting>
    </example>
    <para>
     配列の値は何でも良いため、その値を他の配列とすることも可能です。
     これにより、再帰的な配列や多次元の配列を作成することが可能です。
    </para>
    <example>
     <title>再帰および多次元配列</title>
     <programlisting role="php">
$fruits = array ( "fruits"  =&gt; array ( "a" =&gt; "orange"
                                     , "b" =&gt; "banana"
                                     , "c" =&gt; "apple"
                                     )
                , "numbers" =&gt; array ( 1
                                     , 2
                                     , 3
                                     , 4
                                     , 5
                                     , 6
                                     )
                , "holes"   =&gt; array (      "first"
                                     , 5 =&gt; "second"
                                     ,      "third"
                                     )
                );
    
<!-- quite duplicate...
$a = array(
     "apple"  => array(
          "color"  => "red",
          "taste"  => "sweet",
          "shape"  => "round"
     ),
     "orange"  => array(
          "color"  => "orange",
          "taste"  => "tart",
          "shape"  => "round"
     ),
     "banana"  => array(
          "color"  => "yellow",
          "taste"  => "paste-y",
          "shape"  => "banana-shaped"
     )
);
-->
     </programlisting>
    </example>

   </sect2>
   
   <!-- TODO
   <sect2>
    <title>Misc</title>
   
   </sect2>
   
   - example multi-dim with $arr[bla][bla] syntax
   - converting to array
   - warning about references
   - note that assigning is copy (usually...)
   
   
   -->  

<!-- there is no such thing as multi/singel dim arrays (at least in PHP4) 
   <sect2 id="language.types.array.single-dim">
    <title>Single Dimension Arrays</title>

    <para>
     PHP supports both scalar and associative arrays. In fact, there
     is no difference between the two.  You can create an array using
     the 
     
     <function>list</function> 
     
     Nope
     
     
     
     
     or <function>array</function>
     functions, or you can explicitly set each array element value.
     <informalexample>
      <programlisting role="php"> 
$a[0] = "abc"; 
$a[1] = "def"; 
$b["foo"] = 13;
      </programlisting>
     </informalexample>
    </para>
    <para>
     You can also create an array by simply adding values to the
     array. When you assign a value to an array variable using empty
     brackets, the value will be added onto the end of the array.
     <informalexample>
      <programlisting role="php"> 
$a[] = "hello"; // $a[2] == "hello"
$a[] = "world"; // $a[3] == "world" 
      </programlisting>
     </informalexample>
    </para>
    <para>
     Arrays may be sorted using the <function>asort</function>,
     <function>arsort</function>, <function>ksort</function>,
     <function>rsort</function>, <function>sort</function>,
     <function>uasort</function>, <function>usort</function>, and
     <function>uksort</function> functions depending on the type of
     sort you want.
    </para>
    <para>
     You can count the number of items in an array using the
     <function>count</function> function.
    </para>
    <para>
     You can traverse an array using <function>next</function> and
     <function>prev</function> functions.  Another common way to
     traverse an array is to use the <function>each</function>
     function.
    </para>
   </sect2>

   <sect2 id="language.types.array.multi-dim">
    <title>Multi-Dimensional Arrays</title>

    <para>
     Multi-dimensional arrays are actually pretty simple.  For each
     dimension of the array, you add another [key] value to the end:
     <informalexample>
      <programlisting role="php"> 
$a[1]      = $f;               # one dimensional examples
$a["foo"]  = $f;   

$a[1][0]     = $f;             # two dimensional
$a["foo"][2] = $f;             # (you can mix numeric and associative indices)
$a[3]["bar"] = $f;             # (you can mix numeric and associative indices)

$a["foo"][4]["bar"][0] = $f;   # four dimensional!
      </programlisting>
     </informalexample>
    </para>
    <para>
     In PHP 3 it is not possible to reference multidimensional arrays
     directly within strings. For instance, the following will not
     have the desired result:
     <informalexample>
      <programlisting role="php"> 
$a[3]['bar'] = 'Bob';
echo "This won't work: $a[3][bar]";
      </programlisting>
     </informalexample>
     In PHP 3, the above will output <computeroutput>This won't work:
     Array[bar]</computeroutput>. The string concatenation operator,
     however, can be used to overcome this:
     <informalexample>
      <programlisting role="php">
$a[3]['bar'] = 'Bob';
echo "This will work: " . $a[3]['bar'];
      </programlisting>
     </informalexample>
    </para>
    <para>
     In PHP 4, however, the whole problem may be circumvented by
     enclosing the array reference (inside the string) in curly
     braces:
     <informalexample>
      <programlisting role="php">
$a[3]['bar'] = 'Bob';
echo "This will work: {$a[3][bar]}";
      </programlisting>
     </informalexample>
    </para>
    <para>
     You can "fill up" multi-dimensional arrays in many ways, but the
     trickiest one to understand is how to use the
     <function>array</function> command for associative arrays.  These
     two snippets of code fill up the one-dimensional array in the
     same way:
     <informalexample>
      <programlisting role="php"> 
# Example 1:

$a["color"]	= "red";
$a["taste"]	= "sweet";
$a["shape"]	= "round";
$a["name"]	= "apple";
$a[3]		= 4;

# Example 2:
$a = array(
     "color" => "red",
     "taste" => "sweet",
     "shape" => "round",
     "name"  => "apple",
     3       => 4
);
      </programlisting>
     </informalexample>
    </para>
    <para>
     The <function>array</function> function can be nested for
     multi-dimensional arrays:
     <informalexample>
      <programlisting role="php"> 
&lt;?php
$a = array(
     "apple"  => array(
          "color"  => "red",
          "taste"  => "sweet",
          "shape"  => "round"
     ),
     "orange"  => array(
          "color"  => "orange",
          "taste"  => "tart",
          "shape"  => "round"
     ),
     "banana"  => array(
          "color"  => "yellow",
          "taste"  => "paste-y",
          "shape"  => "banana-shaped"
     )
);

echo $a["apple"]["taste"];    # will output "sweet"
?>
      </programlisting>
     </informalexample>
    </para>

   </sect2>
   
   -->
  </sect1>

  <sect1 id="language.types.object">
   <title>オブジェクト</title>
   
   <sect2 id="language.types.object.init">
    <title>オブジェクトの初期化</title>

    <para>
     オブジェクトを初期化するためには、<literal>new</literal>命令
     によりオブジェクトのインスタンスを変数に作成します。

     <informalexample>
      <programlisting role="php">
&lt;?php
class foo {
    function do_foo () { 
        echo "Doing foo."; 
    }
}

$bar = new foo;
$bar -> do_foo ();
?>
      </programlisting>
     </informalexample>
    </para>

    <simpara>
     詳細な事項については、
     <link linkend="language.oop">クラスおよびオブジェクト</link>に
     関するセクションを参照下さい。
    </simpara>

   </sect2>
  </sect1>

  <sect1 id="language.types.resource">
   <title>リソース</title>
    
   <para>
    リソースは特別な変数であり、外部リソースへのリファレンスを保持して
     います。リソースは、特別な関数により作成され、使用されます。
    これらの関数および対応する全てのリソース型の一覧については、
    <link linkend="resource">付録</link> を参照下さい。
   </para>
   
   <note>
    <simpara>
     リソース型は、PHP 4で導入されました。
    </simpara>
   </note>
   
   <sect2 id="language.types.resource.self-destruct">
    <title>リソースの開放</title>
    
    <para>
     PHP4のZendエンジンに導入されたリファレンスカウンティングシステム
     のおかげで、あるリソースがもう参照されなくなった場合に(Javaと全く
     同様に)、そのリソースは自動的に削除されます。この場合、このリソー
     スが作成した全てのリソースはガーベッジコレクタにより開放されます。
     このため、free_result 関数を用いて手動でメモリを開放する必要が生
     じるのはまれです。
     <note>
      <simpara>
       持続的データベース接続は特別で、ガーベッジコレクタにより破棄さ
       れません。<link 
       linkend="features.persistent-connections">持続的接続</link>も参
       照下さい。
      </simpara>
     </note>
    </para>
    
   </sect2>
   
  </sect1>
    
  <sect1 id="language.types.null">
   <title>ヌル</title>
    
   <para>
    特別な <literal>ヌル</literal>値は、ある変数が値を持たないことを表
    します。
   </para>
   <note>
    <simpara>
     ヌル型は、PHP 4で導入されました。
    </simpara>
   </note>
   
   <sect2 id="language.types.null.syntax">
    <title>構文</title>
    <para>
     ヌル型の値は一つだけで、大文字小文字を区別しないキーワード
     &null;です。
     <informalexample>
      <programlisting role="php">
$var = Null;       
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  
  </sect1>

  <sect1 id="language.types.type-juggling">
   <title>型の相互変換</title>

   <simpara>
    PHP は、変数定義時に明示的な型定義を必要と(または、サポート)しませ
    ん。ある変数の型は、その変数が使用される文により定義されます。これ
    は、ある文字列を変数 <parameter>var</parameter> に代入した場合には、
    <parameter>var</parameter> は文字列になることを意味しています。あ
    る整数値を <parameter>var</parameter> に代入した場合には、その変数
    は整数になります。
   </simpara>

   <para>
    PHP の自動型変換の例の一つは、加算演算子 '+' です。
    オペランドのどれかがfloatの場合、全てのオペランドはfloatとして評価
    され、結果はfloatになります。
    その他の場合、オペランドは整数として解釈され、結果も整数になります。
    この自動型変換はオペランド自体の型を変更するものではないということに
    注意してください。
    変わるのは、オペランドがどのように評価されるかだけです。
    <informalexample>
     <programlisting role="php">
$foo = "0";  // $foo は文字列です (ASCII 48)
<!-- bad example, no real operator (must be used with variable, modifies it too)
$foo++;      // $foo は文字列 "1" です (ASCII 49)
-->
$foo += 2;   // ここでは、$foo は整数です (2)
$foo = $foo + 1.3;  // ここでは、$foo はfloatです (3.3)
$foo = 5 + "10 Little Piggies";    // $foo は整数です (15)
$foo = 5 + "10 Small Pigs";   // $foo は整数です (15)
<!--

TODO: explain ++/- - behaviour with strings

examples:

++'001' = '002'
++'abc' = 'abd'
++'xyz' = 'xza'
++'9.9' = '9.0'
++'-3'  = '-4'
- -'9'   = 8 (integer!)
- -'5.5' = '5.5'
- -'-9'  = -10 (integer)
- -'09'  = 8 (integer)
- -'abc' = 'abc'

-->
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    最後の二つの例が奇妙に思える場合には、
    <link linkend="language.types.string.conversion">文字列変換</link>を
    参照ください。
   </simpara>
   <simpara>
    ある変数を強制的にある特定の型として評価させたい場合には、
    <link linkend="language.types.typecasting">型キャスト</link> の
    セクションを参照ください。ある変数の型を変更したい場合には、
    <function>settype</function> を参照してください。
   </simpara>
   <para>
    本節の例をテストしたい場合には、
    <function>var_dump</function> を使用することが可能です。
   </para>
   <note>
    <para>
     配列への自動変換の動作は現時点で定義されていません。
     <informalexample>
      <programlisting role="php">
$a = 1;       // $a は整数です
$a[0] = "f";  // $a は配列になり、$a[0] には "f" が入ります
      </programlisting>
     </informalexample>
    </para>
    <para>
     上の例で明らかに $a は配列になりますが、最初の要素は 'f' になります。
     次の例を見てみましょう。
     <informalexample>
      <programlisting role="php">
$a = "1";     // $a は文字列です。
$a[0] = "f";  // 文字列オフセットは何ですか? どうなりますか?
      </programlisting>
     </informalexample>
    </para>
    <para>
     PHPは文字列への添字を配列への添字と同じ構文を使用してサポートして
     いるため、上の例は、$a は最初の要素が "f" の配列となるのか
     "f" が文字列 $a の最初の文字になるのかが不明であるという問題を生じます。
    </para>
    <para>
     このため、最新バージョンの PHP 3.0.12 および PHP 4.0b3-RC4 では、
     この自動変換の結果は未定義(undefined)とみなします。
     しかし、修正方法が議論されています。
    </para>
   </note>

   <sect2 id="language.types.typecasting">
    <title>型キャスト</title>

    <para>
     PHP の型キャストは、C 言語と同様に動作します。つまり、
     変換しようとする型の?前をキャストする変数の前に括弧に入れて
     置きます。
     <informalexample>
      <programlisting role="php">
$foo = 10;   // $foo は整数です
$bar = (double) $foo;   // $bar は倍精度実数です
      </programlisting>
     </informalexample>
    </para>
    <para>
     使用可能なキャストを以下に示します。
     <itemizedlist>
      <listitem>
       <simpara>(int), (integer) - 整数へのキャスト</simpara>
      </listitem>
      <listitem>
       <simpara>(float), (double), (real) - floatへのキャスト</simpara>
      </listitem>
      <listitem>
       <simpara>(string) - 文字列へのキャスト</simpara>
      </listitem>
      <listitem>
       <simpara>(array) - 配列へのキャスト</simpara>
      </listitem>
      <listitem>
       <simpara>(object) - オブジェクトへのキャスト</simpara>
      </listitem>
     </itemizedlist>
    </para>
    <tip>
     <simpara>
      文字列に変数をキャストする代わりに、2重引用符で変数を括ることも
      可能です。
      <!-- TODO: example -->
     </simpara>
    </tip>

    <para>
     括弧の中でタブとスペースを使用することができることに注意してくだ
     さい。従って、次の文は、機能的に等価です。
     <informalexample>
      <programlisting role="php">
$foo = (int) $bar;
$foo = ( int ) $bar;
      </programlisting>
     </informalexample>
    </para>
    <para>
     型の間でキャストを行う際の動作は、必ずしも明確ではありません。詳
     細については、以下の節を参照下さい。

     <itemizedlist>
      <listitem>
       <simpara>
	<link linkend="language.types.boolean.casting">論理値への変換
	</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
	<link linkend="language.types.integer.casting">整数への変換
	</link>
       </simpara>
      </listitem>
      <!-- don't exist yet
     <listitem>
     <simpara><link linkend="language.types.double.casting">Converting to 
      float</link></simpara>
     </listitem>
     <listitem>
     <simpara><link linkend="language.types.string.casting">Converting to 
      string</link></simpara>
     </listitem>
     <listitem>
     <simpara><link linkend="language.types.array.casting">Converting to 
      array</link></simpara>
     </listitem>
     <listitem>
     <simpara><link linkend="language.types.object.casting">Converting to 
      object</link></simpara>
     </listitem>
     <listitem>
     <simpara><link linkend="language.types.resource.casting">Converting to 
      resource</link></simpara>
     </listitem>
     <listitem>
     <simpara><link linkend="language.types.null.casting">Converting to 
      &null;</link></simpara>
     </listitem>
      -->
     </itemizedlist>
    
    </para>
    <para>
     <!-- TODO: move to 'converting to string' -->
     配列から文字列にキャストまたは強制的な変換を行った場合、結果は、
     単語<literal>Array</literal>となります。オブジェクトから文字列に
     キャストまたは強制的な変換を行った場合、結果は、単語
     <literal>Object</literal>となります。
     
     <!-- not with my PHP, not even a notice... maybe in PHP3? 
     Does someone know? 
     
     In both cases a warning will
     be issued. -->
    </para>
    <para>
     スカラーまたは文字列変数から配列にキャストを行う時、変数は配列の
     最初の要素になります。
     <informalexample>
      <programlisting role="php">
$var = 'ciao';
$arr = (array) $var;
echo $arr[0];  // 'ciao' を出力します。
      </programlisting>
     </informalexample>
    </para>
    <para>
     スカラーまたは文字列変数からオブジェクトにキャストを行う時、変数
     はオブジェ¯トの属性の一つになります。その属性の名前は 'scalar' に
     なります。
     <informalexample>
      <programlisting role="php">
$var = 'ciao';
$obj = (object) $var;
echo $obj-&gt;scalar;  // 'ciao' を出力します。
      </programlisting>
     </informalexample>
    </para>

   </sect2>
  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
