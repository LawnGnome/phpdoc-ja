<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.13 $ -->
<!-- EN-Revision: 1.37 Maintainer: hirokawa Status: ready -->
 <chapter id="language.references">
  <title>リファレンスの説明</title>
  
  <sect1 id="language.references.whatare">
   <title>リファレンスとは?</title>
   <simpara>
    PHPにおいてリファレンスは、同じ変数の内容を異なった名前でコールす
    ることを意味します。これはCポインタのようなものではなく、シンボル
    テーブルのエイリアスです。PHPでは、変数名と変数の内容は異なってお
    り、このため、同じ内容は異なった複数の名前を有する事が可能である
    ことに注意してください。最も良く似ているのは、UNIXのファイル名とファ
    イルの関係です。この場合、変数名はディレクトリエントリ、変数の内
    容はファイル自体に対応します。リファレンスは、UNIXファイルシステ
    ムのハードリンクのようなものであると考えられます。
   </simpara>
  </sect1>
  
  <sect1 id="language.references.whatdo">
   <title>リファレンスが行うことは何ですか?</title>
   <para>
    PHPのリファレンスにより二つの変数が同じ内容を参照することが可能で
    す。つまり、以下のようなものを実行した場合です。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a =& $b;
?>
]]>
     </programlisting>
    </informalexample>
    この場合、<varname>$a</varname>と<varname>$b</varname>は同じ変数を
    指します。
    <note>
     <para>
      ここで、<varname>$a</varname>と<varname>$b</varname>は完全に同じ
      で、<varname>$a</varname>が<varname>$b</varname>を指しているわけ
      ではなく、その逆でもありません。<varname>$a</varname>と
      <varname>$b</varname>は同じ場所を指しているのです。
     </para>
    </note>
   </para>
   <note>
    <para>
     If array with references is copied, its values are not dereferenced.
     This is valid also for arrays passed by value to functions.
    </para>
   </note>
   <para>
    同じ構文は、リファレンスを返す関数や<literal>new</literal>演算子で
    も使用可能です。(PHP 4.0.4 以降)
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$bar =& new fooclass();
$foo =& find_var($bar);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <warning>
    <para>
     If you assign a reference to a variable declared <literal>global</literal>
     inside a function, the reference will be visible only inside the function.
     You can avoid this by using the <varname>$GLOBALS</varname> array.
     <example>
      <title>Referencing global variables inside function</title>
      <programlisting role="php">
<![CDATA[
<?php
$var1 = "Example variable";
$var2 = "";

function global_references($use_globals)
{
    global $var1, $var2;
    if (!$use_globals) {
        $var2 =& $var1; // visible only inside the function
    } else {
        $GLOBALS["var2"] =& $var1; // visible also in global context
    }
}

global_references(false);
echo "var2 is set to '$var2'\n"; // var2 is set to ''
global_references(true);
echo "var2 is set to '$var2'\n"; // var2 is set to 'Example variable'
?>
]]>
      </programlisting>
     </example>
     Think about <literal>global $var;</literal> as a shortcut to <literal>$var
     =&amp; $GLOBALS['var'];</literal>. Thus assigning other reference
     to <literal>$var</literal> only changes the local variable's reference.
    </para>
   </warning>
   <note>
    <para>
     <literal>&amp;</literal>演算子を使用しないとオブジェクトのコピーが
     生成されます。もし<literal>$this</literal>をクラスの中で使用すると、
     この変数は、そのクラスの現在のインスタンスを指します。<literal>
     &amp;</literal>無しに値を割り当てるとインスタンス(つまりオブジェクト)
     のコピーが生成され、<literal>$this</literal>はコピーを指すことに
     なります。この挙動が望ましくない場合もあるでしょう。というのも普通は
     パフォーマンスとメモリ効率の面から考えて動作するインスタンスは一つ
     で十分だからです。
    </para>
    <para>
     <literal>@new</literal>のように使用することにより、コンストラクタ
     におけるエラーを<literal>@</literal>演算子を使用することが
     できますが、これは、<literal>&amp;new</literal>命令を用いた場合は
     動作しません。これは、Zend Engineの制限であり、パースエラーを
     発生します。
    </para>
   </note>
   <para>
    リファレンスの第2の使用法は、変数のリファレンス渡しです。この場合、
    関数でローカル変数が作成され、コール側の変数と同じ内容へのリファレ
    ンスとなります。例を示します。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function foo(&$var) 
{
  $var++;
}

$a=5;
foo($a);
?>
]]>
     </programlisting>
    </informalexample>
    この結果、<varname>$a</varname> は 6となります。これは、関数
    <varname>foo</varname>の中では、変数<varname>$var</varname>は
    <varname>$a</varname>と同じ内容を指しているためです。
    <link linkend="language.references.pass">リファレンス渡し</link>
    に関するより詳細な説明も参照ください。
   </para>
   <simpara>
    リファレンスの第3の使用法は、
    <link linkend="language.references.return">リファレンスによる返り値
    </link>です。
   </simpara>
  </sect1>
  
  <sect1 id="language.references.arent">
   <title>リファレンスが行わないことは?</title>
   <para>
    上記のように、リファレンスはポインタではありません。このため、次の
    例は期待通りに動作しません。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function foo(&$var) {
  $var =& $GLOBALS["baz"];
}
foo($bar);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    ここでの動作としては、関数<varname>foo</varname>の
    <varname>$var</varname>はコール側の<varname>$bar</varname>
    と結合されますが、<varname>$GLOBALS["baz"]</varname>
    に再結合されるといったものになります。<varname>$bar</varname>
    は関数<varname>foo</varname>で利用できないため、
    リファレンス以外にはコール側の変数スコープにある
    <varname>$bar</varname>を何かに結合する手段はありません。
    (この変数は、<varname>$var</varname>として表されていますが、
    <varname>$var</varname>はその変数の内容のみを有しており、
    コール側のシンボルテーブルで名前と変数を結合したものではありません。)
    You can use <link linkend="language.references.return">returning
    references</link> to reference variables selected by the function.
   </simpara>
  </sect1>
  
  <sect1 id="language.references.pass">
   <title>リファレンス渡し</title>
   <para>
    リファレンスにより関数に変数を渡すことが可能です。この場合、関数内
    でその引数を修正可能になります。構文は次のようになります。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function foo(&$var) {
    $var++;
}

$a=5;
foo($a);
// $a はここでは 6 です
?>
]]>
     </programlisting>
    </informalexample>
    関数コールの際には、リファレンス記号がないことに注意してください。関
    数定義にのみリファレンス記号があります。リファレンスで正しく引数を
    渡すには、関数定義のみで十分です。
  </para>
  <para>
    次のものはリファレンスで渡すことが可能です。
    <itemizedlist>
     <listitem>
      <simpara>
       変数、すなわち、<literal>foo($a)</literal>
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       new 命令、すなわち、<literal>foo(new foobar())</literal>
      </simpara>
     </listitem>
     <listitem>
      <para>
       関数から返されるリファレンスは、次のようになります。
       <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function &bar()
{
   $a = 5;
   return $a;
}
foo(bar());
?>
]]>
    </programlisting>
       </informalexample>
       <link linkend="language.references.return">リファレンスによる返
       り値</link> に関する説明も参照ください。
      </para>
     </listitem>
    </itemizedlist>
   </para>
   <para>
    他の式は、結果が未定義となるため、リファレンスで渡すべきではありま
    せん。例えば、リファレンスで渡す次の例は、無効です。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function bar() // & がないことに注意
{
        $a = 5;
        return $a;
}
foo(bar());

foo($a = 5); // 式、変数ではない
foo(5); // 定数、変数ではない
?>
]]>
     </programlisting>
    </informalexample>
    以上の説明は、PHP 4.0.4 以降用です。
   </para>
  </sect1>

  <sect1 id="language.references.return">
   <title>リファレンスによる返り値</title>
   <para>
    リファレンスを返すことは、結合する変数を見付けるために関数を使用し
    たい場合に便利です。リファレンスを返す場合、次の構文を使用して下さ
    い。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function &find_var($param) {
  /* ...コード... */
  return $found_var;
}

$foo =& find_var($bar);
$foo->x = 2; 
?>
]]>
     </programlisting>
    </informalexample>
    この例では、関数<varname>find_var</varname>により返された
    オブジェクトのプロパティが、設定されます。リファレンス構文を使用し
    ない場合のようにコピーとなるわけではありません。
   </para>
   <note>
    <simpara>
     パラメータを渡す場合と異なり、ここでは、通常のようにコピーではな
     くリファレンスで返り値を指定し、リファレンス結合を指定するために
     両方の場所で<literal>&amp;</literal>を使用する必要があります。
     <varname>$foo</varname>について行われたのは、通常の代入ではありま
     せん。
    </simpara>
   </note>
  </sect1>
  
  <sect1 id="language.references.unset">
  <title>リファレンスの削除</title>
   <para>
    リファレンスを削除することは、ちょうど変数名と変数の内容の結合を解
    除したことに相当します。これは、変数の内容が破棄されることを意味し
    ません。例えば、
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b =& $a;
unset($a);
?>
]]>
     </programlisting>
    </informalexample>
    は、<varname>$b</varname>を削除せず、<varname>$a</varname>のみを削
    除します。
   </para>
   <simpara>
    ここでも、UNIXの<command>unlink</command>コールと類似したものと考
    えると便利です。
   </simpara>
  </sect1>
  
  <sect1 id="language.references.spot">
   <title>リファレンスの適用範囲</title>
   
   <simpara>
    PHPの多くの構文構造は、リファレンス機構を利用して実装されています。
    このため、前記のリファレンス結合に関する事項はこれらの構造について
    も適用されます。リファレンス渡しおよびリファレンスの返り値のような
    いくつかの構造について前節で記述されています。リファレンスを使用す
    る他の構造には次のものがあります。
   </simpara>
   
   <sect2 id="references.global">
    <title><literal>global</literal>リファレンス</title>

    <para>
     変数を<command>global $var</command>として宣言した場合、実際には
     グローバル変数へのリファレンスを作成したことになります。この意味
     は、次の例と同じです。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$var =& $GLOBALS["var"];
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     これは、例えば、<varname>$var</varname>を削除してもグローバル変数
     は削除されないことを意味します。
    </simpara>
   </sect2>
   
   <sect2 id="references.this">
    <title><literal>$this</literal></title>
    
    <simpara>
     オブジェクトのメソッドでは、<varname>$this</varname> は常にコール
     側のオブジェクトへのリファレンスです。
    </simpara>
   </sect2>
  </sect1>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
