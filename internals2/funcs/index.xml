<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 322131 Maintainer: takagi Status: ready -->
 <chapter xml:id="internals2.funcs" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>関数の作成</title>
  <para>
   拡張モジュールの主要な要素のひとつが、
   PHP のユーザ空間にエクスポートする関数です。
   オブジェクト指向の拡張モジュールを書こうとしている場合でも、
   この章を読んでおくことをおすすめします。
   ここにある情報の大半はメソッドを書く場合にもあてはまるからです。
  </para>

  <para>
   <link linkend="internals2.buildsys.skeleton">ext_skel</link>
   で新しい基盤を作った後などに新しい関数を追加するには、
   その内容を C の関数として実装して、
   作った関数のエントリを拡張モジュールの関数テーブルに追加します。
   関数のエントリには、引数情報の構造体へのポインタを含めることができます。
   パラメータを参照で渡したり参照を返したりするのでない限り、
   引数情報を渡すことは必須ではありません。しかし、情報を渡しておけば
   PHP の <link linkend="book.reflection">Reflection API</link>
   からアクセスできるようになります。以下の例でわかるとおり、
   パラメータはそのまま実装へ渡されるわけではなく
   スタックに積んで渡されます。
   このスタックは関数の実装によってチェックされます。
   関数の実装は直接の情報源とはなりません。
  </para>

  <example xml:id="internals2.funcs.index.minimalext">
   <title>関数をひとつ持つ最小限の PHP 拡張モジュール</title>
   <programlisting role="c">
<![CDATA[
/* {{{ proto void hello_world()
       Do nothing */
PHP_FUNCTION(hello_world)
{
}
/* }}} */

/* {{{ arginfo_hello_world */
ZEND_BEGIN_ARG_INFO(arginfo_hello_world, 0)
ZEND_END_ARG_INFO()
/* }}} */

/* {{{ demo_functions */
function_entry demo_functions[] = {
    PHP_FE(hello_world, arginfo_hello_world)
    {NULL, NULL, NULL}
}
/* }}} */

/* {{{ demo_module_enry */
zend_module_entry demo_module_entry = {
#if ZEND_MODULE_API_NO >= 20010901
    STANDARD_MODULE_HEADER,
#endif
    "demo",
    demo_functions,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
#if ZEND_MODULE_API_NO >= 20010901
    "1.0.0",
#en
    STANDARD_MODULE_PROPERTIES
}
/* }}} */
]]>
   </programlisting>
  </example>

  <para>
   この例では、上で説明した要素やモジュールの構造を確認することができます。
   この構造に見覚えがない場合は
   <xref linkend="internals2.structure.modstruct"/> を見直してみましょう。
  </para>

  <para>
   この拡張モジュールの最初の部分は、実際の実装です。
   慣習として、エクスポートする関数の前には二行のコメントをつけることになっています。
   コメントには、利用者向けの関数プロトタイプと
   一行での短い説明を記述します。
  </para>

  <para>
   PHP の異なるバージョン間でソースコードの互換性を保持するため、
   関数の宣言を <code>PHP_FUNCTION</code> マクロでラップしています。
   PHP 5.3 を使っている場合、コンパイラのプリプロセッサは
   これを次のような関数に変換します。
  </para>

  <screen>
<![CDATA[
void zif_hello_world(int ht, zval *return_value, zval **return_value_ptr,
                     zval *this_ptr, int return_value_used TSRMLS_DC)
{
}
]]>
  </screen>

  <para>
   ユーザ空間にエクスポートする関数や C の別の関数との名前の衝突を避けるため、
   エクスポートする関数の C のシンボルには先頭に <code>zif_</code> を付け加えます。
   また、このプロトタイプでは引数スタックを参照していないことにもお気づきでしょう。
   PHP から渡されたパラメータへのアクセス方法については後で説明します。
   この表は、C レベルでのパラメータをまとめたものです。これらは
   <code>INTERNAL_FUNCTION_PARAMETERS</code> マクロでも定義されています。
   これらのパラメータは、PHP のバージョンが変われば変化する可能性があることに注意しましょう。
   提供されているマクロ経由で使わなければなりません。
  </para>

  <table xml:id="internals2.funcs.index.internal-func-params">
   <title>INTERNAL_FUNCTION_PARAMETERS</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>名前と型</entry>
      <entry>説明</entry>
      <entry>アクセス用のマクロ</entry>
     </row>
    </thead>
    <tbody>
                                                    
     <row>
      <entry><code>int ht</code></entry>
      <entry>ユーザから渡された実際のパラメータの数</entry>
      <entry><code>ZEND_NUM_ARGS()</code></entry>
     </row>

     <row>
      <entry><code>zval *return_value</code></entry>
      <entry>
       PHP 変数へのポインタ。ユーザに返す値をここに格納します。
       デフォルトの型は <code>IS_NULL</code> です。
      </entry>
      <entry><code>RETVAL_*</code>, <code>RETURN_*</code></entry>
     </row>

     <row>
      <entry><code>zval **return_value_ptr</code></entry>
      <entry>
       PHP に参照を返す場合は、ここに変数へのポインタを設定します。
       参照を返すことは推奨しません。
      </entry>
      <entry/>
     </row>

     <row>
      <entry><code>zval *this_ptr</code></entry>
      <entry>
       メソッドコールの場合に、これは
       <code>$this</code> オブジェクトを保持する PHP の変数を指します。
      </entry>
      <entry><code>getThis()</code></entry>
     </row>

     <row>
      <entry><code>int return_value_used</code></entry>
      <entry>
       返す値を呼び出し元で使うかどうかを示すフラグ。
      </entry>
      <entry/>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   先ほども説明したように、上の関数は単に NULL を返すだけで他に何もしません。
   PHP 側からこの関数をコールするときには任意の数のパラメータを指定することができます。
   もう少し実用的な関数は、大きく四つの部分にわけることができます。
  </para>

  <orderedlist>
   <listitem>
    <para>
     ローカル変数の宣言。C ではローカル変数の宣言が必要です。
     これは関数の先頭で行います。
    </para>
   </listitem>
   <listitem>
    <para>
     パラメータのパース。
     PHP はパラメータを特別なスタックに積んで渡すので、
     そこからパラメータを取り出して読み込み、型を検証し、
     必要に応じてキャストし、何か問題があれば回避します。
    </para>
   </listitem>
   <listitem>
    <para>
     実際のロジック。必要な処理を書きます。
    </para>
   </listitem>
   <listitem>
    <para>
     返り値の設定、後始末。そして結果を返します。
    </para>
   </listitem>
  </orderedlist>

  <para>
   場合によってはこれらの順序は前後することもあります。
   特に最後のふたつは一緒になってしまうことも多いでしょう。
   しかし、この順序を守っておくほうがよいでしょう。
  </para>

  <example xml:id="internals2.funcs.index.simplefunc">
   <title>単純な関数</title>
   <programlisting role="c">
<![CDATA[
/* {{{ proto void hello_world(string name)
   Greets a user */
PHP_FUNCTION(hello_world)
{
    char *name;
    int name_len;

    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &name, &name_len) == FAILURE) {
        return;
    }

    php_printf("Hello %s!", name);

    RETURN_TRUE;
}
/* }}} */
]]>
   </programlisting>
  </example>

  <para>
   この関数は、先ほどの各部分を示したものです。
   まずは最後の行から見ていきましょう。<code>php_printf</code>
   は、容易に想像できるとは思いますが、標準 C の関数
   <code>printf</code> の PHP 版です。<code>printf</code> とは異なり、
   この関数はプロセスの <code>STDOUT</code> には出力せず
   現在の出力ストリームに表示します。出力ストリームはユーザ側でバッファリングされることもあります。
   PHP の API のほとんどはバイナリセーフではありません。<code>name</code>
   に NULL バイトが含まれている場合、<code>php_printf</code>
   はそれ以降を無視してしまうことに注意しましょう。
   バイナリセーフな出力には <code>PHPWRITE</code> を使わなければなりません。
  </para>

  <note>
   <simpara>
    一般に、データを直接出力ストリームに送るよりはユーザに文字列として返すことを推奨します。
    そうすれば、ユーザ側で何処に出力するかを決めさせることができます。
    この方針の例外は、画像のようなバイナリデータを扱うときです。
    そのようなデータを扱うための方法を API で用意しておく必要があります。
   </simpara>
  </note>

  <para>
   最後の行にあるマクロ <code>RETURN_TRUE</code> は三つのことを行います。
   <code>return_value</code> ポインタで取得した変数の型を <code>IS_BOOLEAN</code>
   に設定し、その値を <code>true</code> として、
   C の関数から処理を返します。
   つまり、このマクロを使うとメモリやその他のリソースの後始末も完了し、
   関数内のそれ以降のコードは実行されません。
  </para>

  <para>
   <code>zend_parse_parameters()</code> 関数の役割は、
   ユーザが渡したパラメータを引数スタックから読み込んで
   適切なキャストを施してローカルの C 変数に格納することです。
   ユーザが渡すパラメータの数が間違っていたりキャストに失敗したりした場合は、
   エラーを発生させて <code>FAILURE</code> を返します。
   この場合は何もせずに関数から抜けます。<code>return_value</code>
   は手を加えずそのままで、ユーザへの返り値はデフォルトの <code>NULL</code>
   となります。
  </para>

  <note>
   <simpara>
    <code>FAILURE</code> は <code>-1</code>、そして
    <code>SUCCESS</code> は <code>0</code> であることを覚えておきましょう。
    コードの可読性を考慮して、値を比較するときは常にこの定数をつかうべきです。
   </simpara>
  </note>

  <para>
   <code>zend_parse_parameters()</code> の最初のパラメータは、
   ユーザからその関数に渡された実際のパラメータの数です。
   この数は <code>ht</code> パラメータで渡されていますが、
   先に説明したように、今の実装ではそうなっているというだけに過ぎません。
   ここでは <code>ZEND_NUM_ARGS()</code> を使わなければなりません。
  </para>

  <para>
   PHP のスレッドセーフなリソースマネージャーとの互換性を考慮して、
   <code>TSRMLS_CC</code> でスレッドコンテキストも渡す必要があります。
   他の関数とは異なり、これは最後のパラメータとはなりません。
   <code>zend_parse_parameters</code> は可変個数のパラメータを受け付け、
   それは読み込むユーザパラメータの数に依存するからです。
  </para>

  <para>
   スレッドコンテキストの後には、想定しているパラメータを宣言します。
   各パラメータが文字列内の一文字として表され、それが型を示します。
   この例では文字列のパラメータを想定しているので、型の指定は単純に
   <code>"s"</code> となります。
  </para>

  <para>
   最後に渡すのは一つあるいは複数の C 変数へのポインタで、
   ここには変数の値やその他の情報が格納されます。
   今回のような文字列の場合は、
   NULL 終端の実際の文字列を表す <code>char*</code>
   と NULL バイトを含む文字列の長さを表す <code>int</code>
   になります。
  </para>

  <para>
   すべての型指定子とそれに対応する C の型については、ソース配布物の中にある
   <link xlink:href="&url.php.src.parameters.readme;">README.PARAMETER_PARSING_API</link>
   に説明があります。
   中でも重要な型について次の表にまとめました。
  </para>

  <table xml:id="internals2.funcs.index.zend-pars-params-types">
   <title>zend_parse_parameters() の型指定子</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>修飾子</entry>
      <entry>パラメータの型</entry>
      <entry>説明</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><code>b</code></entry>
      <entry><code>zend_bool</code></entry>
      <entry>Boolean 値</entry>
     </row>

     <row>
      <entry><code>l</code></entry>
      <entry><code>long</code></entry>
      <entry>integer (long) 値</entry>
     </row>

     <row>
      <entry><code>d</code></entry>
      <entry><code>double</code></entry>
      <entry>float (double) 値</entry>
     </row>

     <row>
      <entry><code>s</code></entry>
      <entry><code>char*, int</code></entry>
      <entry>バイナリセーフな文字列</entry>
     </row>

     <row>
      <entry><code>h</code></entry>
      <entry><code>HashTable*</code></entry>
      <entry>配列のハッシュテーブル</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
